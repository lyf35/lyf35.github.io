<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">
  <link rel="manifest" href="/images/site.webmanifest">
  <meta name="msapplication-config" content="/images/browserconfig.xml">
  <meta name="msvalidate.01" content="<meta name="msvalidate.01" content="5D3796A5DDB32CC875380613FB613833" />">
  <meta name="baidu-site-verification" content="<meta name="baidu-site-verification" content="kewHZtFYQk" />">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Helvetica:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-flat-top.min.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lyf35.github.io","root":"/","scheme":"Pisces","version":"8.0.0-rc.5","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="并发 定义 如果一个逻辑流的执行在时间上与另一个流重叠，称为并发流，这两个流被称为并发地运行。多个流并发执行的一般现象被简称为并发。在多线程的并发执行中，由于这些线程会共享地址空间，这就带来了一些必须要处理的问题。  备注—并发（concurrent）与并行（parallel）： 在计算机系统中，只要两个任务在时间上重叠就被称为并发，这一概念并不关心任务如何具体地被执行，与执行这些任务的处理器核数">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统-并发">
<meta property="og:url" content="http://lyf35.github.io/2020/10/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%B9%B6%E5%8F%91/index.html">
<meta property="og:site_name" content="Yufei Luo&#39;s Blog">
<meta property="og:description" content="并发 定义 如果一个逻辑流的执行在时间上与另一个流重叠，称为并发流，这两个流被称为并发地运行。多个流并发执行的一般现象被简称为并发。在多线程的并发执行中，由于这些线程会共享地址空间，这就带来了一些必须要处理的问题。  备注—并发（concurrent）与并行（parallel）： 在计算机系统中，只要两个任务在时间上重叠就被称为并发，这一概念并不关心任务如何具体地被执行，与执行这些任务的处理器核数">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-10-17T16:21:55.000Z">
<meta property="article:modified_time" content="2020-11-12T14:51:13.000Z">
<meta property="article:author" content="Yufei Luo">
<meta property="article:tag" content="计算机基础">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://lyf35.github.io/2020/10/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%B9%B6%E5%8F%91/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统-并发 | Yufei Luo's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
 <!--   <div class="headband"></div>-->

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Yufei Luo's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">But I was so much older then, I am younger than that now.</p>
      <img class="custom-logo-image" src="/images/logo.png" alt="Yufei Luo's Blog">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-计算机基础">

    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80" rel="section"><i class="fa fa-tags fa-fw"></i>计算机基础</a>

  </li>
        <li class="menu-item menu-item-机器学习">

    <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0" rel="section"><i class="fa fa-tags fa-fw"></i>机器学习</a>

  </li>
        <li class="menu-item menu-item-深度学习">

    <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0" rel="section"><i class="fa fa-tags fa-fw"></i>深度学习</a>

  </li>
        <li class="menu-item menu-item-工程实践">

    <a href="/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5" rel="section"><i class="fa fa-tags fa-fw"></i>工程实践</a>

  </li>
        <li class="menu-item menu-item-论文笔记">

    <a href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0" rel="section"><i class="fa fa-tags fa-fw"></i>论文笔记</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-number">1.</span> <span class="nav-text">并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.</span> <span class="nav-text">并发带来的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="nav-number">1.2.1.</span> <span class="nav-text">临界区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.2.2.</span> <span class="nav-text">竞态条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7"><span class="nav-number">1.2.3.</span> <span class="nav-text">不确定性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">2.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#api"><span class="nav-number">2.2.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.3.</span> <span class="nav-text">锁的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86"><span class="nav-number">2.3.1.</span> <span class="nav-text">评价标准</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E4%B8%AD%E6%96%AD"><span class="nav-number">2.3.2.</span> <span class="nav-text">控制中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">2.3.3.</span> <span class="nav-text">自旋锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%A1%AC%E4%BB%B6%E5%8E%9F%E8%AF%AD%E4%B8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">不同硬件原语下的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E5%B9%B6%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.3.3.1.1.</span> <span class="nav-text">测试并设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2"><span class="nav-number">2.3.3.1.2.</span> <span class="nav-text">比较并交换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%9D%A1%E4%BB%B6%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-number">2.3.3.1.3.</span> <span class="nav-text">链接的加载与条件式存储</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E8%87%AA%E6%97%8B%E8%BF%87%E5%A4%9A"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">解决自旋过多</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%94%BE%E5%BC%83cpu"><span class="nav-number">2.3.3.2.1.</span> <span class="nav-text">放弃CPU</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97"><span class="nav-number">2.3.3.2.2.</span> <span class="nav-text">使用队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81"><span class="nav-number">2.3.3.2.3.</span> <span class="nav-text">两阶段锁</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">3.</span> <span class="nav-text">条件变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="nav-number">3.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#api-1"><span class="nav-number">3.2.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%9C%89%E7%95%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E9%97%AE%E9%A2%98"><span class="nav-number">3.3.</span> <span class="nav-text">生产者&#x2F;消费者（有界缓冲区）问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="nav-number">3.3.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.2.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E6%9D%A1%E4%BB%B6"><span class="nav-number">3.4.</span> <span class="nav-text">覆盖条件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">4.</span> <span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="nav-number">4.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.2.</span> <span class="nav-text">信号量的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">4.3.</span> <span class="nav-text">信号量的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BD%9C%E4%B8%BA%E9%94%81"><span class="nav-number">4.3.1.</span> <span class="nav-text">二值信号量作为锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%94%A8%E4%BD%9C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">4.3.2.</span> <span class="nav-text">信号量用作条件变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">4.3.3.</span> <span class="nav-text">生产者&#x2F;消费者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%94%81"><span class="nav-number">4.3.4.</span> <span class="nav-text">读者—写者锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-number">4.3.5.</span> <span class="nav-text">哲学家就餐问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">5.</span> <span class="nav-text">常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E6%AD%BB%E9%94%81%E7%BC%BA%E9%99%B7"><span class="nav-number">5.1.</span> <span class="nav-text">非死锁缺陷</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9D%E5%8F%8D%E5%8E%9F%E5%AD%90%E6%80%A7%E7%BC%BA%E9%99%B7"><span class="nav-number">5.1.1.</span> <span class="nav-text">违反原子性缺陷</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9D%E5%8F%8D%E9%A1%BA%E5%BA%8F%E7%BC%BA%E9%99%B7"><span class="nav-number">5.1.2.</span> <span class="nav-text">违反顺序缺陷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%BC%BA%E9%99%B7"><span class="nav-number">5.2.</span> <span class="nav-text">死锁缺陷</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E7%94%9F%E5%8E%9F%E5%9B%A0"><span class="nav-number">5.2.1.</span> <span class="nav-text">发生原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E6%9D%A1%E4%BB%B6"><span class="nav-number">5.2.2.</span> <span class="nav-text">产生条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">5.2.3.</span> <span class="nav-text">死锁的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E9%98%B2"><span class="nav-number">5.2.3.1.</span> <span class="nav-text">预防</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85"><span class="nav-number">5.2.3.1.1.</span> <span class="nav-text">避免循环等待</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%8C%81%E6%9C%89%E5%B9%B6%E7%AD%89%E5%BE%85"><span class="nav-number">5.2.3.1.2.</span> <span class="nav-text">避免持有并等待</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8A%A2%E9%94%81"><span class="nav-number">5.2.3.1.3.</span> <span class="nav-text">抢锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E4%BA%92%E6%96%A5"><span class="nav-number">5.2.3.1.4.</span> <span class="nav-text">避免互斥</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E8%B0%83%E5%BA%A6%E9%81%BF%E5%85%8D"><span class="nav-number">5.2.3.2.</span> <span class="nav-text">通过调度避免</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%92%8C%E6%81%A2%E5%A4%8D"><span class="nav-number">5.2.3.3.</span> <span class="nav-text">检查和恢复</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B9%B6%E5%8F%91"><span class="nav-number">6.</span> <span class="nav-text">基于事件的并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3"><span class="nav-number">6.1.</span> <span class="nav-text">存在的问题与解决</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E4%BA%8B%E4%BB%B6"><span class="nav-number">6.1.1.</span> <span class="nav-text">接收事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">6.1.2.</span> <span class="nav-text">阻塞系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="nav-number">6.1.3.</span> <span class="nav-text">状态管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">6.1.4.</span> <span class="nav-text">其他</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yufei Luo"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Yufei Luo</p>
  <div class="site-description" itemprop="description">哪怕什么真理无穷，进一寸有进一寸的欢喜</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x5ZjM1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lyf35"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmx5ZjEyMzQwMDAwMDBAMTYzLmNvbQ==" title="E-Mail → mailto:lyf1234000000@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



      </section>
        <div class="back-to-top animated">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x5ZjM1" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lyf35.github.io/2020/10/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Yufei Luo">
      <meta itemprop="description" content="哪怕什么真理无穷，进一寸有进一寸的欢喜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yufei Luo's Blog">
    </span>

    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统-并发
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-18 00:21:55" itemprop="dateCreated datePublished" datetime="2020-10-18T00:21:55+08:00">2020-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-12 22:51:13" itemprop="dateModified" datetime="2020-11-12T22:51:13+08:00">2020-11-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">理论知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          
            <span id="/2020/10/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%B9%B6%E5%8F%91/" class="post-meta-item leancloud_visitors" data-flag-title="操作系统-并发" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="并发">并发</h1>
<h2 id="定义">定义</h2>
<p>如果一个逻辑流的执行在时间上与另一个流重叠，称为并发流，这两个流被称为并发地运行。多个流并发执行的一般现象被简称为<strong>并发</strong>。在多线程的并发执行中，由于这些线程会共享地址空间，这就带来了一些必须要处理的问题。</p>
<blockquote>
<p>备注—并发（concurrent）与并行（parallel）：</p>
<p>在计算机系统中，只要两个任务在时间上重叠就被称为并发，这一概念并不关心任务如何具体地被执行，与执行这些任务的处理器核数或者是计算机数无关。并发主要关注的是任务的抽象调度，相当于是站在任务安排者视角看到的东西。</p>
<p>并行是并发的一个真子集，指的是两个流并发地运行在不同的处理器核或者计算机上。并行关注的是任务的实际执行，相当于是站在任务执行者视角的概念。</p>
</blockquote>
<span id="more"></span>
<h2 id="并发带来的问题">并发带来的问题</h2>
<h3 id="临界区">临界区</h3>
<p>由于线程之间共享地址空间，因此可能会出现多个线程访问共享资源的情况，共享资源通常是一个变量或者数据结构。<strong>临界区</strong>（critical section）指的是访问共享资源的代码片段。</p>
<h3 id="竞态条件">竞态条件</h3>
<p>当多个执行线程大致同时进入临界区时，如果它们都试图更新共享的数据结构，则会导致非期望的结果，而这种结果通常也是我们不希望得到的。这种情况被称为<strong>竞态条件</strong>（race condition）。</p>
<h3 id="不确定性">不确定性</h3>
<p>如果程序中包含了一个或者多个竞态条件，那么程序的输出则会因运行而异，具体取决于哪些线程在何时运行。这样会导致结果出现<strong>不确定性</strong>（indeterminate），然而我们通常期望程序能给出一个确定的结果。</p>
<p>为了避免程序的不确定性，代码需要使用<strong>互斥</strong>（mutual exclusion）。通过这种方式，便可以保证只有一个线程进入临界区，从而避免出现竞态条件，产生确定的程序输出。</p>
<p>因此，我们需要硬件提供一些有用的指令，可以在这些指令之上构建一个通用的<strong>同步原语</strong>（synchronization primitive）集合，从而以同步和受控的方式访问临界区。</p>
<h1 id="锁">锁</h1>
<h2 id="概述">概述</h2>
<p>锁就是一个变量（因此需要声明一个锁变量才能使用它），这个锁变量保存了锁在某一时刻的状态：可用（没有线程持有锁）或占用（一个线程持有锁）。锁可以被使用在代码块的临界区周围，只有当某个线程占用锁时才能执行临界区的代码，并在临界区执行完成之后释放锁，供其它线程使用。通过这种方式，锁便为程序员提供了最小程度的调度控制，让程序员获得一些控制权，从而使得操作系统的调度变得可控。</p>
<p>在POSIX库中，锁被称为互斥量，因为它被用来提供线程之间的互斥。对于锁的获取和释放有一组函数：<code>lock()</code>和<code>unlock()</code>函数。调用<code>lock()</code>函数尝试获取锁，如果没有其他线程持有锁，那么该线程会获得锁，进入临界区。这个线程也被称为锁的持有者。如果另外一个进程对相同的锁变量调用<code>lock()</code>，因为锁被另一个线程持有，这一调用便不会返回。锁的持有者调用<code>unlock()</code>函数之后，便失去对锁的所有权。如果没有其它等待线程，则锁的状态变为可用；如果有等待线程，则其中一个等待线程会收到锁状态的变化，获取锁并进入临界区。</p>
<p>在实际编程中，一般倾向于使用不同的锁来保护不同的数据和结构，从而允许更多的线程进入临界区。这种细粒度的方案可以增加并发。同时也要注意，如果在程序执行的过程中会频繁地获取锁、释放锁，那么高并发就没有什么意义。</p>
<h2 id="api">API</h2>
<p>POSIX线程库提供了一些通过锁来提供互斥进入临界区的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//锁的初始化</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock=PTHREAD_MUTEX_INITIALIZER; <span class="comment">//第一种方法，将锁设置为默认值</span></span><br><span class="line"><span class="type">int</span> rc=<span class="built_in">pthread_mutex_init</span>(&amp;lock,<span class="literal">NULL</span>); <span class="comment">//第二种方法，调用函数，第一个参数是锁本身的地址，它是一个指向pthread_mutex_t类型的指针；第二个参数是一组可选属性，NULL表示使用默认值。函数执行成功则返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加锁解锁函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取锁，通常应该避免使用，但是对于避免死锁来说会很有用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span></span>; <span class="comment">//尝试获取锁，如果锁已被占用则会失败</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_timedlock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex, <span class="keyword">struct</span> timespec* abs_timeout)</span></span>; <span class="comment">//在超时或者获取锁之后返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁锁</span></span><br><span class="line"><span class="built_in">pthread_mutex_destroy</span>()</span><br></pre></td></tr></table></figure>
<h2 id="锁的实现">锁的实现</h2>
<h3 id="评价标准">评价标准</h3>
<ul>
<li>提供互斥：最基本的评价标准，判断锁是否有效，以及能否阻止多个线程同时进入临界区；</li>
<li>公平性：是否能保证每一个竞争线程有公平的机会抢到锁，不会有竞争锁的线程会饿死，一直无法获得锁的情况；</li>
<li>性能：使用锁之后的额外时间开销，需要考虑没有竞争、一个CPU上多个线程竞争、以及多个CPU多个线程竞争等不同使用场景。</li>
</ul>
<h3 id="控制中断">控制中断</h3>
<p>最早提供的互斥解决方案之一是在临界区关闭中断，这种方案是为单处理器开发的，伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">DisableInterrupts</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">EnableInterrupts</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法虽然简单，但是却有很多缺点。首先是这种方法要求我们允许调用线程执行特权操作，也就是说信任这种机制不会被滥用，但是这样常常会有麻烦；第二是这种方法不支持多处理器；而且关闭中断可能也会导致严重的系统问题；最后还有效率低的问题，因为打开与关闭中断的代码执行地很慢。</p>
<p>因此，只有在很有限的情况之下才能用关闭中断来实现互斥原语。例如某些情况下操作系统本身会采用屏蔽中断的方式，保证访问自己数据结构的原子性，或是避免某些复杂的中断处理情况。</p>
<h3 id="自旋锁">自旋锁</h3>
<p>自旋锁是最简单的一种锁，它一直自旋直到锁可用。在单处理器上，需要抢占式的调度器才能使用自旋锁，否则会因为自旋线程永远不会放弃CPU而导致无法使用。</p>
<p>自旋锁只允许一个线程进入临界区，因此它的正确性可以保证。但是自旋锁不提供任何公平性的保证，可能会导致饿死的情况出现；同时在单CPU上性能开销很大，因为处于自旋等待状态的线程会浪费掉它使用的CPU周期（但是多CPU上的性能不错）。</p>
<p>在不同的操作系统中，自旋锁的实现方式也各有不同。</p>
<h4 id="不同硬件原语下的实现">不同硬件原语下的实现</h4>
<p>为了实现自旋锁，需要硬件提供一些硬件原语的支持，这些硬件原语为一系列的原子指令。在不同的硬件原语下，自旋锁也有着不同的实现方式。</p>
<blockquote>
<p>备注—原子指令：指令执行时会像期望那样全部执行完，不能在指令中间中断。当发生中断时，原子指令要么根本没有运行，要么运行完成，没有中间状态。</p>
</blockquote>
<h5 id="测试并设置">测试并设置</h5>
<p>一些硬件提供了测试并设置指令，它返回<code>old_ptr</code>指向的旧值，同时将指针指向的值更新为<code>new</code>的新值。而且这一过程被原子地（Atomically）执行。它的伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="type">int</span>* old_ptr, <span class="type">int</span> <span class="keyword">new</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> old=*old_ptr;</span><br><span class="line">	*old_ptr=<span class="keyword">new</span>;</span><br><span class="line">	<span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这一指令，自旋锁便可以用如下的伪代码来实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">lock_t</span>&#123;</span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">&#125; <span class="type">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">lock_t</span>* lock)</span></span>&#123;</span><br><span class="line">    lock-&gt;flag=<span class="number">0</span>; <span class="comment">//0代表没有线程持有锁，1代表锁已被持有</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(<span class="type">lock_t</span>* lock)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">TestAndSet</span>(&amp;lock-&gt;flag,<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">        ; <span class="comment">//自旋并等待，在这期间什么也不做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">(<span class="type">lock_t</span>* lock)</span></span>&#123;</span><br><span class="line">    lock-&gt;flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="比较并交换">比较并交换</h5>
<p>一些系统提供了比较并交换的硬件原语，它的基本思想是检测<code>ptr</code>指向的值是否与<code>expected</code>相等，如果是则更新<code>ptr</code>所指的值为新值，否则什么也不做，并且无论哪种情况都返回程序结束时<code>ptr</code>指向的那个值。它的伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CompareAndSwap</span><span class="params">(<span class="type">int</span>* ptr, <span class="type">int</span> expected, <span class="type">int</span> <span class="keyword">new</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> actual=*ptr;</span><br><span class="line">	<span class="keyword">if</span>(actual==expected)</span><br><span class="line">		*ptr=<span class="keyword">new</span>;</span><br><span class="line">	<span class="keyword">return</span> actual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要将测试并设置中的加锁函数稍作修改，便可以用比较并交换指令实现一个自旋锁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(<span class="type">lock_t</span>* lock)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">CompareAndSwap</span>(&amp;lock-&gt;flag,<span class="number">0</span>,<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">        ; <span class="comment">//自旋并等待，在这期间什么也不做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="链接的加载与条件式存储">链接的加载与条件式存储</h5>
<p>一些平台提供了链接的加载和条件式存储这一对指令，可以配合使用来实现自旋锁。链接的加载指令从内存中取出一个值存入一个寄存器，而条件式存储指令是当上一次加载的地址在期间都没有更新时才会成功。这一对指令的伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LoadLinked</span><span class="params">(<span class="type">int</span>* ptr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StoreConditional</span><span class="params">(<span class="type">int</span>* ptr, <span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="comment">/*no one has updated *ptr since the LoadLinked to this address*/</span>)&#123;</span><br><span class="line">		*ptr=value;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//success</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//failed to update;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这一对指令，自旋锁的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(<span class="type">lock_t</span>* lock)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">LoadLinked</span>(&amp;lock-&gt;flag)==<span class="number">1</span>)&#123;</span><br><span class="line">			; <span class="comment">//spin until it&#x27;s zero</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">StoreConditional</span>(&amp;lock-&gt;flag,<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">(<span class="type">lock_t</span>* lock)</span></span>&#123;</span><br><span class="line">	lock-&gt;flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##### 获取并增加</p>
<p>这一指令可以原子地返回特定地址的旧值，并且让该值自增1。这一指令的伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FetchAndAdd</span><span class="params">(<span class="type">int</span>* ptr)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> old=*ptr;</span><br><span class="line">	*ptr=old+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这一指令所实现的自旋锁如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">lock_t</span>&#123;</span><br><span class="line">	<span class="type">int</span> ticket;</span><br><span class="line">	<span class="type">int</span> turn;</span><br><span class="line">&#125; <span class="type">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock_init</span><span class="params">(<span class="type">lock_t</span>* lock)</span></span>&#123;</span><br><span class="line">	lock-&gt;ticket=<span class="number">0</span>;</span><br><span class="line">	lock-&gt;turn=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(<span class="type">lock_t</span>* lock)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> myturn=<span class="built_in">FetchAndAdd</span>(&amp;lock-&gt;ticket);</span><br><span class="line">	<span class="keyword">while</span>(lock-&gt;turn!=myturn)</span><br><span class="line">		; <span class="comment">//spin</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">(<span class="type">lock_t</span>* lock)</span></span>&#123;</span><br><span class="line">	<span class="built_in">FetchAndAdd</span>(&amp;lock-&gt;turn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一方法可以保证所有线程都能抢到锁，因为一个线程执行时一定会修改并获得一个<code>ticket</code>值，因此它最终一定会被调度。</p>
<h4 id="解决自旋过多">解决自旋过多</h4>
<p>基于硬件的锁简单且有效，但是自旋会浪费CPU的时间片。比如有N个线程去竞争一个锁，那么就会浪费掉N-1个时间片用于自旋并等待一个线程释放掉锁。如果要让锁不会不必要地自旋，需要操作系统的支持。</p>
<h5 id="放弃cpu">放弃CPU</h5>
<p>一个简单的办法是在要自旋的时候放弃CPU的使用权，从而允许其他线程的执行。下面的伪代码以硬件原语测试并设置为例，其它的硬件原语实现使用类似的办法进行修改：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">TestAndSet</span>(&amp;flag,<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">		<span class="built_in">yield</span>(); <span class="comment">//放弃CPU</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在单CPU上，如果运行的线程数比较少，这种方法十分有效。但是在多个线程反复竞争一把锁的条件下，这一办法仍然成本很高，因为上下文切换的成本仍然存在。而且这种办法也没有考虑到饿死的问题，可能一个线程会一直处于让出的循环。</p>
<h5 id="使用队列">使用队列</h5>
<p>在前面讨论的办法中，存在的真正问题是存在太多的偶然性。因此，我们需要显式地施加某种控制，决定锁释放时谁可以抢到。这需要操作系统的更多支持，并需要一个队列来保存等待锁的线程。使用这种方法的伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">lock_t</span>&#123;</span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> guard;</span><br><span class="line">	<span class="type">queue_t</span>* q;</span><br><span class="line">&#125; <span class="type">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock_init</span><span class="params">(<span class="type">lock_t</span>* m)</span></span>&#123;</span><br><span class="line">	m-&gt;flag=<span class="number">0</span>;</span><br><span class="line">	m-&gt;guard=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue_init</span>(m-&gt;q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(<span class="type">lock_t</span>* m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">TestAndSet</span>(&amp;m-&gt;guard,<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">		;</span><br><span class="line">	<span class="keyword">if</span>(m-&gt;flag==<span class="number">0</span>)&#123;</span><br><span class="line">		m-&gt;flag=<span class="number">1</span>; <span class="comment">//获得锁</span></span><br><span class="line">		m-&gt;guard=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">queue_add</span>(m-&gt;q,<span class="built_in">gettid</span>());</span><br><span class="line">		<span class="built_in">setpark</span>(); <span class="comment">//让调用线程休眠，同时避免唤醒/等待竞争的出现</span></span><br><span class="line">        m-&gt;guard=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">(<span class="type">lock_t</span>* m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">TestAndSet</span>(&amp;m-&gt;guard,<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">		; <span class="comment">//</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">queue_empty</span>(m-&gt;q))</span><br><span class="line">		m-&gt;flag=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">unpark</span>(<span class="built_in">queue_remove</span>(m-&gt;q)); <span class="comment">//唤醒threadID标识的线程</span></span><br><span class="line">	m-&gt;guard=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="两阶段锁">两阶段锁</h5>
<p>两阶段锁的程序执行也如字面一样分为两个阶段：在第一阶段，会先自旋一段时间，程序希望可以获取锁；如果第一阶段没有获得锁，那么便会执行第二阶段，调用者进入睡眠状态直到锁可用。</p>
<h1 id="条件变量">条件变量</h1>
<h2 id="定义-1">定义</h2>
<p>在很多情况下，线程需要检查某一条件满足之后，才会继续运行。这可以通过使用一个共享变量，然后让该线程去不断重复检查来实现。但是这种方法效率低下，浪费CPU的时间。一个更好的办法是让这一线程处于休眠状态，直到等待的条件满足，这可以通过条件变量来实现。</p>
<p><strong>条件变量</strong>是一个显式队列，当某些执行状态（即条件）不满足时，线程可以把自己加入队列，等待该条件。当另外某个线程改变了这些状态时，就可以唤醒一个或者多个等待进程（通过在该条件上发信号），让它们继续执行。要使用条件变量，需要额外有一个相关的锁。</p>
<h2 id="api-1">API</h2>
<p>条件变量的相关API如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="type">pthread_cond_t</span> c=PTHREAD_COND_INITIALIZER; </span><br><span class="line"><span class="comment">//操作</span></span><br><span class="line"><span class="built_in">pthread_cond_wait</span>(<span class="type">pthread_cond_t</span>* c,<span class="type">pthread_mutex_t</span>* m); <span class="comment">//线程休眠，当调用wait时，需要保证互斥量m处于上锁状态。函数会释放锁，并让调用线程休眠。而在线程被唤醒之后，仍需要重新获取锁。</span></span><br><span class="line"><span class="built_in">pthread_cond_signal</span>(<span class="type">pthread_cond_t</span>* c); <span class="comment">//唤醒等待在某个条件变量上的睡眠线程。虽然API没有要求，但是在调用这一函数时最好持有锁，以保证程序正确</span></span><br></pre></td></tr></table></figure>
<h2 id="生产者消费者有界缓冲区问题">生产者/消费者（有界缓冲区）问题</h2>
<h3 id="问题描述">问题描述</h3>
<p>假设有一个或者多个生产者线程，以及一个或者多个消费者线程。生产者将生成的数据项放入到缓冲区，消费者从缓冲区取走数据项，以某种方式消费。因为有界缓冲区是共享资源，因此必须通过同步机制来访问它，以免产生竞争条件。</p>
<p>很多实际的系统都有这种场景：例如多线程的网络服务器中，一个生产者将HTTP请求放入到工作队列中，消费线程从队列中取走请求并处理；在使用Linux的管道连接操作时，也使用到了有界缓冲区。</p>
<h3 id="实现">实现</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> buffer[MAX];</span><br><span class="line"><span class="type">int</span> fill_ptr=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> use_ptr=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">    buffer[fill_ptr]=value;</span><br><span class="line">    fill_ptr=(fill_ptr+<span class="number">1</span>)%MAX;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp=buffer[use_ptr];</span><br><span class="line">    use_ptr=(use_ptr+<span class="number">1</span>)%MAX;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">cond_t</span> empty,fill; <span class="comment">//使用两个信号的目的是使得信号更具有指向性，消费者只唤醒生产者，生产者只唤醒消费者。否则可能会出现生产者唤醒生产者，或是消费者唤醒消费者的情况</span></span><br><span class="line"><span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;loops;i++)&#123;</span><br><span class="line">        <span class="built_in">Pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(count==MAX) <span class="comment">//使用while而不是if，是为了保证线程再被唤醒之后，再一次检查条件是否仍旧满足。因为信号使用的是Mesa语义，也就是发信号给线程的时候只是唤醒它们，暗示状态发生了变化，但是并不会保证在它运行之前状态一直是期望的情况。（与之相反的叫做Hoare语义，保证被唤醒线程立刻执行）</span></span><br><span class="line">            <span class="built_in">Pthread_cond_wait</span>(&amp;empty,&amp;mutex);</span><br><span class="line">        <span class="built_in">put</span>(i);</span><br><span class="line">        <span class="built_in">Pthread_cond_signal</span>(&amp;fill);</span><br><span class="line">        <span class="built_in">Pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;loops;i++)&#123;</span><br><span class="line">        <span class="built_in">Pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(count==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">Pthread_cond_wait</span>(&amp;fill,&amp;mutex);</span><br><span class="line">        <span class="type">int</span> tmp=<span class="built_in">get</span>();</span><br><span class="line">        <span class="built_in">Pthread_cond_signal</span>(&amp;empty);</span><br><span class="line">        <span class="built_in">Pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="覆盖条件">覆盖条件</h2>
<p>下面是一个多线程分配库的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> bytesLeft=MAX_HEAP_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="type">cond_t</span> c;</span><br><span class="line"><span class="type">mutex_t</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">	<span class="built_in">Pthread_mutex_lock</span>(&amp;m);</span><br><span class="line">	<span class="keyword">while</span>(bytesLeft&lt;size)</span><br><span class="line">		<span class="built_in">Pthread_cont_wait</span>(&amp;c,&amp;m);</span><br><span class="line">	<span class="type">void</span>* ptr=... <span class="comment">//从堆中获取内存</span></span><br><span class="line">    bytesLeft-=size;</span><br><span class="line">    <span class="built_in">Pthread_mutex_unlock</span>(&amp;m);</span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span>* ptr,<span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Pthread_mutex_lock</span>(&amp;m);</span><br><span class="line">    bytesLeft+=size;</span><br><span class="line">    <span class="built_in">Pthread_cond_broadcast</span>(&amp;c); <span class="comment">//注意此处用的不是Pthread_cond_signal函数</span></span><br><span class="line">    <span class="built_in">Pthread_mutex_unlock</span>(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，使用<code>Pthread_cond_broadcast()</code>函数来唤醒所有的等待线程，因为此时无法确定哪一个内存申请程序所请求的空间可以被分配。这种条件变量被叫做覆盖条件，因为它可以覆盖所有需要唤醒线程的场景，但是这样会导致太多线程被唤醒，从而影响性能。</p>
<h1 id="信号量">信号量</h1>
<h2 id="定义-2">定义</h2>
<p>信号量是有一个整数值的对象，可以用两个函数来操作它，在POSIX标准中为<code>sem_wait()</code>和<code>sem_post()</code>。信号量可以被用作锁或者条件变量，它的初始值能够决定其行为。所以首先要初始化信号量，才能调用其它函数与之交互。初始化过程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">sem_t</span> s;</span><br><span class="line"><span class="built_in">sem_init</span>(&amp;s,<span class="number">0</span>,<span class="number">1</span>); <span class="comment">//第二个参数为0代表信号量在同一个进程的多个线程间共享，如果使用其他值可以用于跨不同进程的同步访问；第三个参数用于初始化信号量的值</span></span><br></pre></td></tr></table></figure>
<p>在初始化之后，可以调用<code>sem_wait()</code>和<code>sem_post()</code>进行交互。<code>sem_wait()</code>会将信号量减1，如果这一步操作之后信号量变为负值，则让调用线程挂起，直到之后的一个post操作。而<code>sem_post()</code>会直接增加信号量的值，如果有等待线程则唤醒其中的一个。当信号量的值为负数时，这个值的绝对值就是等待线程的个数。</p>
<h2 id="信号量的实现">信号量的实现</h2>
<p>下面的代码是信号量的一个简单实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_My_sem_t</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">pthread_cond_t</span> cond;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> lock;</span><br><span class="line">&#125; My_sem_t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">My_sem_t_init</span><span class="params">(My_sem_t* s,<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">    s-&gt;value=value;</span><br><span class="line">    <span class="built_in">Cond_init</span>(&amp;s-&gt;cond);</span><br><span class="line">    <span class="built_in">Mutex_init</span>(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">My_sem_wait</span><span class="params">(My_sem_t* s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Mutex_lock</span>(&amp;s-&gt;lock);</span><br><span class="line">    <span class="keyword">while</span>(s-&gt;value&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">Cond_wait</span>(&amp;s-&gt;cond,&amp;s-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;value--;</span><br><span class="line">    <span class="built_in">Mutex_unlock</span>(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">My_sem_post</span><span class="params">(My_sem_t* s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Mutex_lock</span>(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;value++;</span><br><span class="line">    <span class="built_in">Cond_signal</span>(&amp;s-&gt;cond);</span><br><span class="line">    <span class="built_in">Mutex_unlock</span>(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="信号量的使用">信号量的使用</h2>
<h3 id="二值信号量作为锁">二值信号量作为锁</h3>
<p>将信号量的初值设置为1，便可以将信号量用作锁来使用。此时，便可以用<code>sem_wait()</code>和<code>sem_post()</code>将临界区包裹起来，伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> m;</span><br><span class="line"><span class="built_in">sem_init</span>(&amp;m,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sem_wait</span>(&amp;m);</span><br><span class="line"><span class="comment">//临界区代码</span></span><br><span class="line"><span class="built_in">sem_post</span>(&amp;m);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例：</p>
<p>假设有两个线程的场景。一开始线程0调用了<code>sem_wait()</code>，它把信号量的值减为0。由于信号量小于0时才会等待，故线程0从函数返回之后便进入临界区。如果没有其它线程尝试获取锁，线程0在执行完临界区的代码并调用<code>sem_post()</code>时，信号量会被重置为1。</p>
<p>如果在线程0调用<code>sem_post()</code>之前，线程1调用<code>sem_wait()</code>尝试进入临界区，此时线程1会把信号量减为-1，然后等待。线程0继续运行，最后调用<code>sem_post()</code>将信号量增加到0。此时线程1便可以获取锁，并且当它执行结束的时候再次增加信号量的值，将其恢复为1。</p>
</blockquote>
<h3 id="信号量用作条件变量">信号量用作条件变量</h3>
<p>信号量也可以用在一个线程暂停执行，等待某一条件成立的场景。在这种场景下，通常一个线程等待条件成立，另一个线程修改条件并发送信号给等待线程，从而唤醒等待线程。因为等待线程在等待某些条件发生变化，因此此时的信号量作为条件变量。在这种情况下，信号量的初始值应该设置为0。</p>
<blockquote>
<p>例：</p>
<p>假设一个父线程创建一个子线程，并等待它结束再继续执行。此时有两种情况：</p>
<p>第一种是父线程创建了子线程，但是子线程并没有运行。这种情况下，父进程调用<code>sem_wait()</code>会先于子进程调用<code>sem_post()</code>。此时，父线程会首先把信号量减为-1，然后睡眠等待。子线程运行结束的时候调用<code>sem_post()</code>，信号量增加为0。此时，父线程被唤醒，从<code>sem_wait()</code>中返回，执行剩下的程序。</p>
<p>第二种是子线程在父线程调用<code>sem_wait()</code>之前就已经执行结束。在这种情况下，子线程首先调用<code>sem_post()</code>将信号量从0变为1。当父线程执行到<code>sem_wait()</code>时，信号量的值为1，父线程将信号量减为0，然后从函数中返回继续执行剩下的程序，无需等待。</p>
</blockquote>
<h3 id="生产者消费者问题">生产者/消费者问题</h3>
<p>使用信号量来解决生产者/消费者问题的伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> empty;</span><br><span class="line"><span class="type">sem_t</span> full;</span><br><span class="line"><span class="type">sem_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;loops;i++)&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;empty); <span class="comment">//这一操作需要放在锁之前，否则会出现死锁的情况</span></span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;mutex); <span class="comment">//放入队列或是从队列取出的操作必须是互斥的，否则可能会造成数据丢失</span></span><br><span class="line">        <span class="built_in">put</span>(i);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;full);<span class="comment">//这一操作需要放在锁之后，否则会出现死锁的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;loops;i++)&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;full);</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> tmp=<span class="built_in">get</span>();</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;empty);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;empty,<span class="number">0</span>,MAX); <span class="comment">//MAX表示队列的上限</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;full,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">//信号量full为0的时候表示队列满</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;mutex,<span class="number">0</span>,<span class="number">1</span>); <span class="comment">//互斥锁</span></span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读者写者锁">读者—写者锁</h3>
<p>考虑到不同的数据结构访问可能需要不同类型的锁，人们发明了读者—写者锁。</p>
<p>如果某个线程要更新数据结构，需要调用<code>rwlock_acquire_writelock()</code>获得写锁，调用<code>rwlock_release_writelock()</code>来释放锁。内部通过一个<code>writelock</code>的信号量保证只有一个写者可以获得锁进入临界区，从而更新数据结构。</p>
<p>而在获取读锁时，读者首先要获取lock，然后增加reader变量，追踪目前有多少个读者在访问该数据结构。在函数<code>rwlock_acquire_readlock()</code>中，当第一个读者获取读锁的时候，也会同时获得写锁。一旦一个读者获取了读锁之后，其他的读者也可以获取读锁，但是想要获取写锁的线程就必须要等到所有的读者都结束。最后一个退出的读者会放弃写锁，从而让等待的写者可以获取写锁。</p>
<p>一个简单的读者—写者锁的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_rwlock_t</span>&#123;</span><br><span class="line">    <span class="type">sem_t</span> lock;</span><br><span class="line">    <span class="type">sem_t</span> writelock;</span><br><span class="line">    <span class="type">int</span> readers;</span><br><span class="line">&#125; <span class="type">rwlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rwlock_init</span><span class="params">(<span class="type">rwlock_t</span>* rw)</span></span>&#123;</span><br><span class="line">    rw-&gt;readers=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;rw-&gt;lock,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;rw-&gt;writelock,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rwlock_acquire_readlock</span><span class="params">(<span class="type">rwlock_t</span>* rw)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;rw-&gt;lock);</span><br><span class="line">    rw-&gt;readers++;</span><br><span class="line">    <span class="keyword">if</span>(rw-&gt;readers==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;rw-&gt;writelock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;rw-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rwlock_release_readlock</span><span class="params">(<span class="type">rwlock_t</span>* rw)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;rw-&gt;lock);</span><br><span class="line">    rw-&gt;readers--;</span><br><span class="line">    <span class="keyword">if</span>(rw-&gt;readers==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;rw-&gt;writelock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;rw-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rwlock_acquire_writelock</span><span class="params">(<span class="type">rwlock_t</span>* rw)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;rw-&gt;writelock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rwlock_release_writelock</span><span class="params">(<span class="type">rwlock_t</span>* rw)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;rw-&gt;writelock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="哲学家就餐问题">哲学家就餐问题</h3>
<p>这一问题的基本情况是：假定有N位哲学家围着一个圆桌，每两位哲学家中间有一把餐叉（共N把）。哲学家有时候需要思考，此时不需要餐叉；有时又需要就餐，而只有同时拿到左手和右手边的餐叉才能吃到东西。</p>
<p>每个哲学家的基本循环可以用如下的伪代码描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">think</span>();</span><br><span class="line">    <span class="built_in">getforks</span>();</span><br><span class="line">	<span class="built_in">eat</span>();</span><br><span class="line">    <span class="built_in">putforks</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一问题的关键是如何实现<code>getforks()</code>和<code>putforks()</code>函数，保证没有死锁，没有哲学家饿死，并且尽可能有高的并发度。因此，每个餐叉需要用一个信号量来表示其是否被使用：<code>sem_t forks[N]</code>，每个信号量都被初始化为1。</p>
<p>下面是一个有问题的解决方案：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getforks</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">sem_wait</span>(forks[p]);</span><br><span class="line">    <span class="built_in">sem_wait</span>(forks[(p+<span class="number">1</span>)%N]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">putforks</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sem_post</span>(forks[p]);</span><br><span class="line">    <span class="built_in">sem_post</span>(forks[(p+<span class="number">1</span>)%N]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的方案中，每个哲学家都首先获取左边的餐叉，然后获取右边的，在释放时也按照同样的顺序。但是这种方式会造成死锁，假设每个哲学家都拿取了左边的餐叉，此时所有的餐叉都被占有，所有的哲学家都被阻塞着，都在等待另一个哲学家占有的餐叉。解决这一问题最简单的办法，是修改某个或者某些（但一定不是全部）哲学家取餐叉的顺序，即改为先右后左，这样便会打破等待循环。</p>
<h1 id="常见问题">常见问题</h1>
<h2 id="非死锁缺陷">非死锁缺陷</h2>
<h3 id="违反原子性缺陷">违反原子性缺陷</h3>
<p>这种缺陷的定义是：违反了多次内存访问中预期的可串行性。也就是说，代码段本意是原子性的，但是在执行中却没有强制地实现原子性。通过给共享变量的访问加锁，便可以修复这一问题。</p>
<h3 id="违反顺序缺陷">违反顺序缺陷</h3>
<p>违反顺序缺陷的定义是：两个内存访问的预期顺序被打破。即A本来应该在B之前执行，但是实际运行中却不是这个顺序。使用条件变量来强制执行顺序即可修复这一缺陷。</p>
<h2 id="死锁缺陷">死锁缺陷</h2>
<h3 id="发生原因">发生原因</h3>
<p>当线程1持有锁L1，正在等待另外一个锁L2；而线程2持有锁L2，正在等待锁L1释放时，便会因为两个线程互相等待而产生死锁，导致程序无法执行下去。在实际编程中，一个大型代码库里的组件之间通常会有复杂的依赖，这便会容易因循环依赖导致死锁；同时，软件开发中的封装思想与锁也不是很契合，因此一些看起来没有关系的接口也可能会导致死锁。</p>
<h3 id="产生条件">产生条件</h3>
<ul>
<li>互斥：线程对于所需资源进行互斥地访问；</li>
<li>持有并等待：线程持有资源并且又在等待其他的资源；</li>
<li>非抢占：线程获得的资源不能被抢占；</li>
<li>循环等待：线程之间存在一个环路，环路上每个线程都持有一个资源，而这个资源又是下一个线程需要申请的。</li>
</ul>
<h3 id="死锁的处理">死锁的处理</h3>
<h4 id="预防">预防</h4>
<h5 id="避免循环等待">避免循环等待</h5>
<p>最实用的预防技术是让代码不会产生循环等待。一个直接的办法是获取锁的时候提供一个全序，这也就是说，假如系统有两个锁L1和L2，每次都先申请L1再申请L2，这样便可以避免死锁。但是更复杂的系统中通常有许多锁，因此也常常使用偏序。</p>
<h5 id="避免持有并等待">避免持有并等待</h5>
<p>死锁的这一条件可以通过原子地抢锁来预防。在抢锁的过程中，不会发生不合适的线程切换，从而避免了死锁。但是这种方案不适用于封装，因为这一方案需要准确地知道要抢哪些锁，并且提前抢到这些锁。</p>
<h5 id="抢锁">抢锁</h5>
<p>如果允许线程抢锁，则可以预防死锁的产生。但是这又会造成活锁的问题：两个线程可能一直重复抢锁的动作，又同时抢锁失败。此时，系统一直在运行这段代码，但是却没有进展。</p>
<h5 id="避免互斥">避免互斥</h5>
<p>完全避免互斥也可以预防死锁的形成。一些人设计了无等待的数据结构，这是通过使用硬件指令，从而构造出不需要锁的数据结构。但是这种方式也有可能会产生活锁。</p>
<h4 id="通过调度避免">通过调度避免</h4>
<p>一些场景也更加适合使用死锁避免的方案。通过了解不同线程在运行过程中对锁的需求情况，以此进行调度，可以避免死锁的产生。</p>
<h4 id="检查和恢复">检查和恢复</h4>
<p>有时我们允许死锁偶尔发生，检查到发生死锁之后再采取行动（如果死锁很少发生，并且产生死锁造成的代价很小，就无需花费大量精力避免死锁）。</p>
<h1 id="基于事件的并发">基于事件的并发</h1>
<p>## 概述</p>
<p>基于事件的并发指的是，我们等待事件的发生，当它发生时检查事件类型，然后做相应的工作。处理事件的代码叫做事件处理程序，它运行的时候，是系统中发生的唯一活动。</p>
<p>因此，调度就是决定接下来处理哪个事件。这种对调度的显式控制是基于事件方法的一个重要优点。由于一次只处理一个事件，所以不需要获取或者释放锁，线程化程序中常见的并发性错误也不会出现在基于事件的并发方法中。</p>
<h2 id="存在的问题与解决">存在的问题与解决</h2>
<h3 id="接收事件">接收事件</h3>
<p>基于事件的服务器需要决定哪个事件发生，也就是如何确定是否有它的消息已经到达。大多数系统提供了<code>select()</code>或<code>poll()</code>系统调用，这些接口检查是否有任何应该关注的进入I/O。</p>
<p>例如<code>select()</code>函数在MacOS X上的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds,</span></span></span><br><span class="line"><span class="params"><span class="function">           fd_set* restrict readfds,</span></span></span><br><span class="line"><span class="params"><span class="function">           fd_set* restrict writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">           fd_set* restrict errorfds,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">struct</span> timeval* restrict timeout)</span></span></span><br></pre></td></tr></table></figure>
<p>这一函数检查I/O描述符集合，它们的地址通过<code>readfds</code>、<code>writefds</code>和<code>errorfds</code>传入，分别查看它们中的某些描述符是否已准备好读取、是否准备好写入、或是否有异常情况待处理，在每个集合中检查前<code>nfds</code>个描述符。该函数返回所有集合中就绪描述符的总数。</p>
<blockquote>
<p>补充—阻塞与非阻塞接口：</p>
<p>阻塞（又称同步）接口在返回给调用者之前完成所有的工作，而非阻塞（又称异步）接口开始一些工作，但是立即返回，剩余所有需要完成的工作都在后台完成。</p>
</blockquote>
<h3 id="阻塞系统调用">阻塞系统调用</h3>
<p>在使用基于事件的方法时，只有主事件在执行，此时如果一个事件处理程序发出一个阻塞调用，整个服务器就会阻塞直到调用完成。当事件处于阻塞状态时，系统处于闲置，造成潜在的巨大资源浪费。因此，在基于事件的系统中不允许阻塞调用。</p>
<p>为了克服这一限制，许多现代操作系统引入了异步I/O的接口。这些接口使得应用程序可以发出I/O请求，并在I/O完成之前立即将控制权返回给调用者，另外的接口让应用程序能够确定各种I/O是否已完成。同时，为了能够确定I/O是否完成，一些系统提供了基于中断的方法，使用UNIX的信号在异步I/O完成时通知应用程序，从而避免了轮询系统的需要。</p>
<h3 id="状态管理">状态管理</h3>
<p>基于事件方法的代码通常比传统基于线程的代码更加复杂，因为当事件处理程序发出异步I/O时，它必须打包一些程序状态，以便下一个事件处理程序在I/O最终完成时使用。这个额外的工作被称为手工栈管理。</p>
<h3 id="其他">其他</h3>
<p>基于事件的方法还有一些其他困难，例如：</p>
<ul>
<li>在多核CPU上不可能使用基于事件的方法。因为利用多个CPU时，事件服务器必须并行运行多个事件处理程序，此时便会出现同步问题，并且必须采用通用的解决方案如加锁。</li>
<li>不能很好地与某些类型的系统活动集成，如分页等。</li>
<li>基于事件的代码可能难以管理。</li>
<li>异步网络I/O集成很难实现。</li>
</ul>
<h1 id="参考">参考</h1>
<ol type="1">
<li>Operating Systems: Three Easy Pieces</li>
<li>深入理解计算机系统 第三版</li>
</ol>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Yufei Luo
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://lyf35.github.io/2020/10/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%B9%B6%E5%8F%91/" title="操作系统-并发">http://lyf35.github.io/2020/10/18/操作系统-并发/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> 计算机基础</a>
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="fa fa-tag"></i> 操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/" rel="prev" title="操作系统-内存虚拟化">
      <i class="fa fa-chevron-left"></i> 操作系统-内存虚拟化
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%8C%81%E4%B9%85%E6%80%A7/" rel="next" title="操作系统-持久性">
      操作系统-持久性 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yufei Luo</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">22:56</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动
  </div>

        






<script data-pjax>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"ypNNXSdcGIIoldC5BBmViS2g-gzGzoHsz","app_key":"0TDwohU7eO4yHTn4tley8PtE","server_url":"https://leancloud.cn/dashboard/data.html?appid=ypNNXSdcGIIoldC5BBmViS2g-gzGzoHsz#/","security":false};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="//cdn.jsdelivr.net/npm/ribbon.js@1/dist/ribbon.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/next-theme/pjax@0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  
  <script data-pjax>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>









<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>


    <div class="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      const script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4dcdc02d24075b0e9d3a',
      clientSecret: '53cf2cb8b89b9d4bba922bb19bda1290f0d0bf95',
      repo        : 'lyf35.github.io',
      owner       : 'lyf35',
      admin       : ['lyf35'],
      id          : '1e84809673aaccd04d3cbba064783cd5',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
