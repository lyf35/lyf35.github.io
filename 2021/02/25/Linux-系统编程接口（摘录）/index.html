<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">
  <link rel="manifest" href="/images/site.webmanifest">
  <meta name="msapplication-config" content="/images/browserconfig.xml">
  <meta name="msvalidate.01" content="<meta name="msvalidate.01" content="5D3796A5DDB32CC875380613FB613833" />">
  <meta name="baidu-site-verification" content="<meta name="baidu-site-verification" content="kewHZtFYQk" />">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Helvetica:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-flat-top.min.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lyf35.github.io","root":"/","scheme":"Pisces","version":"8.0.0-rc.5","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="注：本文的内容摘录自《Linux&#x2F;UNIX系统编程手册》（原名The Linux Programming Interface）">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux-系统编程接口（摘录）">
<meta property="og:url" content="http://lyf35.github.io/2021/02/25/Linux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%EF%BC%88%E6%91%98%E5%BD%95%EF%BC%89/index.html">
<meta property="og:site_name" content="Yufei Luo&#39;s Blog">
<meta property="og:description" content="注：本文的内容摘录自《Linux&#x2F;UNIX系统编程手册》（原名The Linux Programming Interface）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151455.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151502.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151521.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151530.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151659.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151827.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151803.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151807.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151724.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151917.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151929.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151932.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151937.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151956.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808152010.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808152058.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808152106.png">
<meta property="article:published_time" content="2021-02-25T04:21:54.000Z">
<meta property="article:modified_time" content="2021-03-14T13:53:34.000Z">
<meta property="article:author" content="Yufei Luo">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151455.png">

<link rel="canonical" href="http://lyf35.github.io/2021/02/25/Linux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%EF%BC%88%E6%91%98%E5%BD%95%EF%BC%89/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux-系统编程接口（摘录） | Yufei Luo's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
 <!--   <div class="headband"></div>-->

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Yufei Luo's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">But I was so much older then, I am younger than that now.</p>
      <img class="custom-logo-image" src="/images/logo.png" alt="Yufei Luo's Blog">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-计算机基础">

    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80" rel="section"><i class="fa fa-tags fa-fw"></i>计算机基础</a>

  </li>
        <li class="menu-item menu-item-机器学习">

    <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0" rel="section"><i class="fa fa-tags fa-fw"></i>机器学习</a>

  </li>
        <li class="menu-item menu-item-深度学习">

    <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0" rel="section"><i class="fa fa-tags fa-fw"></i>深度学习</a>

  </li>
        <li class="menu-item menu-item-工程实践">

    <a href="/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5" rel="section"><i class="fa fa-tags fa-fw"></i>工程实践</a>

  </li>
        <li class="menu-item menu-item-论文笔记">

    <a href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0" rel="section"><i class="fa fa-tags fa-fw"></i>论文笔记</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text"> 系统调用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E9%99%90%E5%88%B6%E5%92%8C%E9%80%89%E9%A1%B9"><span class="nav-number">2.</span> <span class="nav-text"> 系统限制和选项</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E9%99%90%E5%88%B6"><span class="nav-number">2.2.</span> <span class="nav-text"> 系统限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E9%80%89%E9%A1%B9"><span class="nav-number">2.3.</span> <span class="nav-text"> 系统选项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">3.</span> <span class="nav-text"> 文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.1.</span> <span class="nav-text"> 文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6"><span class="nav-number">3.1.1.</span> <span class="nav-text"> 设备文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E5%92%8C%E5%88%86%E5%8C%BA"><span class="nav-number">3.1.2.</span> <span class="nav-text"> 磁盘和分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.3.</span> <span class="nav-text"> 文件系统结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.1.4.</span> <span class="nav-text"> 虚拟文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E5%B1%82%E7%BA%A7%E4%B8%8E%E6%96%87%E4%BB%B6%E6%8C%82%E8%BD%BD"><span class="nav-number">3.1.5.</span> <span class="nav-text"> 目录层级与文件挂载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.1.6.</span> <span class="nav-text"> 虚拟内存文件系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E4%B8%8E%E9%93%BE%E6%8E%A5"><span class="nav-number">3.2.</span> <span class="nav-text"> 目录与链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="nav-number">3.2.1.</span> <span class="nav-text"> 硬链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E9%93%BE%E6%8E%A5"><span class="nav-number">3.2.2.</span> <span class="nav-text"> 软链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">3.2.3.</span> <span class="nav-text"> 链接的系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E7%A7%BB%E9%99%A4%E9%93%BE%E6%8E%A5"><span class="nav-number">3.2.3.1.</span> <span class="nav-text"> 创建和移除链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8D"><span class="nav-number">3.2.3.2.</span> <span class="nav-text"> 更改文件名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5"><span class="nav-number">3.2.3.3.</span> <span class="nav-text"> 使用符号链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%A7%BB%E9%99%A4"><span class="nav-number">3.2.3.4.</span> <span class="nav-text"> 文件&#x2F;目录的创建和移除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E7%9B%AE%E5%BD%95"><span class="nav-number">3.2.3.5.</span> <span class="nav-text"> 读目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="nav-number">3.2.3.6.</span> <span class="nav-text"> 进程当前工作目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A0%B9%E7%9B%AE%E5%BD%95"><span class="nav-number">3.2.3.7.</span> <span class="nav-text"> 改变进程的根目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90"><span class="nav-number">3.2.3.8.</span> <span class="nav-text"> 路径解析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%91%E6%8E%A7%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6"><span class="nav-number">3.3.</span> <span class="nav-text"> 监控文件事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="nav-number">3.3.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#api"><span class="nav-number">3.3.2.</span> <span class="nav-text"> API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%8A%A0%E9%94%81"><span class="nav-number">3.4.</span> <span class="nav-text"> 文件加锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#flock%E5%87%BD%E6%95%B0"><span class="nav-number">3.4.1.</span> <span class="nav-text"> flock函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fcntl%E5%87%BD%E6%95%B0"><span class="nav-number">3.4.2.</span> <span class="nav-text"> fcntl函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6io"><span class="nav-number">3.5.</span> <span class="nav-text"> 文件I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="nav-number">3.5.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8io"><span class="nav-number">3.5.2.</span> <span class="nav-text"> 通用I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#open"><span class="nav-number">3.5.2.1.</span> <span class="nav-text"> open()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#read"><span class="nav-number">3.5.2.2.</span> <span class="nav-text"> read()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#write"><span class="nav-number">3.5.2.3.</span> <span class="nav-text"> write()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#close"><span class="nav-number">3.5.2.4.</span> <span class="nav-text"> close()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lseek"><span class="nav-number">3.5.2.5.</span> <span class="nav-text"> lseek()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95"><span class="nav-number">3.5.3.</span> <span class="nav-text"> 特殊用法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fcntl"><span class="nav-number">3.5.3.1.</span> <span class="nav-text"> fcntl()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E5%AE%9A%E5%81%8F%E7%A7%BB%E9%87%8F%E7%9A%84io"><span class="nav-number">3.5.3.2.</span> <span class="nav-text"> 特定偏移量的I&#x2F;O</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%95%A3%E8%BE%93%E5%85%A5%E5%92%8C%E9%9B%86%E4%B8%AD%E8%BE%93%E5%87%BA"><span class="nav-number">3.5.3.3.</span> <span class="nav-text"> 分散输入和集中输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%88%AA%E6%96%AD"><span class="nav-number">3.5.3.4.</span> <span class="nav-text"> 文件截断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#devfd%E7%9B%AE%E5%BD%95"><span class="nav-number">3.5.3.5.</span> <span class="nav-text"> &#x2F;dev&#x2F;fd目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6"><span class="nav-number">3.5.3.6.</span> <span class="nav-text"> 创建临时文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6io%E7%BC%93%E5%86%B2"><span class="nav-number">3.5.4.</span> <span class="nav-text"> 文件I&#x2F;O缓冲</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%BC%93%E5%86%B2"><span class="nav-number">3.5.4.1.</span> <span class="nav-text"> 内核缓冲</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stdio%E5%BA%93%E7%9A%84%E7%BC%93%E5%86%B2"><span class="nav-number">3.5.4.2.</span> <span class="nav-text"> stdio库的缓冲</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%BC%93%E5%86%B2%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.5.4.2.1.</span> <span class="nav-text"> 设置缓冲模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%B7%E6%96%B0stdio%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">3.5.4.2.2.</span> <span class="nav-text"> 刷新stdio缓冲区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#stdio%E5%BA%93%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B7%E5%90%88"><span class="nav-number">3.5.4.2.3.</span> <span class="nav-text"> stdio库与系统调用混合</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.5.4.3.</span> <span class="nav-text"> 总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="nav-number">3.6.</span> <span class="nav-text"> 文件属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="nav-number">3.6.1.</span> <span class="nav-text"> 获取文件信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%97%B6%E9%97%B4%E6%88%B3"><span class="nav-number">3.6.2.</span> <span class="nav-text"> 文件时间戳</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-number">3.6.3.</span> <span class="nav-text"> 文件所有权</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="nav-number">3.6.4.</span> <span class="nav-text"> 文件权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7"><span class="nav-number">3.6.5.</span> <span class="nav-text"> 扩展属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">4.</span> <span class="nav-text"> 虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-number">4.1.</span> <span class="nav-text"> 内存映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="nav-number">4.1.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%98%A0%E5%B0%84"><span class="nav-number">4.1.2.</span> <span class="nav-text"> 创建映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%99%A4%E6%98%A0%E5%B0%84"><span class="nav-number">4.1.3.</span> <span class="nav-text"> 解除映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84"><span class="nav-number">4.1.4.</span> <span class="nav-text"> 文件映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E6%98%A0%E5%B0%84"><span class="nav-number">4.1.5.</span> <span class="nav-text"> 匿名映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%98%A0%E5%B0%84%E5%8C%BA%E5%9F%9F"><span class="nav-number">4.1.6.</span> <span class="nav-text"> 同步映射区域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E6%98%A0%E5%B0%84"><span class="nav-number">4.1.7.</span> <span class="nav-text"> 重新映射</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C"><span class="nav-number">4.2.</span> <span class="nav-text"> 虚拟内存操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="nav-number">4.2.1.</span> <span class="nav-text"> 改变内存保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%94%81"><span class="nav-number">4.2.2.</span> <span class="nav-text"> 内存锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A%E5%86%85%E5%AD%98%E9%A9%BB%E7%95%99%E6%80%A7"><span class="nav-number">4.2.3.</span> <span class="nav-text"> 确定内存驻留性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E8%AE%AE%E5%90%8E%E7%BB%AD%E7%9A%84%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.2.4.</span> <span class="nav-text"> 建议后续的内存使用模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text"> 定时器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%B4%E9%9A%94%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">5.1.</span> <span class="nav-text"> 间隔定时器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%91%E7%9C%A0"><span class="nav-number">5.2.</span> <span class="nav-text"> 休眠</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#posix%E6%97%B6%E9%92%9F"><span class="nav-number">5.3.</span> <span class="nav-text"> POSIX时钟</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#posix%E9%97%B4%E9%9A%94%E5%BC%8F%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">5.4.</span> <span class="nav-text"> POSIX间隔式定时器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">5.5.</span> <span class="nav-text"> 文件描述符定时器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text"> 进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9"><span class="nav-number">6.1.</span> <span class="nav-text"> 基础内容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%8F%B7"><span class="nav-number">6.1.1.</span> <span class="nav-text"> 进程号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">6.1.2.</span> <span class="nav-text"> 进程的内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E6%A0%88%E5%B8%A7"><span class="nav-number">6.1.3.</span> <span class="nav-text"> 栈和栈帧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-number">6.1.4.</span> <span class="nav-text"> 命令行参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%88%97%E8%A1%A8"><span class="nav-number">6.1.5.</span> <span class="nav-text"> 环境列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%B1%80%E9%83%A8%E8%B7%B3%E8%BD%AC"><span class="nav-number">6.1.6.</span> <span class="nav-text"> 非局部跳转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">6.1.7.</span> <span class="nav-text"> 内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-number">6.1.7.1.</span> <span class="nav-text"> 在堆上分配内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-number">6.1.7.2.</span> <span class="nav-text"> 在栈上分配内存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF"><span class="nav-number">6.2.</span> <span class="nav-text"> 系统和进程信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#proc%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">6.2.1.</span> <span class="nav-text"> &#x2F;proc文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-5"><span class="nav-number">6.2.1.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%85%B3%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="nav-number">6.2.1.2.</span> <span class="nav-text"> 获取进程有关的信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF"><span class="nav-number">6.2.1.3.</span> <span class="nav-text"> 系统信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%A0%87%E8%AF%86"><span class="nav-number">6.2.2.</span> <span class="nav-text"> 系统标识</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">6.3.</span> <span class="nav-text"> 进程的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="nav-number">6.4.</span> <span class="nav-text"> 进程的终止</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#api-2"><span class="nav-number">6.4.1.</span> <span class="nav-text"> API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E7%BB%86%E8%8A%82"><span class="nav-number">6.4.2.</span> <span class="nav-text"> 进程终止的细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%80%E5%87%BA%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">6.4.3.</span> <span class="nav-text"> 退出处理程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9B%91%E6%8E%A7"><span class="nav-number">6.5.</span> <span class="nav-text"> 进程监控</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-number">6.5.1.</span> <span class="nav-text"> 等待子进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">6.5.2.</span> <span class="nav-text"> 孤儿进程与僵尸进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigchld%E4%BF%A1%E5%8F%B7"><span class="nav-number">6.5.3.</span> <span class="nav-text"> SIGCHLD信号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="nav-number">6.6.</span> <span class="nav-text"> 程序执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%96%B0%E7%A8%8B%E5%BA%8F"><span class="nav-number">6.6.1.</span> <span class="nav-text"> 执行新程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E4%BF%A1%E5%8F%B7"><span class="nav-number">6.6.2.</span> <span class="nav-text"> 文件描述符与信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8Cshell%E5%91%BD%E4%BB%A4"><span class="nav-number">6.6.3.</span> <span class="nav-text"> 执行shell命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84%E5%92%8C%E4%BC%9A%E8%AF%9D"><span class="nav-number">6.7.</span> <span class="nav-text"> 进程组和会话</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-6"><span class="nav-number">6.7.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="nav-number">6.7.2.</span> <span class="nav-text"> 进程组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D"><span class="nav-number">6.7.3.</span> <span class="nav-text"> 会话</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E8%B0%83%E5%BA%A6"><span class="nav-number">6.8.</span> <span class="nav-text"> 进程优先级和调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">6.8.1.</span> <span class="nav-text"> 进程优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">6.8.2.</span> <span class="nav-text"> 实时进程调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cpu%E4%BA%B2%E5%92%8C%E5%8A%9B"><span class="nav-number">6.8.3.</span> <span class="nav-text"> CPU亲和力</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90"><span class="nav-number">6.9.</span> <span class="nav-text"> 进程资源</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8"><span class="nav-number">6.9.1.</span> <span class="nav-text"> 进程资源使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="nav-number">6.9.2.</span> <span class="nav-text"> 进程资源限制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#daemon%E8%BF%9B%E7%A8%8B"><span class="nav-number">6.10.</span> <span class="nav-text"> DAEMON进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-7"><span class="nav-number">6.10.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="nav-number">6.10.2.</span> <span class="nav-text"> 创建流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">6.10.3.</span> <span class="nav-text"> 重新初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#syslog%E5%B7%A5%E5%85%B7"><span class="nav-number">6.10.4.</span> <span class="nav-text"> syslog工具</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">7.</span> <span class="nav-text"> 线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-8"><span class="nav-number">7.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%BB%88%E6%AD%A2"><span class="nav-number">7.2.</span> <span class="nav-text"> 创建与终止</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%88%86%E7%A6%BB"><span class="nav-number">7.3.</span> <span class="nav-text"> 线程的连接与分离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">7.4.</span> <span class="nav-text"> 线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-number">7.4.1.</span> <span class="nav-text"> 互斥量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">7.4.2.</span> <span class="nav-text"> 条件变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">7.5.</span> <span class="nav-text"> 线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%8F%96%E6%B6%88"><span class="nav-number">7.6.</span> <span class="nav-text"> 线程取消</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-number">7.7.</span> <span class="nav-text"> 线程实现细节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8Bid"><span class="nav-number">7.7.1.</span> <span class="nav-text"> 线程ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A0%88"><span class="nav-number">7.7.2.</span> <span class="nav-text"> 线程栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BF%A1%E5%8F%B7"><span class="nav-number">7.7.3.</span> <span class="nav-text"> 线程和信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">7.7.4.</span> <span class="nav-text"> 线程和进程控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.7.5.</span> <span class="nav-text"> Linux的线程实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7"><span class="nav-number">8.</span> <span class="nav-text"> 信号</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-9"><span class="nav-number">8.1.</span> <span class="nav-text"> 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E4%BA%A7%E7%94%9F"><span class="nav-number">8.1.1.</span> <span class="nav-text"> 信号产生</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BC%A0%E9%80%92%E4%B8%8E%E5%93%8D%E5%BA%94"><span class="nav-number">8.1.2.</span> <span class="nav-text"> 信号的传递与响应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.1.3.</span> <span class="nav-text"> 信号类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="nav-number">8.2.</span> <span class="nav-text"> 信号集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E6%8E%A9%E7%A0%81"><span class="nav-number">8.3.</span> <span class="nav-text"> 信号掩码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E4%BF%A1%E5%8F%B7"><span class="nav-number">8.4.</span> <span class="nav-text"> 特殊信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%BD%AE"><span class="nav-number">8.5.</span> <span class="nav-text"> 改变信号处置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#api-3"><span class="nav-number">8.5.1.</span> <span class="nav-text"> API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%99%A8%E5%87%BD%E6%95%B0"><span class="nav-number">8.5.2.</span> <span class="nav-text"> 信号处理器函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">8.5.2.1.</span> <span class="nav-text"> 设计原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%99%A8%E5%87%BD%E6%95%B0"><span class="nav-number">8.5.2.2.</span> <span class="nav-text"> 终止信号处理器函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sa_siginfo%E6%A0%87%E5%BF%97"><span class="nav-number">8.5.2.3.</span> <span class="nav-text"> SA_SIGINFO标志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%AD%E6%96%AD%E5%92%8C%E9%87%8D%E5%90%AF"><span class="nav-number">8.5.2.4.</span> <span class="nav-text"> 系统调用的中断和重启</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="nav-number">8.6.</span> <span class="nav-text"> 信号相关操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="nav-number">8.6.1.</span> <span class="nav-text"> 发送信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E4%BF%A1%E5%8F%B7%E6%8F%8F%E8%BF%B0"><span class="nav-number">8.6.2.</span> <span class="nav-text"> 显示信号描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E4%BA%8E%E7%AD%89%E5%BE%85%E7%8A%B6%E6%80%81%E7%9A%84%E4%BF%A1%E5%8F%B7"><span class="nav-number">8.6.3.</span> <span class="nav-text"> 处于等待状态的信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E4%BF%A1%E5%8F%B7"><span class="nav-number">8.6.4.</span> <span class="nav-text"> 等待信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%8E%B7%E5%8F%96%E4%BF%A1%E5%8F%B7"><span class="nav-number">8.6.5.</span> <span class="nav-text"> 通过文件描述符获取信号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E4%BF%A1%E5%8F%B7"><span class="nav-number">8.7.</span> <span class="nav-text"> 实时信号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-10"><span class="nav-number">8.7.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E5%AE%9E%E6%97%B6%E4%BF%A1%E5%8F%B7"><span class="nav-number">8.7.2.</span> <span class="nav-text"> 发送实时信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%AE%9E%E6%97%B6%E4%BF%A1%E5%8F%B7"><span class="nav-number">8.7.3.</span> <span class="nav-text"> 处理实时信号</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">9.</span> <span class="nav-text"> 进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E5%92%8Cfifo"><span class="nav-number">9.1.</span> <span class="nav-text"> 管道和FIFO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-11"><span class="nav-number">9.1.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-number">9.1.2.</span> <span class="nav-text"> 创建与使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8Eshell%E5%91%BD%E4%BB%A4%E9%80%9A%E4%BF%A1"><span class="nav-number">9.1.3.</span> <span class="nav-text"> 与shell命令通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fifo"><span class="nav-number">9.1.4.</span> <span class="nav-text"> FIFO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E8%AF%AD%E4%B9%89"><span class="nav-number">9.1.5.</span> <span class="nav-text"> 读写语义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#system-v-ipc"><span class="nav-number">9.2.</span> <span class="nav-text"> System V IPC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">9.2.1.</span> <span class="nav-text"> 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">9.2.2.</span> <span class="nav-text"> 消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%88%96%E6%89%93%E5%BC%80"><span class="nav-number">9.2.2.1.</span> <span class="nav-text"> 创建或打开</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E4%BA%A4%E6%8D%A2"><span class="nav-number">9.2.2.2.</span> <span class="nav-text"> 消息交换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%8E%A7%E5%88%B6"><span class="nav-number">9.2.2.3.</span> <span class="nav-text"> 消息队列控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">9.2.2.4.</span> <span class="nav-text"> 关联数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">9.2.2.5.</span> <span class="nav-text"> 缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">9.2.3.</span> <span class="nav-text"> 信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="nav-number">9.2.3.1.</span> <span class="nav-text"> 简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%88%96%E6%89%93%E5%BC%80-2"><span class="nav-number">9.2.3.2.</span> <span class="nav-text"> 创建或打开</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">9.2.3.3.</span> <span class="nav-text"> 控制信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%85%B3%E8%81%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">9.2.3.4.</span> <span class="nav-text"> 信号量关联数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%93%8D%E4%BD%9C"><span class="nav-number">9.2.3.5.</span> <span class="nav-text"> 信号量操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="nav-number">9.2.3.6.</span> <span class="nav-text"> 缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">9.2.4.</span> <span class="nav-text"> 共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="nav-number">9.2.4.1.</span> <span class="nav-text"> 简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%88%96%E6%89%93%E5%BC%80-3"><span class="nav-number">9.2.4.2.</span> <span class="nav-text"> 创建或打开</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">9.2.4.3.</span> <span class="nav-text"> 使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">9.2.4.4.</span> <span class="nav-text"> 控制操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%85%B3%E8%81%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">9.2.4.5.</span> <span class="nav-text"> 共享内存关联数据结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#posix-ipc"><span class="nav-number">9.3.</span> <span class="nav-text"> POSIX IPC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-4"><span class="nav-number">9.3.1.</span> <span class="nav-text"> 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-2"><span class="nav-number">9.3.2.</span> <span class="nav-text"> 消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%BC%80-%E5%85%B3%E9%97%AD%E5%92%8C%E6%96%AD%E5%BC%80"><span class="nav-number">9.3.2.1.</span> <span class="nav-text"> 打开、关闭和断开</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%89%B9%E6%80%A7"><span class="nav-number">9.3.2.2.</span> <span class="nav-text"> 消息队列特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%B6%88%E6%81%AF"><span class="nav-number">9.3.2.3.</span> <span class="nav-text"> 交换消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5"><span class="nav-number">9.3.2.4.</span> <span class="nav-text"> 消息通知</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#posix%E5%92%8Csystem-v%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%AF%94%E8%BE%83"><span class="nav-number">9.3.2.5.</span> <span class="nav-text"> POSIX和System V消息队列比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F-2"><span class="nav-number">9.3.3.</span> <span class="nav-text"> 信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-12"><span class="nav-number">9.3.3.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">9.3.3.2.</span> <span class="nav-text"> 命名信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%93%8D%E4%BD%9C-2"><span class="nav-number">9.3.3.3.</span> <span class="nav-text"> 信号量操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AA%E5%91%BD%E5%90%8D%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">9.3.3.4.</span> <span class="nav-text"> 未命名信号量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-2"><span class="nav-number">9.3.4.</span> <span class="nav-text"> 共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-13"><span class="nav-number">9.3.4.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%AF%B9%E8%B1%A1"><span class="nav-number">9.3.4.2.</span> <span class="nav-text"> 创建共享内存对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%AF%B9%E8%B1%A1"><span class="nav-number">9.3.4.3.</span> <span class="nav-text"> 删除共享内存对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#socket"><span class="nav-number">9.4.</span> <span class="nav-text"> SOCKET</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-5"><span class="nav-number">9.4.1.</span> <span class="nav-text"> 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-2"><span class="nav-number">9.4.2.</span> <span class="nav-text"> 系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81socket"><span class="nav-number">9.4.3.</span> <span class="nav-text"> 流socket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%A5socket"><span class="nav-number">9.4.4.</span> <span class="nav-text"> 数据报socket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unix-domain"><span class="nav-number">9.4.5.</span> <span class="nav-text"> UNIX domain</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#internet-domain"><span class="nav-number">9.4.6.</span> <span class="nav-text"> Internet domain</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E7%94%A8%E6%B3%95"><span class="nav-number">9.4.7.</span> <span class="nav-text"> 其它用法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E5%AE%83io%E6%A8%A1%E5%9E%8B"><span class="nav-number">10.</span> <span class="nav-text"> 其它I&#x2F;O模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-14"><span class="nav-number">10.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">10.2.</span> <span class="nav-text"> I&#x2F;O多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-6"><span class="nav-number">10.2.1.</span> <span class="nav-text"> 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-3"><span class="nav-number">10.2.2.</span> <span class="nav-text"> 系统调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8io"><span class="nav-number">10.3.</span> <span class="nav-text"> 信号驱动I&#x2F;O</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll"><span class="nav-number">10.4.</span> <span class="nav-text"> epoll</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yufei Luo"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Yufei Luo</p>
  <div class="site-description" itemprop="description">哪怕什么真理无穷，进一寸有进一寸的欢喜</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">89</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x5ZjM1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lyf35"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmx5ZjEyMzQwMDAwMDBAMTYzLmNvbQ==" title="E-Mail → mailto:lyf1234000000@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



      </section>
        <div class="back-to-top animated">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x5ZjM1" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lyf35.github.io/2021/02/25/Linux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%EF%BC%88%E6%91%98%E5%BD%95%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Yufei Luo">
      <meta itemprop="description" content="哪怕什么真理无穷，进一寸有进一寸的欢喜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yufei Luo's Blog">
    </span>

    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux-系统编程接口（摘录）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-25 12:21:54" itemprop="dateCreated datePublished" datetime="2021-02-25T12:21:54+08:00">2021-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-14 21:53:34" itemprop="dateModified" datetime="2021-03-14T21:53:34+08:00">2021-03-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/" itemprop="url" rel="index"><span itemprop="name">工程实践</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          
            <span id="/2021/02/25/Linux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%EF%BC%88%E6%91%98%E5%BD%95%EF%BC%89/" class="post-meta-item leancloud_visitors" data-flag-title="Linux-系统编程接口（摘录）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>107k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:37</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>注：本文的内容摘录自《Linux/UNIX系统编程手册》（原名The Linux Programming Interface）</p>
<a id="more"></a>
<h1 id="系统调用"><a class="markdownIt-Anchor" href="#系统调用"></a> 系统调用</h1>
<p>系统调用是受控的内核入口，借助于这一机制，进程可以请求内核去执行某些动作。内核以应用程序编程接口（API）的形式，提供了一系列的服务供程序访问，包括创建新进程，执行I/O等。</p>
<p>执行系统调用时会完成如下这些步骤：</p>
<ol>
<li>应用程序调用C语言函数库的外壳（wrapper）函数，来发起系统调用</li>
<li>外壳函数将系统调用参数放入到特定的寄存器中</li>
<li>外壳函数将系统调用编号复制到寄存器%eax</li>
<li>外壳函数执行中断机器指令（int 0x80），使处理器从用户态切换到内核态</li>
<li>内核调用<code>system_call()</code>例程：
<ol>
<li>在内核栈中保存寄存器的值</li>
<li>审核系统调用编号的有效性</li>
<li>以系统调用编号对存放所有调用服务例程的列表进行索引，发现并调用相应的系统调用服务例程，然后将结果状态返回给<code>system_call()</code></li>
<li>从内核栈恢复各个寄存器的值，并将系统调用返回值置于栈中</li>
<li>返回至外壳函数，将处理器切换至用户态</li>
</ol>
</li>
<li>如果系统调用的返回值表明调用有误，外壳函数会使用该值来设置全局变量<code>errno</code>，然后外壳函数返回调用程序，并同时返回一个整型值，表明系统调用是否成功。</li>
</ol>
<h1 id="系统限制和选项"><a class="markdownIt-Anchor" href="#系统限制和选项"></a> 系统限制和选项</h1>
<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>UNIX系统中需要对各种各样的系统特性和资源进行限制，并选择提供或者不提供由各种标准定义的选项，例如一个进程能同时拥有多少已打开的文件、路径名的最大长度、一个程序的参数列表可以多大等。在不同的操作系统实现中，这些变量往往不同。</p>
<h2 id="系统限制"><a class="markdownIt-Anchor" href="#系统限制"></a> 系统限制</h2>
<p>针对于系统中的每个限制，所有的实现都必须支持一个最小值，它们被定义为<code>&lt;limits.h&gt;</code>文件中的常量，命名形如<code>_POSIX_XXX_MAX</code>。这类常量的每一个都对应着对某类资源或者特性的上限，且要求这些上限具有一个确定的最小值。而在某些情况下，需要为某个限制提供一个最大值，对这些值的命名中包含字符串<code>_MIN</code>，它们代表了对某些资源的下限。</p>
<p>这些系统限制分为三类：</p>
<ol>
<li>
<p>运行时恒定值：这些值可能依赖于具体的运行环境，需要在程序运行时调用<code>sysconf()</code>函数来获取。这一函数用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sysconf</span><span class="params">(<span class="keyword">int</span> name)</span> <span class="comment">//返回name指代的系统限制的数值，如果返回-1则代表这个系统限制未被确定或者发生错误</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>路径名变量值：与路径名（文件、目录、终端等）相关的限制，每个限制可能是相对于某个系统实现的常量，也可能随文件系统的不同而不同。在限制可能因路径名而发生变化的情况下，应用程序可以使用<code>pathconf()</code>或<code>fpathconf()</code>来获取该值。它们的用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">pathconf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">int</span> name)</span> <span class="comment">//返回name指代的系统限制的数值，如果返回-1则代表这个系统限制未被确定或者发生错误</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fpathconf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> name)</span> <span class="comment">//返回name指代的系统限制的数值，如果返回-1则代表这个系统限制未被确定或者发生错误</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>运行时可增加值：对于某些系统限制，特定系统在运行时可能会增加该值，应用程序可以使用<code>sysconf()</code>来获得系统所支持的实际值。</p>
</li>
</ol>
<h2 id="系统选项"><a class="markdownIt-Anchor" href="#系统选项"></a> 系统选项</h2>
<p>对于一些选项，如实时信号、POSIX共享内存、任务控制等，它们允许自行定义。通过在<code>&lt;unistd.h&gt;</code>文件中定义相应的常量，便可实现在编译时通过其对特定选项的支持。</p>
<p>各个选项常量在定义之后，其值必为下列之一：</p>
<ul>
<li>值为-1：表示不支持该选项。此时，系统无需定义与该选项相关的头文件、数据类型和函数接口</li>
<li>值为0：表示实现可能支持该选项，应用程序需要在运行时检查该选项是否获得支持</li>
<li>值大于0：表示实现支持该选项，实现定义了与该选项有关的所有头文件、数据类型和函数接口，其行为也符合规范要求</li>
</ul>
<h1 id="文件操作"><a class="markdownIt-Anchor" href="#文件操作"></a> 文件操作</h1>
<h2 id="文件系统"><a class="markdownIt-Anchor" href="#文件系统"></a> 文件系统</h2>
<h3 id="设备文件"><a class="markdownIt-Anchor" href="#设备文件"></a> 设备文件</h3>
<p>设备专用文件与系统中的某个设备对应。在内核中，每种设备类型都有与之对应的设备驱动程序，用来处理设备的所有I/O请求。设备驱动程序属内核代码单元，可执行一系列操作，（通常）与相关硬件的输入/输出动作相对应。</p>
<p>由设备驱动程序提供的API 是固定的，包含的操作对应于系统调用<code>open()</code>、<code>close()</code>、<code>read()</code>、<code>write()</code>、<code>mmap()</code>以及<code>ioctl()</code>。每个设备驱动程序所提供的接口一致，这隐藏了每个设备在操作方面的差异，从而满足了I/O 操作的通用性。</p>
<p>一些设备是实际存在的，如鼠标、磁盘和磁带设备；而另一些设备是虚拟的，就是不存在相应的硬件，但是内核会通过设备驱动程序提高一种抽象设备。设备可分为字符型设备和块设备，字符型设备基于每个字符来处理数据，如终端和键盘；而块设备则每次处理一块数据，如磁盘和磁带。在文件系统中，设备文件通常位于<code>/dev</code>目录下。</p>
<p>每个设备文件都有一个主ID和辅ID，主ID号标识一般的设备登记，内核使用主ID号查找与该类设备相应的驱动程序；而辅ID号则能够在一般等级中唯一标识特定设备。每个设备驱动程序都会将自己与特定主设备号的关联关系向内核注册，从而建立设备专用文件和设备驱动程序之间的关系。</p>
<h3 id="磁盘和分区"><a class="markdownIt-Anchor" href="#磁盘和分区"></a> 磁盘和分区</h3>
<p>常规文件和目录通常都存放在磁盘设备中，每块磁盘都可以划分为一个或者多个不重叠的分区，而内核将每个分区视为<code>/dev</code>路径下的单独设备。磁盘分区通常只存放三种类型的信息：文件系统、数据区域、交换区域。</p>
<h3 id="文件系统结构"><a class="markdownIt-Anchor" href="#文件系统结构"></a> 文件系统结构</h3>
<p>文件系统是对常规文件和目录的组织集合，磁盘的每个分区都对应于一个文件系统。Linux支持多种不同的文件系统，包括传统的文件系统、原生UNIX文件系统、网络文件系统、日志文件系统（文件更新时间变长，但是无需在系统崩溃之后检查文件系统的一致性）等。</p>
<p>在文件系统中，用来分配空间的基本单位是逻辑块，即文件系统所在磁盘设备上若干连续的物理块。文件系统由以下几个部分组成：</p>
<ul>
<li>引导块：文件系统的首块。引导块只是用来引导操作系统的信息。</li>
<li>超级块：紧随引导块之后的一个独立块，包含与文件系统有关的参数信息，包括i节点表的容量、文件系统逻辑块的大小、文件系统大小</li>
<li>i节点表：文件系统中的每个文件或者目录在i节点表中都对应着唯一一条记录，其中包含了关于文件的各种信息，包括文件类型、文件归属、文件访问权限、时间戳、文件大小、分配给文件的块数量、指向文件数据块的指针等。</li>
<li>数据块：用于存放数据</li>
</ul>
<p>在ext2文件系统中，由于存储文件的数据块不一定连续甚至不一定按顺序存放，因此i节点表内维护了一组指针，如下图所示：</p>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151455.png" alt="image-20210628151559251" style="zoom:67%;" />
<p>其中，每个i节点包含15个指针，前12个指向文件前12个块的位置，而后面则是一个指向指针块的指针，提供了第13个及后续数据块的位置。指针块中指针的数量取决于文件系统中块的大小。而如果文件较大时，也可以是多重的间接指针。这样就在维持i节点结构大小固定的情况下，支持任意大小的文件；同时文件系统可以用不连续方式存储文件块，并支持随机访问文件；此外，对于小文件来说，这种设计也满足了对文件数据块的快速访问（前12个为直接指针）</p>
<h3 id="虚拟文件系统"><a class="markdownIt-Anchor" href="#虚拟文件系统"></a> 虚拟文件系统</h3>
<p>由于Linux支持的各种文件系统所对应的底层实现细节并不相同，因此虚拟文件系统（VFS）为文件系统创建了一个抽象层来解决这一问题。VFS为文件系统定义了一套通用接口，所有与文件交互的程序都会安装这一接口进行操作，而每种文件系统也会提供VFS接口的实现。</p>
<p>VFS接口的操作与设计文件系统和目录的所有常规系统调用对应，包括<code>open()</code>, <code>read()</code>, <code>write()</code>, <code>lseek()</code>, <code>close()</code>, <code>truncate()</code>, <code>stat()</code>, <code>mount()</code>, <code>umount()</code>, <code>mmap()</code>, <code>mkdir()</code>, <code>link()</code>, <code>unlink()</code>, <code>symlink()</code>, <code>rename()</code>。</p>
<h3 id="目录层级与文件挂载"><a class="markdownIt-Anchor" href="#目录层级与文件挂载"></a> 目录层级与文件挂载</h3>
<p>Linux系统下所有文件系统中的文件都位于根目录树下，而树根就是根目录“/”，其他的文件系统都被挂载在根目录之下，被视为整个目录层级的子树。</p>
<p>在Linux系统下，使用<code>mount device directory</code>命令即可将名为device的文件系统挂载到目录层级中由directory指定的目录。使用<code>unmount</code>命令则会相应地卸载文件系统。如果不带任何参数执行<code>mount</code>命令，则可以列出当前已经挂载地文件系统。</p>
<p>同时，系统调用<code>mount()</code>也可以用来挂载文件，相应的卸载文件的系统调用为<code>umount()</code>和<code>umount2()</code>，它们的用法为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* source, <span class="keyword">const</span> <span class="keyword">char</span>* target, <span class="keyword">const</span> <span class="keyword">char</span>* fstype, <span class="keyword">unsigned</span> <span class="keyword">long</span> mountflags, <span class="keyword">const</span> <span class="keyword">void</span>* data)</span> <span class="comment">//其中source指定要挂载的文件系统，target代表挂载的目录，fstype标识文件系统的类型，mountflags为掩码，用于修改mount操作，data为一个指向信息缓冲区的指针，对其信息的解释取决于文件系统。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">umount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* target)</span> <span class="comment">//target指定待卸载文件系统的挂载点</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">umount2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* target, <span class="keyword">int</span> flags)</span> <span class="comment">//加入flags参数，用于对卸载操作进行控制</span></span></span><br><span class="line"><span class="function"><span class="comment">//上述三个函数的返回值0代表成功，-1代表失败</span></span></span><br></pre></td></tr></table></figure>
<p>要获得已挂载文件系统的相关信息，可以使用下面两个系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/statvfs.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">statvfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, struct statvfs* statvfsbuf)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatvfs</span><span class="params">(<span class="keyword">int</span> fd, struct statvfs* statvfsbuf)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回0代表成功，-1代表失败</span></span></span><br></pre></td></tr></table></figure>
<p>上述调用同时会得到一个<code>statvfs</code>结构，属于由<code>statvfsbuf</code>指向的缓冲区。其中，<code>statvfs</code>数据结构包含了关于文件系统的信息。</p>
<p>Linux系统下的三个文件包含了当前已挂载或者可挂载的文件系统信息：</p>
<ul>
<li><code>/proc/mounts</code>：它是内核数据接口的接口，因此总是包含已挂载文件系统的精确信息</li>
<li><code>/etc/mtab</code>：包含的内容与<code>/proc/mounts</code>类似，但是更加详细一些。</li>
<li><code>/etc/fstab</code>：由系统管理员手动维护，包含了对系统支持的所有文件系统的描述</li>
</ul>
<p>这三个文件的格式相同，都包含6个字段：已挂载设备名、设备挂载点、文件系统类型、挂载标志、用于控制对文件系统备份操作的数字、用于控制对文件系统检查顺序的数字。</p>
<h3 id="虚拟内存文件系统"><a class="markdownIt-Anchor" href="#虚拟内存文件系统"></a> 虚拟内存文件系统</h3>
<p>Linux同样支持驻留在内存中的虚拟文件系统tmpfs。对于应用程序来说，可以和使用其他文件系统一样的方法进行操作，但是由于不涉及磁盘访问，因此虚拟文件系统的操作速度极快。</p>
<p>要创建一个tmpfs文件系统，可以使用如下命令：<code>mount -t tmpfs source target</code></p>
<h2 id="目录与链接"><a class="markdownIt-Anchor" href="#目录与链接"></a> 目录与链接</h2>
<h3 id="硬链接"><a class="markdownIt-Anchor" href="#硬链接"></a> 硬链接</h3>
<p>在文件系统中，目录的存储方式与普通文件类似，但是它们有两点不同：</p>
<ol>
<li>在i-node条目中，目录会被标记为一种不同的文件类型</li>
<li>目录是经过特殊组织而成的文件，本质上是一个表格，其中包含了文件名和i-node编号</li>
</ol>
<p>文件i-node中所存储的信息列表中并未包含文件名，仅通过目录列表内的一个映射来定义文件名称。通过这种方式，能够在相同或者不同目录中创建多个名称，每个均指向相同的i-node节点。这些名称被称为链接，有时也被称为硬链接。</p>
<p>在shell中，可以使用<code>ln</code>命令为一个已存在的文件创建新的硬链接，这样也就相当于同一个文件可以拥有多个名字。此时，如果移除其中一个文件名，另一个文件名以及文件本身将继续存在，但是会将文件i-node的链接计数减1。只有当文件的所有名字都被删除之后（即链接计数变为0），才会释放文件的i-node记录和数据块。</p>
<p>对硬链接有如下限制：</p>
<ol>
<li>硬链接需要与其所指代的文件驻留在同一个文件系统中</li>
<li>不能为目录创建硬链接，否则将会导致出现链接环路</li>
</ol>
<h3 id="软链接"><a class="markdownIt-Anchor" href="#软链接"></a> 软链接</h3>
<p>而软链接（符号链接）是一种特殊的文件类型，它的数据是另一文件的名称。在shell中，通过使用<code>ln -s</code>即可创建一个符号链接，<code>ls -F</code>命令的输出结果会在符号链接的尾部标记@。符号链接的内容可以是绝对或者相对路径，解释相对路径时将以链接本身的位置作为参照点。</p>
<p>需要注意的是，文件的链接计数中并未计算符号链接。因此，如果移除了符号链接所指向的文件名，符号链接还会继续存在。此时这一链接就变成了悬空链接，无法再对其进行解引用操作。也因此可以为并不存在的文件名创建一个符号链接。</p>
<p>由于符号链接指代一个文件名，因此它可以链接不同文件系统内的文件，也可以为目录创建符号链接。</p>
<p>符号链接直接可能会形成链路，在某些系统调用中如果指定了符号链接，内核会对一系列链接去层层解引用，直到最终文件。需要注意的是，有些系统调用会对符号链接进行解引用，而有些系统调用则对符号链接不做任何处理，直接作用于链接文件本身。</p>
<h3 id="链接的系统调用"><a class="markdownIt-Anchor" href="#链接的系统调用"></a> 链接的系统调用</h3>
<h4 id="创建和移除链接"><a class="markdownIt-Anchor" href="#创建和移除链接"></a> 创建和移除链接</h4>
<p>系统调用<code>link</code>和<code>unlink</code>可以被用于创建和移除硬链接，用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* oldpath, <span class="keyword">const</span> <span class="keyword">char</span>* newpath)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回0代表成功，-1代表失败</span></span></span><br></pre></td></tr></table></figure>
<p>在<code>link</code>系统调用中，如果<code>oldpath</code>提供的是一个硬链接，那么将以<code>newpath</code>参数指定的路径名创建一个新的链接，如果<code>newpath</code>指定的路径名存在，则产生错误。需要注意的是，<code>link</code>不会对符号链接进行解引用操作。</p>
<p>而<code>unlink</code>系统调用则移除一个链接，且如果此链接是指向文件的最后一个链接，则还会移除文件本身。<code>unlink</code>不能用于移除目录，也不会对符号链接进行解引用操作。</p>
<p>Linux内核除了为每个i-node维护链接计数，还会为文件已打开的文件描述符计数。因此，当移除指向文件的最后一个链接时，如果仍有进程持有指代该文件的打开文件描述符，则在关闭所有的这类描述符之前，系统实际上不会删除该文件。这将允许在取消对文件链接的时候，无需担心是否有其它进程已经将其打开。</p>
<h4 id="更改文件名"><a class="markdownIt-Anchor" href="#更改文件名"></a> 更改文件名</h4>
<p><code>rename</code>系统调用可以用于重命名文件，或者是将文件移动到同一文件系统中的另一目录：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* oldpath, <span class="keyword">const</span> <span class="keyword">char</span>* newpath)</span> <span class="comment">//成功返回0，失败返回-1</span></span></span><br></pre></td></tr></table></figure>
<p>这一调用将现有路径名<code>oldpath</code>重命名为<code>newpath</code>参数指定的路径名。该操作仅操作目录条目，而不移动文件数据。改名既不影响指向该文件的其它硬链接，也不影响持有该文件打开描述符的任何进程。</p>
<p><code>rename</code>满足下面的规则：</p>
<ul>
<li>如果<code>newpath</code>已经存在，则将其覆盖</li>
<li>如果<code>newpath</code>与<code>oldpath</code>指向同一文件，则不发生变化</li>
<li>两个参数中的符号链接都不解引用</li>
<li>如果<code>oldpath</code>指代文件，则不能将<code>newpath</code>指定为一个目录的路径名；而如果<code>oldpath</code>为目录名，则需要保证<code>newpath</code>不存在或者是空目录的名称，且<code>newpath</code>不能包含<code>oldpath</code>作为其目录前缀，此时相当于对目录重命名</li>
<li>两个参数所指代的文件需要位于同一文件系统</li>
</ul>
<h4 id="使用符号链接"><a class="markdownIt-Anchor" href="#使用符号链接"></a> 使用符号链接</h4>
<p>创建符号链接的系统调用如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filepath, <span class="keyword">const</span> <span class="keyword">char</span>* linkpath)</span> <span class="comment">//成功返回0，失败返回-1</span></span></span><br></pre></td></tr></table></figure>
<p><code>symlink</code>系统调用会针对于<code>filepath</code>指定的路径名创建一个新的符号链接<code>linkpath</code>。如果<code>linkpath</code>给定的路径名已经存在，则调用失败；而<code>filepath</code>可以为绝对或者相对路径，且它所命名的文件或者目录在调用时无需存在。</p>
<p>而获取符号链接本身的内容可以用如下系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">char</span>* buffer, <span class="keyword">size_t</span> bufsiz)</span> <span class="comment">//成功则返回实际放入buffer的字节数，失败返回-1</span></span></span><br></pre></td></tr></table></figure>
<p>这一系统调用会对<code>pathname</code>进行解引用，将其所指向的路径名称放入<code>buffer</code>指向的字符数组中，而<code>bufsiz</code>则对应于<code>buffer</code>参数的可用字节数。</p>
<h4 id="文件目录的创建和移除"><a class="markdownIt-Anchor" href="#文件目录的创建和移除"></a> 文件/目录的创建和移除</h4>
<p><code>mkdir</code>系统调用用于创建一个新的目录：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">mode_t</span> mode)</span> <span class="comment">//返回0表示成功，-1表示失败</span></span></span><br></pre></td></tr></table></figure>
<p><code>pathname</code>参数指定了新目录的路径名称，可为绝对路径或者相对路径；而<code>mode</code>参数指定了新目录的权限。在新建目录中包含两个条目<code>.</code>和<code>..</code>，分别代表指向目录自身的链接和指向父目录的链接。</p>
<p>需要注意的是，这一系统调用所创建的仅仅是路径名中的最后一部分，<code>pathname</code>参数中的父目录必须存在，这一函数才能执行成功。</p>
<p>如果要删除目录则可以使用如下的系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname)</span> <span class="comment">//返回0表示成功，-1表示失败</span></span></span><br></pre></td></tr></table></figure>
<p><code>pathname</code>可以为绝对路径也可以为相对路径。要使得<code>rmdir</code>调用成功，则必须保证<code>pathname</code>对应的目录为空。如果<code>pathname</code>为符号链接，则不会对其做解引用操作，并返回错误。</p>
<p>要移除文件或者空目录也可以用<code>remove</code>库函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname)</span> <span class="comment">//返回0表示成功，-1表示失败</span></span></span><br></pre></td></tr></table></figure>
<p>如果<code>pathname</code>是一个文件，那么<code>remove</code>会调用<code>unlink</code>；而如果<code>pathname</code>是目录，则调用的是<code>rmdir</code>。<code>remove</code>不对符号链接进行解引用操作，如果它是符号链接，则<code>remove</code>会移除链接本身，而不是链接指向的文件。</p>
<h4 id="读目录"><a class="markdownIt-Anchor" href="#读目录"></a> 读目录</h4>
<p>下面两个函数用于打开一个目录，并返回指向该目录的句柄，供后续调用使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function">DIR* <span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* dirpath)</span></span></span><br><span class="line"><span class="function">DIR* <span class="title">fdopendir</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果调用成功则返回文件目录流，失败则返回一个空指针</span></span></span><br></pre></td></tr></table></figure>
<p>函数的返回结果是一个<code>DIR</code>类型的指针，这一结构即为目录流。函数在返回时会将目录流指向目录列表的首条记录。在调用<code>fdopendir</code>之后，文件描述符将处于系统的控制之下，除了使用个别函数，程序不应该采取任何方式对其进行访问。</p>
<p>对于得到的目录流，可以使用<code>readdir</code>函数从中读取条目：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function">struct dirent* <span class="title">readdir</span><span class="params">(DIR* dirp)</span> <span class="comment">//调用成功则返回一个dirent类型数据结构，如果失败或者DIR位于目录流的末尾，则返回空指针</span></span></span><br></pre></td></tr></table></figure>
<p>每调用<code>readdir</code>一次，就会从<code>dirp</code>所指代的目录流中读取下一个目录条目，并返回一个指向<em>静态分配</em>的<code>dirent</code>数据结构的指针，其中包含了目录条目的信息。每次调用都会覆盖<code>dirent</code>结构。</p>
<p><code>readdir</code>函数的一个变体是<code>readdir_r</code>，这一函数是可重入的，用法为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readdir_r</span><span class="params">(DIR* dirp, struct dirent* entry, struct dirent** result)</span> <span class="comment">//成功返回0，失败则返回一个代表失败类型的正数</span></span></span><br></pre></td></tr></table></figure>
<p>这一函数会将下一项目录条目放在<code>entry</code>指向的<code>dirent</code>结构中，同时会在<code>result</code>放置指向该结构的指针。</p>
<p><code>rewinddir()</code>函数可以用于将目录流移动到起点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(DIR* dirp)</span></span></span><br></pre></td></tr></table></figure>
<p>而<code>closedir()</code>函数可以将打开状态的目录流关闭：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR* dirp)</span> <span class="comment">//成功返回0，失败返回-1</span></span></span><br></pre></td></tr></table></figure>
<p>一个目录流会与一个文件描述符相关联，<code>dirfd()</code>函数返回与<code>dirp</code>目录流相关联的文件描述符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dirfd</span><span class="params">(DIR* dirp)</span> <span class="comment">//成功则返回相应的文件描述符，失败返回-1</span></span></span><br></pre></td></tr></table></figure>
<p>而如果要递归遍历整个目录子树，可以使用<code>nftw()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ftw.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nftw</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* dirpath</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> (*func)(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">const</span> struct stat* statbuf, <span class="keyword">int</span> typeflag, struct FTW* ftwbuf),</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> nopenfd,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果成功遍历则返回0，失败则返回-1或者是func返回的第一个非0值</span></span></span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>nftw</code>会针对于给定的树执行未排序的前序遍历，即对于各个目录的处理要比各目录下的文件和子目录优先。其中<code>dirpath</code>代表要遍历的目录树，<code>func</code>代表对目录树的每个文件所调用的函数，<code>nopenfd</code>代表可使用文件描述符数量的最大值，<code>flags</code>参数可以对函数的操作进行修正。</p>
<h4 id="进程当前工作目录"><a class="markdownIt-Anchor" href="#进程当前工作目录"></a> 进程当前工作目录</h4>
<p>一个进程的当前工作目录定义了该进程解析相对路径名的起点。新进程的当前工作目录继承自父进程。</p>
<p>要获取当前工作目录可以用<code>getcwd</code>命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getcwd</span><span class="params">(<span class="keyword">char</span>* cwdbuf, <span class="keyword">size_t</span> size)</span> <span class="comment">//如果成功则返回cwdbuf，失败返回NULL</span></span></span><br></pre></td></tr></table></figure>
<p>这一函数会将内含当前目录绝对路径的字符串放置在<code>cwdbuf</code>指向的已分配缓冲区中，调用者需要为<code>cwdbuf</code>缓冲区分配至少<code>size</code>个字节的空间。一旦调用成功，<code>getcwd</code>将会返回一枚指向<code>cwdbuf</code>的指针。如果当前工作目录的路径名长度超过<code>size</code>，则会返回NULL，并将<code>errno</code>设置为<code>ERANGE</code>。</p>
<p>如果<code>cwdbuf</code>为NULL且<code>size</code>为0，那么glibc封装函数会为<code>getcwd</code>按需分配一个缓冲区，并将指向该缓冲区的指针作为函数的返回值。</p>
<p>要改变当前工作目录有两种方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchdir</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回0代表成功，-1代表失败</span></span></span><br></pre></td></tr></table></figure>
<p><code>chdir</code>系统调用将调用进程的当前工作目录改为由<code>pathname</code>指定的相对或者绝对路径名称，如果是符号链接还会解引用；而<code>fchdir</code>则是在指定目录时使用文件描述符，这一描述符为使用<code>open</code>打开相应目录时获得的。</p>
<h4 id="改变进程的根目录"><a class="markdownIt-Anchor" href="#改变进程的根目录"></a> 改变进程的根目录</h4>
<p>每个进程都有一个根目录，该目录是解释绝对路径（即以/开始的目录）时的起点。默认情况下，根目录为文件系统的真实根目录。有些场合需要改变一个进程的根目录，而特权级进程可以通过<code>chroot</code>系统调用来修改：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chroot</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname)</span> <span class="comment">//成功返回0，失败返回-1</span></span></span><br></pre></td></tr></table></figure>
<p><code>chroot</code>会将进程根目录改为<code>pathname</code>指定的目录，如果它为符号链接则要对其解引用。</p>
<h4 id="路径解析"><a class="markdownIt-Anchor" href="#路径解析"></a> 路径解析</h4>
<p><code>realpath</code>库函数可以用来解除路径中的符号链接，并解析其中对<code>/.</code>和<code>/..</code>的引用，从而生成一个以空字符结尾的字符串，内含相应的绝对路径名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">realpath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">char</span>* resolved_path)</span> <span class="comment">//如果成功则返回指向resolved_path的指针，失败返回NULL</span></span></span><br></pre></td></tr></table></figure>
<p>glibc的<code>realpath</code>实现允许将<code>resolved_path</code>设置为空，此时函数会为解析生成的路径名称分配一个缓冲区，并将指向该缓冲区的指针作为结果返回。</p>
<p>而<code>dirname</code>和<code>basename</code>两个函数可以将一个路径名字符串分解成目录和文件名两部分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;libgen.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">dirname</span><span class="params">(<span class="keyword">char</span>* pathname)</span> <span class="comment">//返回目录名</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">basename</span><span class="params">(<span class="keyword">char</span>* pathname)</span> <span class="comment">//返回文件名</span></span></span><br></pre></td></tr></table></figure>
<p>二者返回的字符串拼接起来，即可得到一个完整的路径名。</p>
<h2 id="监控文件事件"><a class="markdownIt-Anchor" href="#监控文件事件"></a> 监控文件事件</h2>
<h3 id="概述-2"><a class="markdownIt-Anchor" href="#概述-2"></a> 概述</h3>
<p>某些应用程序需要对文件或目录进行监控，已侦测其是否发生了特定事件。例如，当把文件加入或移出一目录时，图形化文件管理器应能判定此目录是否在其当前显示之列，而守护进程可能也想要监控自己的配置文件，以了解其是否被修改。Linux提供了inotify机制，以允许应用程序监控文件事件。使用inotify API由如下几个关键步骤：</p>
<ol>
<li>使用<code>inotify_init()</code>创建一个inotify实例，这一调用会返回一个文件描述符，用于在后续操作中指向该实例</li>
<li>应用程序使用<code>inotify_add_watch()</code>向inotify实例的监控列表添加条目，告知内核哪些文件是自己的兴趣所在。每个监控项包含一个路径名，以及一个相关的位掩码，指明所要监控的事件集合。</li>
<li>为了获得事件通知，应用程序需要针对inotify文件描述符执行<code>read()</code>操作，每次对<code>read()</code>的成功调用，都会返回一个或者多个<code>inotify_event</code>结构，其中各自记录了处于inotify实例监控之下的某个路径名所发生的事件</li>
<li>在结束监控时，应用程序关闭inotify文件描述符，这样便会自动清除与inotify实例相关的所有监控项。</li>
</ol>
<p>inotify机制不仅可以用于文件，还可以用于目录，监控目录时，与路径自身及其所含文件相关的事件都会通知给应用程序。</p>
<h3 id="api"><a class="markdownIt-Anchor" href="#api"></a> API</h3>
<p>与inotify相关的API调用包括：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/inotify.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inotify_init</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">//成功则返回一个文件描述符，失败返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inotify_add_watch</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">uint32_t</span> mask)</span> <span class="comment">//成功则会返回一个监控描述符（wd），失败返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inotify_rm_watch</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uint32_t</span> wd)</span> <span class="comment">//成功返回0，失败返回-1</span></span></span><br></pre></td></tr></table></figure>
<p>在使用<code>inotify_add_watch</code>时，位掩码参数<code>mask</code>标识了针对给定路径名而要监控的事件。</p>
<p>将监控项在监控列表中登记之后，应用程序可以使用<code>read</code>从inotify文件描述符中读取事件，以判定发生了哪些事件。如果直到读取时尚未发生任何事件，<code>read</code>调用会阻塞下去，直到有事件产生（如果设置了非阻塞的文件描述符标志，则会报错）</p>
<p>事件发生后，每次调用<code>read</code>都会返回一个缓冲区，其中包含一个或者多个<code>inotify_event</code>的数据结构。这一数据结构的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inotify_event</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> wd; <span class="comment">//监控描述符</span></span><br><span class="line">	<span class="keyword">uint32_t</span> mask; <span class="comment">//描述事件类型的位掩码</span></span><br><span class="line">	<span class="keyword">uint32_t</span> cookie; <span class="comment">//用于将相关的事件联系在一起</span></span><br><span class="line">	<span class="keyword">uint32_t</span> len; <span class="comment">//name字段的长度</span></span><br><span class="line">	<span class="keyword">char</span> name[]; <span class="comment">//以空字符填充的文件名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件加锁"><a class="markdownIt-Anchor" href="#文件加锁"></a> 文件加锁</h2>
<h3 id="flock函数"><a class="markdownIt-Anchor" href="#flock函数"></a> <code>flock</code>函数</h3>
<p><code>flock</code>系统调用在整个文件上放置一个锁。待加锁的文件是一个通过传入<code>fd</code>的一个打开着的文件描述符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flock</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> operation)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p><code>operation</code>参数为LOCK_SH（给文件加共享锁）、LOCK_EX（给文件加互斥锁）和LOCK_UN（解锁<code>fd</code>引用的文件）。如果要进行非阻塞操作，则可以使用或操作加上LOCK_NB选项。</p>
<p>任意数量的进程可同时持有一个文件上的共享锁，但在同一个时刻只有一个进程能够持有一个文件上的互斥锁。</p>
<h3 id="fcntl函数"><a class="markdownIt-Anchor" href="#fcntl函数"></a> <code>fcntl</code>函数</h3>
<p>使用<code>fcntl()</code>能够在一个文件的任意部分上放置一把锁，这个文件部分既可以是一个字节，也可以是整个文件。一般来讲，<code>fcntl()</code>会被用来锁住文件中与应用程序定义的记录边界对应的字节范围，这也是术语记录加锁的由来。Linux系统可以将一个记录锁应用在任意类型的文件描述符上。</p>
<p>用来创建或者删除一个文件锁的<code>fcntl</code>调用的形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">flockstr</span>;</span></span><br><span class="line">fcntl(fd, cmd, &amp;flockstr);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span>&#123;</span></span><br><span class="line">	<span class="keyword">short</span> l_type; <span class="comment">//表示锁的类型，可以为F_RDLCK（放置读锁）、F_WRLCK（放置写锁）、F_UNLCK（删除锁）其中之一</span></span><br><span class="line">    <span class="keyword">short</span> l_whence; <span class="comment">//表示l_start参数如何使用，可以设为SEEK_SET、SEEK_CUR和SEEK_END</span></span><br><span class="line">    <span class="keyword">off_t</span> l_start; <span class="comment">//锁的起始位置（相对于l_whence的位置）</span></span><br><span class="line">    <span class="keyword">off_t</span> l_len; <span class="comment">//加锁的字节长度。它可以设置为0，代表对l_start和l_whence确定的起始位置到文件结尾的所有字节全部加锁</span></span><br><span class="line">    <span class="keyword">pid_t</span> l_pid; <span class="comment">//如果cmd为F_GETLK，那么代表持有锁的进程ID</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>cmd</code>参数可以为F_SETLK（获取或者释放<code>flockstr</code>指定的字节上的锁，如果另一个进程持有与待加锁区域任意部分不兼容的锁则返回EAGAIN错误）、F_SETLKW（获取或释放锁，但是如果遇到待加锁区域不兼容的情况则会阻塞等待）、F_GETLK（检测释放可以在给定区域上锁）这三个值的其中一个。</p>
<h2 id="文件io"><a class="markdownIt-Anchor" href="#文件io"></a> 文件I/O</h2>
<h3 id="概述-3"><a class="markdownIt-Anchor" href="#概述-3"></a> 概述</h3>
<p>在Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、字符设备文件、块设备文件、套接字文件、管道文件和链接文件。文件描述符（file  descriptor）是内核为了高效管理已被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。一个程序刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3。</p>
<p>在Linux系统中，为了维护文件描述符，建立了三个表：进程级的文件描述符表（每个进程维护一个）、系统级的文件描述符表（所有进程共享）和文件系统的i-node表（所有进程共享），它们的关系如下图所示：</p>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151502.png" alt="image-20210624093356351" style="zoom: 50%;" />
<p>每一个文件描述符会与一个打开文件相对应。同时，不同的文件描述符也可以指向同一个文件。相同的文件可以被不同的进程打开，也可以在同一个进程中被多次打开。这些文件描述符也可以被重定向，从而指向其它任何文件对象。</p>
<p>大多数程序使用的3种标准的文件描述符如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">文件描述符</th>
<th style="text-align:center">用途</th>
<th style="text-align:center">POSIX名称</th>
<th style="text-align:center">stdio流</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">标准输入（默认指向键盘）</td>
<td style="text-align:center">STDIN_FILENO</td>
<td style="text-align:center">stdin</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">标准输出（默认指向终端）</td>
<td style="text-align:center">STDOUT_FILENO</td>
<td style="text-align:center">stdout</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">标准错误</td>
<td style="text-align:center">STDERR_FILENO</td>
<td style="text-align:center">stderr</td>
</tr>
</tbody>
</table>
<p>执行文件I/O操作的4个主要系统调用为：</p>
<ul>
<li><code>fd=open(pathname, flags, mode)</code>：打开<code>pathname</code>所标识的文件，并返回文件描述符，用于在后续的函数调用中指代打开的文件。如果文件不存在可以创建，这取决于<code>flags</code>参数的设置，同时<code>flags</code>参数还可以指定文件打开方式（只读、只写、读写）。<code>mode</code>参数指定了由<code>open()</code>调用创建文件的访问权限</li>
<li><code>numread=read(fd, buffer, count)</code>：调用从<code>fd</code>所指代的打开文件中读取至多<code>count</code>字节的数据，并存储到<code>buffer</code>中。</li>
<li><code>numwritten=write(fd, buffer, count)</code>：调用从<code>buffer</code>中读取多达<code>count</code>字节的数据写入<code>fd</code>所指代的已打开文件中。</li>
<li><code>status=close(fd)</code>：在所有输入/输出操作完成之后，调用该函数释放文件描述符以及与之相关的内核资源</li>
</ul>
<p>上述四个系统调用可以对所有类型的文件执行I/O操作，包括终端之类的设备。</p>
<h3 id="通用io"><a class="markdownIt-Anchor" href="#通用io"></a> 通用I/O</h3>
<h4 id="open"><a class="markdownIt-Anchor" href="#open"></a> <code>open()</code></h4>
<p><code>open()</code>系统调用既可以打开一个已经存在的文件，也可以创建并打开一个新文件。它的用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span></span><br></pre></td></tr></table></figure>
<p>如果打开成功，则返回一个文件描述符，用于在后续的函数调用中指代该文件；如果发生错误，则返回-1，并将<code>errno</code>设置为相应的错误标志。而且这一函数调用会保证，如果调用成功，则返回值是进程未使用的文件描述符中数值最小者。</p>
<p>其中参数的含义如下：</p>
<ul>
<li><code>pathname</code>：要打开的文件</li>
<li><code>flags</code>：位掩码，用于指定文件的访问模式，可以用一系列的常量进行位或运算进行组合，例如<code>O_RDWR|O_CREAT|O_TRUNC</code></li>
<li><code>mode</code>：如果使用<code>open()</code>创建新文件，则这一参数可以用于指定文件的访问权限；如果未指定<code>O_CREAT</code>标志，则可以省略该参数</li>
</ul>
<p>对于<code>flags</code>位掩码，它们可以使用的常量分为如下几组：</p>
<ul>
<li>文件访问模式标志：<code>O_RDONLY</code>，<code>O_WRONLY</code>，<code>O_RDWR</code>，分别表示以只读、只写、读写模式打开。这三个标志在<code>flags</code>参数中只能使用一个</li>
<li>文件创建标志：
<ul>
<li><code>O_CLOEXEC</code>：为新的文件描述符启用<code>close-on-exec</code>标志</li>
<li><code>O_CREAT</code>：如果文件不存在则创建一个新的空文件，此时需要额外提供<code>mode</code>参数</li>
<li><code>O_DIRECT</code>：无系统缓冲的文件I/O 操作，也就是应用程序在执行磁盘I/O是绕过缓冲区高速缓存，从用户空间直接将数据传递到文件或者磁盘设备。对于大多数应用而言，使用这一方式可能会大大降低性能，因此它只适用于有特定I/O需求的应用。如果使用直接I/O，则用于传递数据的缓冲区的内存边界、文件和设备的偏移量、以及待传递数据的长度都必须为块大小的整数倍，否则将会导致EINVAL错误</li>
<li><code>O_DIRECTORY</code>：如果<code>pathname</code>参数不是目录则返回错误</li>
<li><code>O_EXCL</code>：此标志与<code>O_CREAT</code>标志结合使用表明如果文件已经存在，则不会打开文件，且 <code>open()</code>调用失败，并返回错误，错误号<code>errno</code>为<code>EEXIST</code>。也就是说，此标志确保了调用者（<code>open( )</code>的调用进程）就是创建文件的进程。对文件是否存在的检查和创建文件属于同一原子操作。</li>
<li><code>O_LARGEFILE</code>：支持以大文件方式打开文件。由于存放文件偏移量的数据类型<code>off_t</code>是一个有符号的长整型数，因此在32位系统下，文件大小的限制为2GB以下。如果在32位系统下要处理大文件，则需要使用这一标志。此外，也可以在每个头文件中加入<code>#define _FILE_OFFSET_BITS 64</code>来实现。</li>
<li><code>O_NOATIME</code>：在读文件时，不更新文件的最近访问时间。要使用该标志，要么调用进程的有效用户ID必须与文件的拥有者相匹配，要么进程需要拥有特权（<code>CAP_FOWNER</code>）。否则，<code>open()</code>调用失败，并返回错误，错误号<code>errno</code>为<code>EPERM</code>。</li>
<li><code>O_NOCTTY</code>：如果正在打开的文件属于终端设备，这一标志防止其成为控制终端</li>
<li><code>O_NOFOLLOW</code>：在<code>open()</code>函数中指定了<code>O_NOFOLLOW</code>标志，且<code>pathname</code>参数属于符号链接，则<code>open()</code>函数将返回失败（错误号<code>errno</code>为<code>ELOOP</code>）。此标志在特权程序中极为有用，能够确保<code>open()</code>函数不对符号链接进行解引用</li>
<li><code>O_TRUNC</code>：如果文件已经存在且为普通文件，那么将清空文件内容，将其长度置0。在Linux 下使用此标志，无论以读、写方式打开文件，都可清空文件内容（在这两种情况下，都必须拥有对文件的写权限）</li>
</ul>
</li>
<li>文件状态标志：
<ul>
<li><code>O_APPEND</code>：总是在文件尾部追加数据。如果使用这一标志，则每次写入都会将文件偏移量移动至文件末尾，并完成数据写操作。这两步操作被合并到同一原子操作，避免了文件的脏写入问题。</li>
<li><code>O_ASYNC</code>：当对于<code>open()</code>调用所返回的文件描述符可以实施 I/O 操作时，系统会产生一个信号通知进程</li>
<li><code>O_DSYNC</code>：根据同步I/O 数据完整性的完成要求来执行文件写操作，也就是说后续对于这个文件的每个<code>write</code>调用都会自动将文件数据和用于获取数据的文件元数据（并不是所有的元数据）刷新到磁盘上。</li>
<li><code>O_NONBLOCK</code>：以非阻塞方式打开。如果<code>open()</code>调用没有立即打开文件，则返回错误，而不是陷入阻塞。而且调用<code>open()</code>成功之后，后续的I/O操作也是非阻塞的，如果I/O系统调用没有立即完成，则可能只会传输部分数据，或者系统调用失败。</li>
<li><code>O_SYNC</code>：以同步方式写入文件，也就是说后续对于这个文件的每个<code>write</code>调用都会自动将所有的文件数据和元数据刷新到磁盘上。</li>
</ul>
</li>
</ul>
<h4 id="read"><a class="markdownIt-Anchor" href="#read"></a> <code>read()</code></h4>
<p><code>read()</code>系统调用从文件描述符所指代的打开文件中读取数据，它的用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> count)</span></span></span><br></pre></td></tr></table></figure>
<p>其中<code>count</code>参数指定最多能够读取的字节数，<code>buffer</code>参数提供用来存放输入数据的内存缓冲区地址，缓冲区应该至少有<code>count</code>个字节。</p>
<p>如果<code>read()</code>调用成功，则返回实际读取的字节数；如果遇到文件结束则返回0；如果出现错误则返回-1。</p>
<h4 id="write"><a class="markdownIt-Anchor" href="#write"></a> <code>write()</code></h4>
<p><code>write()</code>系统调用将数据写入一个已经打开的文件中，它的用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> count)</span></span></span><br></pre></td></tr></table></figure>
<p><code>fd</code>为待写入文件的描述符，<code>count</code>参数指定最多能够写入文件的字节数，<code>buffer</code>参数为要写入文件中数据的内存缓冲区地址，缓冲区应该至少有<code>count</code>个字节。</p>
<p>如果函数调用成功，将返回实际写入文件的字节数。该返回值可能小于<code>count</code>，对于磁盘文件可能因为磁盘已满，或者进程资源对于文件大小的限制。</p>
<p>需要注意的是，对磁盘文件执行I/O操作时，<code>write()</code>调用成功并不能保证数据已经写入磁盘。这是因为为了减少磁盘活动量和加快<code>write()</code>系统调用，内核会缓存磁盘的I/O操作。</p>
<h4 id="close"><a class="markdownIt-Anchor" href="#close"></a> <code>close()</code></h4>
<p><code>close()</code>系统调用关闭一个打开的文件描述符，并将其释放回调用进程。这一文件描述符可以供该进程后续分配给其它文件。当一个进程终止时，将自动关闭它打开的所有文件描述符。它的用法为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br></pre></td></tr></table></figure>
<p>如果关闭成功，则返回0；失败则返回-1。</p>
<p>由于文件描述符属于有限资源，因此在程序中显式关闭不再需要的文件描述符是一个好的编程习惯，使得代码更具可读性也更加可靠。</p>
<h4 id="lseek"><a class="markdownIt-Anchor" href="#lseek"></a> <code>lseek()</code></h4>
<p>对于每个打开的文件，系统内核会记录一个文件偏移量（又被称为读写偏移量或指针）。文件偏移量指的是下一个<code>read()</code>或者<code>write()</code>操作的文件起始位置，以相对于文件头部起始点的位置来表示。文件第一个字节的偏移量为0。</p>
<p>打开一个文件时，会将文件偏移量设置为指向文件开始，以后每次<code>read()</code>或者<code>write()</code>调用都将自动对其进行调整，以指向已读或者已写数据的下一字节。</p>
<p>它的使用方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span></span><br></pre></td></tr></table></figure>
<p>如果设置成功，则返回新的偏移位置，失败则返回-1。其中，<code>fd</code>为文件描述符，指向一个已打开文件；<code>offset</code>参数指定了一个以字节为单位的数值，它是一个有符号的整型数；<code>whence</code>参数表明参照哪个基点来解释<code>offset</code>参数。</p>
<p><code>whence</code>参数可以为下列之一：</p>
<ul>
<li><code>SEEK_SET</code>：将文件偏移量设置为从文件头部起始点开始的<code>offset</code>个字节。此时<code>offset</code>必须为非负数。</li>
<li><code>SEEK_CUR</code>：相对于当前的文件偏移量，将文件偏移量调整<code>offset</code>个字节。此时<code>offset</code>可以为正也可以为负。</li>
<li><code>SEEK_END</code>：将文件偏移量设置为起始于文件尾部的<code>offset</code>个字节，也就是从文件最后一个字节之后的下一个字节算起。此时<code>offset</code>可以为正也可以为负。</li>
</ul>
<p>如果程序的文件偏移量已跨越了文件结尾，然后再执行I/O操作，则会造成文件空洞。从文件结尾后到新写入数据间的这段空间被称为文件空洞。从编程角度看，文件空洞中是存在字节的，读取空洞将返回以0（空字节）填充的缓冲区。然而，文件空洞不占用任何磁盘空间。直到后续某个时点，在文件空洞中写入了数据，文件系统才会为之分配磁盘块。文件空洞的主要优势在于，与为实际需要的空字节分配磁盘块相比，稀疏填充的文件会占用较少的磁盘空间。</p>
<h3 id="特殊用法"><a class="markdownIt-Anchor" href="#特殊用法"></a> 特殊用法</h3>
<h4 id="fcntl"><a class="markdownIt-Anchor" href="#fcntl"></a> <code>fcntl()</code></h4>
<p><code>fcntl()</code>系统调用对一个打开的文件描述符执行一系列的控制操作，它的用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ……)</span></span></span><br></pre></td></tr></table></figure>
<p>其中，<code>fd</code>指的是文件描述符，<code>cmd</code>用于设置这一函数的功能，而后面的省略号表示参数会根据<code>cmd</code>的具体类型而定。返回值为-1表示失败，如果成功的话，返回值会因<code>cmd</code>而异。下面为<code>fcntl</code>的一些使用示例。</p>
<p>例1：可以使用<code>fcntl()</code>来获取一个打开文件的访问模式和状态标志。方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flags=fcntl(fd, F_GETFL);</span><br></pre></td></tr></table></figure>
<p>后续可以使用<code>flags</code>参数通过位运算来检查一些状态标志，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flags &amp; O_SYNC <span class="comment">//测试文件是否以同步写方式打开</span></span><br><span class="line">accessMode = flags &amp; O_ACCMODE <span class="comment">//借助掩码O_ACCMODE，获取文件的访问模式</span></span><br><span class="line">accessMode == O_WRONLY <span class="comment">//通过与常量进行比对，来判断访问模式的种类</span></span><br></pre></td></tr></table></figure>
<p>例2：同样地，也可以修改一个打开文件的某些状态标志，允许更改的标志有：<code>O_APPEND</code>、<code>O_NONBLOCK</code>、<code>O_NOATIME</code>、<code>O_ASYNC</code>、<code>O_DIRECT</code>。修改方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> new_flags;</span><br><span class="line"><span class="comment">//do something to set new_flags</span></span><br><span class="line">fcntl(fd, F_SETFL, new_flags)</span><br></pre></td></tr></table></figure>
<p>例3：可以用<code>fcntl()</code>复制文件描述符，用法为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> newfd = fcntl(oldfd, F_DUPFD, startfd);</span><br></pre></td></tr></table></figure>
<p>其中，<code>oldfd</code>指的是要复制的文件描述符，<code>startfd</code>为文件描述符的副本进行编号限制，将使用不小于<code>startfd</code>的最小未用值作为描述符的编号。</p>
<p>此外，另一系统调用<code>dup3</code>也可以完成这一功能，用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup3</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd, <span class="keyword">int</span> flags)</span></span>;<span class="comment">//flags只支持O_CLOEXEC标志，fcntl中可以使用F_DUPFD_CLOEXEC标志完成同样功能</span></span><br></pre></td></tr></table></figure>
<p>如果成功则返回新的文件描述符，失败返回-1。</p>
<h4 id="特定偏移量的io"><a class="markdownIt-Anchor" href="#特定偏移量的io"></a> 特定偏移量的I/O</h4>
<p>系统调用<code>pread()</code>和<code>pwrite()</code>可以完成与<code>read()</code>和<code>write()</code>相类似的工作，但是前两者会在<code>offset</code>参数所指定的位置进行操作，而不是从当前的文件偏移量处，且不改变文件的当前偏移量。用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">pread</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset)</span></span>; <span class="comment">//如果成功则返回读取的字节数，0代表文件末尾，-1代表失败</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">pwrite</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset)</span></span>; <span class="comment">//如果成功则返回写入的字节数，-1代表失败</span></span><br></pre></td></tr></table></figure>
<h4 id="分散输入和集中输出"><a class="markdownIt-Anchor" href="#分散输入和集中输出"></a> 分散输入和集中输出</h4>
<p>系统调用<code>readv()</code>和<code>writev()</code>实现了分散输入和集中输出的功能，用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readv</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec* iov, <span class="keyword">int</span> iovcnt)</span></span>; <span class="comment">//如果成功则返回读取的字节数，0代表文件末尾，-1代表失败</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec* iov, <span class="keyword">int</span> iovcnt)</span></span>; <span class="comment">//如果成功则返回写入的字节数，-1代表失败</span></span><br></pre></td></tr></table></figure>
<p>上述两个系统调用一次可传输多个缓冲区的数据，数组<code>iov</code>定义了一组用来传输数据的缓冲区，<code>iovcnt</code>定义了<code>iov</code>数组的长度。<code>iovec</code>的数据结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>&#123;</span></span><br><span class="line">	<span class="keyword">void</span>* iov_base;</span><br><span class="line">	<span class="keyword">size_t</span> iov_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>readv()</code>从文件描述符中读取一片连续的字节，然后将其分散放置在<code>iov</code>指定的缓冲区中，从第一个缓冲区开始，依次填满所有的缓冲区。如果数据不足以填充所有缓冲区，则只会占有部分。</p>
<p><code>writev()</code>将<code>iov</code>指定的所有缓冲区的内容拼接起来，然后以连续字节序列写入文件描述符指代的文件中。</p>
<p>如果想在指定的文件偏移量处执行分散输入/集中输出，则可以使用下面两个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">preadv</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt, <span class="keyword">off_t</span> offset)</span></span>; <span class="comment">//如果成功则返回读取的字节数，0代表文件末尾，-1代表失败</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">pwritev</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt, <span class="keyword">off_t</span> offset)</span></span>; <span class="comment">//如果成功则返回写入的字节数，-1代表失败</span></span><br></pre></td></tr></table></figure>
<h4 id="文件截断"><a class="markdownIt-Anchor" href="#文件截断"></a> 文件截断</h4>
<p>下列两个系统调用可以将文件大小设置为<code>length</code>参数指定的值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">off_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果成功，则函数的返回值为0；失败则返回-1。当文件长度大于<code>length</code>时，调用会丢弃超出部分，但如果小于参数<code>length</code>，则调用将会在文件尾部添加一系列空字节或者一个文件空洞。</p>
<p>对于<code>truncate()</code>函数而言，它需要以路径名字符串来指定文件，并要求文件可访问，且对文件具有写权限。如果文件名为符号连接，则会对其解引用；而调用<code>ftruncate()</code>函数之前，需要以可写方式打开文件，获取其文件描述符，这一系统调用不会修改文件的偏移量。</p>
<h4 id="devfd目录"><a class="markdownIt-Anchor" href="#devfd目录"></a> <code>/dev/fd</code>目录</h4>
<p>对于每个进程，内核都提供了一个特殊的虚拟目录<code>/dev/fd</code>，该目录中包含<code>/dev/fd/n</code>形式的文件名，其中<code>n</code>是与进程中的打开文件相对应的编号。打开<code>/dev/fd</code>目录中的一个文件就等同于复制相应的文件描述符，因此下面两行代码等价：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd=open(<span class="string">&quot;/dev/fd/1&quot;</span>,O_WRONLY);</span><br><span class="line">fd=dup(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果使用<code>open()</code>函数打开文件，则需要将其设置为与原描述符相同的访问模式，此时如果在<code>flag</code>标志的设置中引入其它标志是无意义的，系统会自动忽略。</p>
<h4 id="创建临时文件"><a class="markdownIt-Anchor" href="#创建临时文件"></a> 创建临时文件</h4>
<p>有些程序需要创建一些临时文件，仅供其在运行期间使用，程序终止后立即删除。有两个函数可以用于创建临时文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkstemp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>如果成功则返回一个文件描述符，失败则返回-1。其中参数<code>template</code>采用路径名的形式，最后6个字符必须为<code>XXXXXX</code>，这6个字符将会被替换，以保证文件名的唯一性，而且修改后的字符串将会被保存到<code>template</code>参数中。因此，<code>template</code>参数被设置为字符数组，而不是字符串常量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE* <span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure>
<p><code>tmpfile()</code>函数会创建一个名称唯一的临时文件，并以读写方式打开。这一函数执行成功之后，将会返回一个文件流供<code>stdio</code>库函数使用。文件流关闭之后将自动删除临时文件。</p>
<h3 id="文件io缓冲"><a class="markdownIt-Anchor" href="#文件io缓冲"></a> 文件I/O缓冲</h3>
<h4 id="内核缓冲"><a class="markdownIt-Anchor" href="#内核缓冲"></a> 内核缓冲</h4>
<p><code>read()</code>和<code>write()</code>系统调用在操作磁盘文件时并不会直接发起磁盘访问，而是在用户空间缓冲区与内核缓冲区高速缓存之间复制数据。因此，写操作会先将用户空间内存传递到内核空间的缓冲区，然后在后续某个时刻再将缓冲区的数据刷写到磁盘中。如果在此期间另一进程试图读取文件的数据，内核将自动从缓冲区而不是文件中读取；而对于读操作，内核从磁盘中读取数据并存储到内核缓冲区，然后从缓冲区读取数据，直到把缓冲区的数据读完。对于序列化的文件访问，内核通常会执行预读以加快读取速度。</p>
<p>如果与文件发生大量的数据传输，通过采用大块空间缓冲数据，以及执行更少的系统调用，可以极大地提高I/O性能。</p>
<p>有时，我们需要控制文件I/O内核缓冲。<code>fsync</code>系统调用将使得缓冲数据与打开文件描述符<code>fd</code>相关的所有元数据都刷新到磁盘上。调用这一函数会强制使得文件处于同步I/O完成的状态，此时读请求的文件数据已经从磁盘传递给了进程，而写请求所指定的数据已经传递给磁盘，且用于获取数据的所有文件元数据以及所有发生更新的文件元数据也已经传递完毕。函数调用方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span> <span class="comment">//成功则返回0，失败返回-1</span></span></span><br></pre></td></tr></table></figure>
<p>这一函数只有在对磁盘设备的传递完成之后才会返回。</p>
<p>另一个系统调用是<code>fdatasync</code>，它的运作类似于<code>fsync</code>，但是对于文件的元数据来说，只要求获取数据的所有文件元数据传递完毕：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span> <span class="comment">//成功则返回0，失败返回-1</span></span></span><br></pre></td></tr></table></figure>
<p><code>fdatasync</code>可能会减少磁盘操作的次数，因为在这一函数的调用过程中，部分元数据的改变无需进行更新。而<code>fsync</code>则会强制将元数据也传递到磁盘上。对于某些对性能要求较高，但是对某些元数据准确性要求不高的应用，便可以通过这种方式减少磁盘操作次数。</p>
<p>而<code>sync</code>系统调用则会使包含更新文件信息的所有内核缓冲区（数据块、指针块、元数据等）刷新到磁盘上：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>在调用<code>open</code>函数时，指定<code>O_SYNC</code>标志也会使得后续每次调用<code>write</code>时都会自动将文件数据和元数据刷新到磁盘上。</p>
<p>需要特别注意的是，采用<code>O_SYNC</code>标志（或者频繁调用<code>fsync()</code>、<code>fdatasync()</code>或<code>sync()</code>）对性能的影响极大，会使得写入速度大大增加，尤其是当缓冲区的大小较低的时候。因此，如果需要强制刷新内核缓冲区，在设计应用程序的时候就应该考虑是否可以使用大尺寸的<code>write()</code>缓冲区。</p>
<h4 id="stdio库的缓冲"><a class="markdownIt-Anchor" href="#stdio库的缓冲"></a> stdio库的缓冲</h4>
<p>C语言的stdio函数库可以避免自行处理对数据的缓冲，一些相关的函数调用如下。</p>
<h5 id="设置缓冲模式"><a class="markdownIt-Anchor" href="#设置缓冲模式"></a> 设置缓冲模式</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE* stream, <span class="keyword">char</span>* buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span> <span class="comment">//成功则返回0，失败返回非0值</span></span></span><br></pre></td></tr></table></figure>
<p>在打开一个文件流之后，<code>setvbuf</code>函数必须在调用任何其他stdio函数之前调用。这一调用将会影响后续在指定流上的所有stdio操作。其中各个参数的含义如下：</p>
<ul>
<li><code>stream</code>：指定要修改的文件流</li>
<li><code>buf</code>：针对于参数<code>stream</code>要使用的缓冲区，如果值为<code>NULL</code>，那么stdio库会为其自动分配一个缓冲区；如果不为<code>NULL</code>，则使用指向<code>size</code>大小的内存块作为缓冲区</li>
<li><code>mode</code>：指定缓冲类型，具有下列值之一：
<ul>
<li><code>_IONBF</code>：不对I/O进行缓冲，每个stdio库函数立即调用<code>write()</code>和<code>read()</code>函数，并忽略<code>buf</code>和<code>size</code>参数。<code>stderr</code>默认为这一类型</li>
<li><code>_IOLBF</code>：采用行缓冲I/O，指代终端设备的流默认属于这一类型。对于输出流，在输出一个换行符之前将缓冲数据；而对于输入流则每次读取一行数据</li>
<li><code>_IOFBF</code>：采用全缓冲I/O，单次读写数据的大小与缓冲区相同。指代磁盘的流默认采用这一方式</li>
</ul>
</li>
</ul>
<p><code>setbuf</code>函数构建于<code>setvbuf</code>之上，执行了类似任务：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE* stream, <span class="keyword">char</span>* buf)</span></span></span><br></pre></td></tr></table></figure>
<p>在<code>setbuf</code>函数中，参数<code>buf</code>可以被设置为<code>NULL</code>表示无缓冲，也可以被设置为指向由调用者分配的<code>BUFSIZ</code>个字节大小的缓冲区。<code>BUFSIZ</code>参数定义于<code>&lt;stdio.h&gt;</code>头文件中。</p>
<p><code>setbuffer</code>函数类似于<code>setbuf</code>函数，但是允许调用者指定<code>buf</code>缓冲区大小：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuffer</span><span class="params">(FILE* stream, <span class="keyword">char</span>* buf, <span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure>
<h5 id="刷新stdio缓冲区"><a class="markdownIt-Anchor" href="#刷新stdio缓冲区"></a> 刷新stdio缓冲区</h5>
<p>无论当前采用哪一种缓冲区模式，在任何时候都可以使用<code>fflush</code>库函数强制将stdio输出流中的数据刷新到内核缓冲区中，用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE* stream)</span> <span class="comment">//返回0代表成功，EOF代表错误</span></span></span><br></pre></td></tr></table></figure>
<p>如果参数<code>stream</code>为<code>NULL</code>，则<code>fflush</code>函数将刷新所有的stdio缓冲区。也可以将这一函数应用于输入流，这将丢弃已经缓冲的输入数据。</p>
<h5 id="stdio库与系统调用混合"><a class="markdownIt-Anchor" href="#stdio库与系统调用混合"></a> stdio库与系统调用混合</h5>
<p>在同一文件上执行I/O操作时，还可以将系统调用和标准C语言库函数混合使用，下面两个函数有助于完成这一工作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE* stream)</span> <span class="comment">//成功则返回文件描述符，失败返回-1</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* mode)</span> <span class="comment">//成功则返回一个新的文件指针，失败返回NULL</span></span></span><br></pre></td></tr></table></figure>
<p>二者的功能相反，<code>fileno</code>函数是给定一个文件流，然后返回相应的文件描述符，之后便可在I/O系统调用中正常使用该文件描述符；而<code>fdopen</code>则给定一个文件描述符，然后创建一个使用该描述符进行文件I/O的相应流，<code>mode</code>参数与<code>fopen</code>中的含义相同，如果该参数与<code>fd</code>的访问模式不一致则会失败。</p>
<p><code>fdopen</code>函数对于非常规的文件描述符很有用，借助这一函数便可在套接字、管道等文件类型上使用stdio库函数。</p>
<h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4>
<p>stdio函数库和内核所采用的缓冲机制可以总结为下图：</p>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151521.png" alt="image-20210628135556878" style="zoom: 80%;" />
<h2 id="文件属性"><a class="markdownIt-Anchor" href="#文件属性"></a> 文件属性</h2>
<h3 id="获取文件信息"><a class="markdownIt-Anchor" href="#获取文件信息"></a> 获取文件信息</h3>
<p>使用如下几个系统调用，可以获取与文件有关的信息，其中大部分都提取自文件的i节点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, struct stat* statbuf)</span> <span class="comment">//返回所命名文件的相关信息</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, struct stat* statbuf)</span> <span class="comment">//与stat类似，但是如果文件是符号连接则返回符号连接自身</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat* statbuf)</span> <span class="comment">//返回由某个文件描述符所指代文件的信息</span></span></span><br><span class="line"><span class="function"><span class="comment">//对于上述调用，0表示成功，-1表示失败</span></span></span><br></pre></td></tr></table></figure>
<p>对于<code>stat</code>和<code>lstat</code>，无需对其所操作的文件本身拥有任何权限，但是对于指定路径的父目录要有执行（搜索）权限。</p>
<p>上述调用都会在缓冲区中返回一个由<code>statbuf</code>指向的<code>stat</code>结构，这个结构中包含了设备ID、i节点号、文件所有权、文件类型及权限、文件大小、已分配块、文件时间戳等信息。</p>
<h3 id="文件时间戳"><a class="markdownIt-Anchor" href="#文件时间戳"></a> 文件时间戳</h3>
<p><code>stat</code>结构的<code>st_atime</code>，<code>st_mtime</code>和<code>st_ctime</code>字段为文件的时间戳，分别记录了文件的上次访问时间、上次修改时间、文件状态（即i节点内的信息）上次发生变更的时间。对时间戳的记录形式为自1970年1月1日以来经历的秒数。</p>
<p>一些系统调用可以用来修改时间戳：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utime.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">const</span> struct utimbuf* buf)</span> <span class="comment">//可以改变存储于文件i节点中的文件上次访问时间戳和上次修改时间戳，pathname代表要修改时间的文件，buf可以为NULL，也可以为指向utimbuf结构的指针。如果buf为NULL，则将两个时间同时改为当前时间；如果为指向utimbuf结构的指针，则按照结构内相应字段的值去更新时间。</span></span></span><br><span class="line"><span class="function">struct utimbuf</span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> actime; <span class="comment">//访问时间</span></span><br><span class="line">    <span class="keyword">time_t</span> modtime; <span class="comment">//修改时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">const</span> struct timeval tv[<span class="number">2</span>])</span> <span class="comment">//允许微秒级精度指定时间值</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futimes</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct timeval tv[<span class="number">2</span>])</span> <span class="comment">//使用文件描述符fd来指定文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lutimes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">const</span> struct timeval tv[<span class="number">2</span>])</span> <span class="comment">//使用路径名指定文件，如果指向链接则不进行解引用</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimensat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">const</span> struct timespec times[<span class="number">2</span>], <span class="keyword">int</span> flags)</span> <span class="comment">//支持纳秒精度的时间戳，同时可以独立设置某一个时间戳，flags参数可以为0或者AT_SYMLINK_NOFOLLOW，表示对符号链接不做解引用</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futimens</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct timespec times[<span class="number">2</span>])</span></span></span><br><span class="line"><span class="function"><span class="comment">//上述函数返回0表示成功，-1表示失败</span></span></span><br></pre></td></tr></table></figure>
<h3 id="文件所有权"><a class="markdownIt-Anchor" href="#文件所有权"></a> 文件所有权</h3>
<p>每个文件都有一个与之管理的用户ID和组ID，据此可以判定文件所属的用户和组。当一个文件被创建时，其用户ID取进程的有效用户ID，而组ID则曲子进程的有效组ID或父目录的组ID。</p>
<p>下面的系统调用可以修改文件所有权：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span> <span class="comment">//改变pathname参数对应文件的所有权。owner和group代表新的用户ID和组ID，如果无需改变某一个则将其设置为-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span> <span class="comment">//与chown相同，但是pathname如果为符号连接，则改变链接文件本身的所有权</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span> <span class="comment">//修改fd对应文件的所有权</span></span></span><br><span class="line"><span class="function"><span class="comment">//上述函数返回0表示成功，-1表示失败</span></span></span><br></pre></td></tr></table></figure>
<h3 id="文件权限"><a class="markdownIt-Anchor" href="#文件权限"></a> 文件权限</h3>
<p>对于普通文件，<code>stat</code>结构中的<code>st_mod</code>字段低12位定义了文件权限，其中前3位为专用位，分别为set-user-ID位、set-group-ID位和sticky位，其余9位构成了定义权限的掩码，分别授予访问文件的各类用户（文件所有者、文件所属组、其它用户）的权限（可以读取文件内容、可以更改文件内容、可以执行文件）。</p>
<p>头文件<code>&lt;sys/stat.h&gt;</code>包含了用来表示文件权限位的常量，如下图所示：</p>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151530.png" alt="image-20210629110659209" style="zoom: 67%;" />
<blockquote>
<p>备注1—Linux进程的ID</p>
<ul>
<li>
<p>实际用户ID和实际组ID：登录shell从<code>/etc/passwd</code>文件中读取相应用户密码记录的第三字段和第四字段，置为其实际用户ID和实际组ID，当创建一个新的进程时（如shell执行一个程序），将从父进程继承这些ID</p>
</li>
<li>
<p>有效用户ID和有效组ID：当进程尝试执行各种操作（系统调用）时，将结合有效用户ID、有效组ID与辅助组ID一起确定授予进程的权限。通常，有效用户ID和有效组ID与相应的实际ID相同，但是也可以通过一些系统调用去修改有效用户ID和有效组ID</p>
</li>
</ul>
<p>备注2—文件权限专用位的含义</p>
<ul>
<li>
<p>set-user-ID位：如果这一位被设置，那么其它用户在执行该程序时，进程会拥有与程序文件属主相同的权限，即有效用户ID会被改变</p>
</li>
<li>
<p>set-group-ID位：与set-user-ID位的作用类似，但是修改的是有效组ID</p>
</li>
<li>
<p>sticky位：作用于目录时，起限制删除的作用。如果目录设置了该位，则表明仅当非特权进程拥有对目录的写权限，且为文件或者目录的属主时，才能对目录下的文件进行删除和重命名操作。</p>
</li>
</ul>
</blockquote>
<p>而对于目录来说，其权限方案与普通文件类似，但是权限的含义有不同。目录的读权限可以列出目录中的内容，写权限允许在目录内创建或者删除文件，可执行权限允许访问目录中的文件。</p>
<p>Linux内核会根据进程的有效用户ID、有效组ID和辅助组ID来进行权限检查。检查文件权限时，内核所遵循的规则如下：</p>
<ol>
<li>对于特权级进程，授予其所有访问权限。</li>
<li>若进程的有效用户ID与文件的用户ID（属主）相同，内核会根据文件的属主权限，授予进程相应的访问权限。比方说，若文件权限掩码中的属主读权限（owner-read permission）位被置位，则授予进程读权限。否则，则拒绝进程对文件的读取操作。</li>
<li>若进程的有效组ID或任一附属组ID与文件的组ID属组）相匹配，内核会根据文件的属组权限，授予进程对文件的相应访问权限。</li>
<li>若以上三点皆不满足，内核会根据文件的other（其他）权限，授予进程相应权限。</li>
</ol>
<p>而系统调用<code>access</code>便可以根据当前进程的真实用户ID和组ID来检查文件的访问权限：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">int</span> mode)</span> <span class="comment">//如果mode中的所有权限被允许则返回0，否则返回-1</span></span></span><br></pre></td></tr></table></figure>
<p>如果<code>pathname</code>为符号引用，则函数将对其做解引用。参数<code>mode</code>为位掩码，通过下面四个常量的或运算组合而成：</p>
<ul>
<li><code>F_OK</code>：该文件是否存在</li>
<li><code>R_OK</code>：是否对该文件有读权限</li>
<li><code>W_OK</code>：是否对该文件有写权限</li>
<li><code>X_OK</code>：是否对该文件有执行权限</li>
</ul>
<p>对于新建文件，内核会使用<code>open()</code>或者<code>creat()</code>中的<code>mode</code>参数所指定的权限；对于新建目录则会根据<code>mkdir()</code>的<code>mode</code>参数来设置权限。但是文件模式创建掩码<code>umask</code>会对这些设置进行修改，它是一种进程属性，当进程新建文件或者目录时，该属性用于指明应该屏蔽哪些权限位。</p>
<p>进程的<code>umask</code>通常继承自父shell，大多数shell的初始化文件会将<code>umask</code>默认设置为八进制值022，也就是对于同组或者其它用户总是屏蔽写权限。系统调用<code>umask()</code>可以将进程的<code>umask</code>改为指定的值，用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">mode_t</span> <span class="title">umask</span><span class="params">(<span class="keyword">mode_t</span> mask)</span></span></span><br></pre></td></tr></table></figure>
<p>对这一函数的调用总会成功，并返回进程的前一个<code>umask</code>。</p>
<p>而下面两个系统调用可以直接修改文件的权限：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">mode_t</span> mode)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">mode_t</span> mode)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回0代表成功，-1代表失败</span></span></span><br></pre></td></tr></table></figure>
<p>其中，<code>mode</code>参数可以是八进制的数字形式（如0777），也可以是各个权限位或运算的掩码。要想改变文件权限，进程要么具有特权级别，要么其有效用户ID与文件的用户ID相匹配。而<code>pathname</code>对应于要修改权限的文件，如果这一参数指向一个符号链接，那么调用<code>chmod</code>则会改变符号链接所指代文件的访问权限，而不是符号链接自身的访问权限（符号链接的所有权限为所有用户共享，且不得更改）。</p>
<p>为了满足对特定用户和组授权时进行更为精密的控制这一需求，Linux内核支持使用访问控制列表（ACL）对文件权限模型进行扩展。利用ACL，可以在任意数量的用户和组之中，为单个用户或组指定文件权限。</p>
<p>一个ACL由一系列ACL记录（ACE）组成，每一条记录都针对单个用户或者用户组定义了对文件的访问权限。例如：</p>
<table>
<thead>
<tr>
<th style="text-align:center">标记类型（表示该记录作用于一个用户、组还是其它类别的用户）</th>
<th style="text-align:center">标记限定符（用于标识特定的用户或组，即某个用户ID或者组ID）</th>
<th style="text-align:center">权限（为文件授予的权限信息）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ACL_USER_OBJ（文件属主的权限）</td>
<td style="text-align:center">-</td>
<td style="text-align:center">rwx</td>
</tr>
<tr>
<td style="text-align:center">ACL_USER（授予某个用户ID的权限）</td>
<td style="text-align:center">1007</td>
<td style="text-align:center">r–</td>
</tr>
<tr>
<td style="text-align:center">ACL_GROUP_OBJ（文件组的权限）</td>
<td style="text-align:center">-</td>
<td style="text-align:center">rwx</td>
</tr>
<tr>
<td style="text-align:center">ACL_GROUP（授予某个组ID的权限）</td>
<td style="text-align:center">103</td>
<td style="text-align:center">-w-</td>
</tr>
<tr>
<td style="text-align:center">ACL_MASK（记录可以授予的最高权限）</td>
<td style="text-align:center">-</td>
<td style="text-align:center">rw-</td>
</tr>
<tr>
<td style="text-align:center">ACL_OTHER（不匹配其它ACE的用户的权限）</td>
<td style="text-align:center">-</td>
<td style="text-align:center">r–</td>
</tr>
</tbody>
</table>
<h3 id="扩展属性"><a class="markdownIt-Anchor" href="#扩展属性"></a> 扩展属性</h3>
<p>文件的扩展属性（EA）指的是以名称-值对的形式，将任意元数据与文件的i节点关联起来的技术。EA的命名格式为<code>namespace.name</code>，其中<code>namespace</code>用于把EA从功能上划分为不同的大类，而<code>name</code>则用于在命名空间中唯一标识某个EA。</p>
<p>可供<code>namespace</code>使用的值包括：</p>
<ul>
<li><code>user</code>：在文件权限检查的制约下，由非特权级进程操控。它只能施加在文件或者目录上。要获取user EA的值，需要有读权限；而如果要修改user EA的值，则要求有写权限。</li>
<li><code>trusted</code>：可以由用户进程操控，但是进程必须具有特权。</li>
<li><code>system</code>：供内核使用，将系统对象与文件关联，目前仅支持访问控制列表。</li>
<li><code>security</code>：存储服务于操作系统安全模块的文件安全标签，也用于将可执行文件的能力关联起来。</li>
</ul>
<p>一个i节点可以拥有多个相关的EA，其所从属的命名空间可以相同也可以不同，在各个命名空间内的EA名均自成一体。在<code>user</code>和<code>trusted</code>两个命名空间中，EA名可以为任意字符串；而在<code>system</code>内，只有经内核明确认可的命名才可以使用。</p>
<p>在shell中，可以使用命令<code>setfattr</code>和<code>getfattr</code>来设置和查看文件的EA。同时，也有一系列的系统调用可以用来对文件的EA进行操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="comment">//创建和修改EA，返回0代表成功，-1代表失败</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setxattr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">void</span>* value, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lsetxattr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">void</span>* value, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetxattr</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">void</span>* value, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取EA的值，如果成功则返回EA值的大小，失败返回-1。其中value指向一个缓冲区，size代表缓冲区大小</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">getxattr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">void</span>* value, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">lgetxattr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">void</span>* value, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">fgetxattr</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">void</span>* value, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"><span class="comment">//删除EA，返回0代表成功，-1代表失败</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removexattr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lremovexattr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fremovexattr</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取与文件相关联的所有EA的名称，如果成功则返回list所包含的字节数，失败则返回-1。list指向一个缓冲区，size表示缓冲区大小</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">listxattr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">char</span>* <span class="built_in">list</span>, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">llistxattr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">char</span>* <span class="built_in">list</span>, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">flistxattr</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span>* <span class="built_in">list</span>, <span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure>
<h1 id="虚拟内存"><a class="markdownIt-Anchor" href="#虚拟内存"></a> 虚拟内存</h1>
<h2 id="内存映射"><a class="markdownIt-Anchor" href="#内存映射"></a> 内存映射</h2>
<h3 id="概述-4"><a class="markdownIt-Anchor" href="#概述-4"></a> 概述</h3>
<p>内存映射分为文件映射和匿名映射。文件映射将一个文件的一部分直接映射到调用进程的虚拟内存中。一旦一个文件被映射之后，就可以通过在相应的内存区域中操作字节来访问文件内容。映射的分页会在需要的时候从文件中（自动）加载。这种映射也被称为基于文件的映射或内存映射文件。而对于匿名映射来说，一个匿名映射没有对应的文件。相反，这种映射的分页会被初始化为 0。</p>
<p>一个进程映射中的内存可以与其他进程中的映射共享（即各个进程的页表条目指向RAM中的相同分页）。当两个或更多个进程共享相同分页时，每个进程都有可能会看到其他进程对分页内容做出的变更，这取决于映射是私有的还是共享的。对于私有映射来说，在映射内容上发生的变更对其它进程不可见；而对于共享映射来说，在映射内容上发生的变更对所有共享同一个映射的其他进程都可见。</p>
<p>这两种映射特性组成了四种不同的内存映射：</p>
<ul>
<li>私有文件映射：映射的内容被初始化为一个文件区域中的内容。这种映射的主要用途是使用一个文件的内容来初始化一块内存区域，例如根据二进制可执行文件的相应部分来初始化一个进程的文本和数据段。</li>
<li>私有匿名映射：每次调用<code>mmap()</code>创建一个私有匿名映射时都会产生一个新映射，该映射与同一（或不同）进程创建的其他匿名映射是不同的，它们不会共享物理分页。</li>
<li>共享文件映射：所有映射一个文件的同一区域的进程会共享同样的内存物理分页，这些分页的内容将被初始化为该文件区域。对映射内容的修改将直接在文件中进行。这种映射方式允许内存映射I/O，同时允许无关进程共享一块内容以便进行进程间通信。</li>
<li>共享匿名映射：每次调用<code>mmap()</code>创建一个共享匿名映射时都会产生一个新的、与任何其他映射不共享分页的新映射。映射的分页不会被写时复制，并且一个进程对映射内容所做出的变更会对其他进程可见。共享匿名映射允许以一种类似于System V 共享内存段的方式来进行IPC，但仅限于相关进程之间。</li>
</ul>
<h3 id="创建映射"><a class="markdownIt-Anchor" href="#创建映射"></a> 创建映射</h3>
<p><code>mmap()</code>系统调用在调用进程的虚拟地址空间中创建一个新的映射：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mmap</span><span class="params">(<span class="keyword">void</span>* addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>; <span class="comment">//成功则返回内存映射的起始地址，失败返回MAP_FAILED</span></span><br></pre></td></tr></table></figure>
<p><code>addr</code>参数指定了映射被放置的虚拟地址，可以指定为NULL使内核为映射选择一个合适的地址。<code>length</code>参数指定了映射的字节数，会被向上提升为分页大小的整数倍。<code>prot</code>为一个位掩码，取值可以为PROT_NONE，或者PROT_READ、PROT_WRITE和PROT_EXEC的组合。<code>flags</code>参数是一个控制映射操作各个方面选项的位掩码，可以为MAP_PRIVATE和MAP_SHARED之一，也可以同时用或操作包含其它值，如MAP_ANONYMOUS、MAP_FIXED、MAP_LOCKED等。<code>fd</code>和<code>offset</code>用于文件映射，<code>fd</code>参数为被映射文件的文件描述符，<code>offset</code>参数指定映射在文件中的起点，必须是系统分页大小的倍数。</p>
<h3 id="解除映射"><a class="markdownIt-Anchor" href="#解除映射"></a> 解除映射</h3>
<p><code>munmap()</code>系统调用执行的是与<code>mmap()</code>相反的操作，即从调用进程的虚拟地址空间中删除一个映射：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span>* addr, <span class="keyword">size_t</span> length)</span></span>; <span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>addr</code>参数是待解除映射的地址范围的起始地址，它必须与一个分页边界对齐。<code>length</code>是一个非负整数，它指定了待解除映射区域的大小。在解除映射时，可以解除整个映射，也可以解除一个映射中的一部分。</p>
<p>当一个进程终止或执行了一个<code>exec()</code>之后进程中所有的映射会自动被解除。</p>
<h3 id="文件映射"><a class="markdownIt-Anchor" href="#文件映射"></a> 文件映射</h3>
<p>要创建一个文件映射需要执行下面的步骤。</p>
<ol>
<li>获取文件的一个描述符，通常通过调用<code>open()</code>来完成。</li>
<li>将文件描述符作为 <code>fd</code>参数传入<code>mmap()</code>调用。</li>
</ol>
<p>执行上述步骤之后，<code>mmap()</code>会将打开的文件的内容映射到调用进程的地址空间中。一旦<code>mmap()</code>被调用之后，就能够关闭文件描述符，而不会对映射产生任何影响。</p>
<h3 id="匿名映射"><a class="markdownIt-Anchor" href="#匿名映射"></a> 匿名映射</h3>
<p>在Linux中，使用<code>mmap()</code>创建匿名映射有两种办法。一种是在<code>flags</code>指定MAP_ANONYMOUS 并将<code>fd</code>设置为-1，另一种是打开<code>/dev/zero</code>设备文件，并将得到的文件描述符传递给<code>mmap()</code>。此时，得到的映射中的字节会被初始化为0，offset 参数会被忽略。</p>
<h3 id="同步映射区域"><a class="markdownIt-Anchor" href="#同步映射区域"></a> 同步映射区域</h3>
<p>内核会自动将发生在MAP_SHARED映射内容上的变更写入到底层文件中，但在默认情况下，内核不保证这种同步操作会在何时发生。<code>msync()</code>系统调用让应用程序能够显式地控制何时完成共享映射与映射文件之间的同步：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(<span class="keyword">void</span>* addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> flags)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p><code>addr</code>和<code>length</code>参数指定了需同步的内存区域的起始地址和大小。在<code>addr</code>中指定的地址必须是分页对齐的，<code>length</code>会被向上舍入到系统分页大小的下一个整数倍。<code>flags</code>参数可以为MS_SYNC（会阻塞直到内存区域中所有被修改过的分页被写入到硬盘为止）、MS_ASYNC（内存区域仅与内核高速缓冲区同步）和MS_INVALIDATE（使映射数据的缓存副本失效）其中之一。</p>
<h3 id="重新映射"><a class="markdownIt-Anchor" href="#重新映射"></a> 重新映射</h3>
<p>Linux提供了<code>mremap()</code>系统调用，使得映射的位置和大小可以被改变：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mremap</span><span class="params">(<span class="keyword">void</span>* old_address, <span class="keyword">size_t</span> old_size, <span class="keyword">size_t</span> new_size, <span class="keyword">int</span> flags, ……)</span> <span class="comment">//成功则返回新映射地址的起始处，失败返回MAP_FAILED</span></span></span><br></pre></td></tr></table></figure>
<p><code>old_address</code>和<code>old_size</code>参数指定了需扩展或收缩的既有映射的位置和大小。在<code>old_address</code>中指定的地址必须是分页对齐的，并且通常是一个由之前的<code>mmap()</code>调用返回的值。映射预期的新大小会通过<code>new_size</code>参数指定。在<code>old_size</code>和<code>new_size</code>中指定的值都会被向上舍入到系统分页大小的下一个整数倍。</p>
<p>在执行重映射的过程中内核可能会为映射在进程的虚拟地址空间中重新指定一个位置，而是否允许这种行为则是由<code>flags</code>参数来控制的。它是一个位掩码，其值要么是0，要么为MREMAP_MAYMOVE或者MREMAP_MAYMOVE|MREMAP_FIXED（此时需要额外传入一个参数<code>void* new_address</code>，将映射迁移至这个指定地址）</p>
<h2 id="虚拟内存操作"><a class="markdownIt-Anchor" href="#虚拟内存操作"></a> 虚拟内存操作</h2>
<h3 id="改变内存保护"><a class="markdownIt-Anchor" href="#改变内存保护"></a> 改变内存保护</h3>
<p><code>mprotect()</code>系统调用修改起始位置为<code>addr</code>（必须是分页大小整数倍），长度为<code>length</code>（会被向上舍入到分页大小整数倍）字节的虚拟内存区域中对分页的保护：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span><span class="params">(<span class="keyword">void</span>* addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p><code>prot</code>参数是一个位掩码，它指定了这块内存区域上的新保护，其取值是PROT_NONE或PROT_READ、PROT_WRITE以及PROT_EXEC这三个值中的一个或多个取或操作。如果一个进程在访问一块内存区域时违背了内存保护，那么内核就会向该进程发送一个SIGSEGV信号。</p>
<h3 id="内存锁"><a class="markdownIt-Anchor" href="#内存锁"></a> 内存锁</h3>
<p>在一些应用程序中，将一个进程的虚拟内存的部分或全部锁进内存以确保它们总是位于物理内存中，可以提高程序的性能，并且保证敏感数据不会被交换到磁盘上。</p>
<p>特权进程能够锁住的内存数量是没有限制的（即RLIMIT_MEMLOCK会被忽略）；非特权进程能够锁住的内存数量上限由软限制RLIMIT_MEMLOCK定义。由于虚拟内存的管理单位是分页，因此内存加锁会应用于整个分页。在执行限制检查时，RLIMIT_MEMLOCK限制会被向下舍入到最近的系统分页大小的整数倍。</p>
<p>对内存区域加锁和解锁的操作如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mlock</span><span class="params">(<span class="keyword">void</span>* addr, <span class="keyword">size_t</span> length)</span></span>; <span class="comment">//addr为起始地址，不要求分页对齐，如果未对其则强制移动到下一个分页边界；由于加锁操作的单位是分页，因此被锁住的区域的结束位置为大于length加addr的下一个分页边界</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munlock</span><span class="params">(<span class="keyword">void</span>* addr, <span class="keyword">size_t</span> length)</span></span>; <span class="comment">//参数含义与mlock相同。不会立即删除分页，只有其它进程请求内存时才会从RAM中删除分页</span></span><br><span class="line"><span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>除了显式地使用<code>munlock()</code>之外，内存锁在下列情况下会被自动删除：</p>
<ul>
<li>进程终止</li>
<li>被锁住的分页通过<code>munmap</code>被解除映射</li>
<li>被锁住的分页通过<code>mmap</code>MAP_FIXED标记的映射覆盖时</li>
</ul>
<p>一个进程可以给它占据的所有内存加锁和解锁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mlockall</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munlockall</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line"><span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>其中<code>flags</code>参数可以为MCL_CURRENT、MCL_FUTURE以及二者的或。MCL_CURRENT将调用进程虚拟地址空间中当前所有映射的分页锁进内存，MCL_FUTURE将后续映射进调用进程的虚拟地址空间的所有分页锁进内存。</p>
<h3 id="确定内存驻留性"><a class="markdownIt-Anchor" href="#确定内存驻留性"></a> 确定内存驻留性</h3>
<p><code>mincore()</code>系统调用是内存加锁系统调用的补充，它报告在一个虚拟地址范围中哪些分页当前驻留在RAM 中，因此在访问这些分页时也不会导致分页故障：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mincore</span><span class="params">(<span class="keyword">void</span>* addr, <span class="keyword">size_t</span> length, <span class="keyword">unsigned</span> <span class="keyword">char</span>* vec)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>这一系统调用返回起始地址为<code>addr</code>，长度为<code>length</code>字节的虚拟地址范围中分页的内存驻留信息。<code>addr</code>中的地址必须是分页对齐的，并且由于返回的信息是有关整个分页的，因此<code>length</code>实际上会被向上舍入到系统分页大小的下一个整数倍。内存驻留的相关信息会通过<code>vec</code>返回。</p>
<h3 id="建议后续的内存使用模式"><a class="markdownIt-Anchor" href="#建议后续的内存使用模式"></a> 建议后续的内存使用模式</h3>
<p><code>madvise()</code>系统调用通过通知内核调用进程对起始地址为<code>addr</code>长度为<code>length</code>字节的范围之内分页的可能的使用情况，来提升应用程序的性能。内核可能会使用这种信息来提升在分页之下的文件映射上执行的I/O的效率。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">madvise</span><span class="params">(<span class="keyword">void</span>* addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> advice)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>参数<code>addr</code>的值要求分页对齐，<code>length</code>会被向上舍入到系统分页大小的下一个整数倍，<code>advice</code>可以为下面几个值其中之一：</p>
<ul>
<li>MADV_NORMAL：默认行为，分页以簇（一个系统分页大小整数倍）传输，这样会导致一些预先读和事后读</li>
<li>MADV_RANDOM：这个区域的分页会被随机访问，这样预先读不会带来任何好处</li>
<li>MADV_SEQUENTIAL：在此范围内的分页只会被访问一次，并且是顺序访问</li>
<li>MADV_WILLNEED：预先读取这个区域中的分页以备将来的访问之需</li>
<li>MADV_DONTNEED：调用进程不再要求这个区域中的分页驻留在内存中</li>
</ul>
<h1 id="定时器"><a class="markdownIt-Anchor" href="#定时器"></a> 定时器</h1>
<h2 id="间隔定时器"><a class="markdownIt-Anchor" href="#间隔定时器"></a> 间隔定时器</h2>
<p>系统调用<code>setitimer</code>会创建一个间隔式定时器，它会在未来的某个时间点到期，（可选）并于此后每隔一段时间到期一次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys&#x2F;time.h&gt;</span><br><span class="line">int setitimer(int which, const struct itimerval* new_value, struct itimerval* old_value) &#x2F;&#x2F;返回0代表成功，-1代表失败</span><br></pre></td></tr></table></figure>
<p><code>which</code>参数可以设置为下面3个值的其中一个：</p>
<ul>
<li>ITIMER_REAL：创建以真实时间倒计时的定时器，到期时产生SIGALARM信号</li>
<li>ITIMER_VIRTUAL：创建以进程虚拟时间（用户模式下的CPU时间）倒计时的定时器，到期产生SIGVTALRM信号</li>
<li>ITIMER_PROF：创建一个profiling定时器，以进程时间（用户态与内核态CPU时间总和）倒计时，到期产生SIGPROF信号</li>
</ul>
<p>对上述所有这些信号的默认处置均会终止进程。</p>
<p>参数<code>new_value</code>和<code>old_value</code>均为指向结构<code>itimerval</code>的指针，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct itimerval&#123;</span><br><span class="line">    struct timeval it_interval; </span><br><span class="line">    struct timeval it_value; </span><br><span class="line">&#125;</span><br><span class="line">struct timeval&#123;</span><br><span class="line">    time_t tv_sec; &#x2F;&#x2F;秒数</span><br><span class="line">    suseconds_t tv_usec; &#x2F;&#x2F;微秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个进程只能拥有上述三类计时器的各一个。当第二次调用<code>setitimer</code>时，修改已有定时器的属性要符合参数<code>which</code>中的类型。如果调用<code>setitimer()</code>时将<code>new_value.it_value</code>的两个字段均置为0，那么会屏蔽任何已有的定时器。</p>
<p>参数<code>new_value</code>的下属结构<code>it_value</code>指定了距离定时器到期的延迟时间。另一下属结构<code>it_interval</code>则说明该定时器是否为周期性定时器。如果<code>it_interval</code>的两个字段值均为0，那么该定时器就属于在<code>it_value</code>所指定的时间间隔后到期的一次性定时器。只要<code>it_interval</code>中的任一字段非0，那么在每次定时器到期之后，都会将定时器重置为在指定间隔后再次到期。</p>
<p>如果参数<code>old_value</code>不为NULL，则以其所指向的<code>interval</code>结构来返回定时器的前一个设置。如果<code>old_value.it_value</code>的两个字段值均为0，那么该定时器之前处于屏蔽状态；如果<code>old_value.it_interval</code>的两个字段值均为0，那么该定时器之前被设置为一次性定时器。如果不关心定时器的前一个设置，可以将<code>old_value</code>设置为NULL。</p>
<p>定时器会从初始值<code>it_value</code>开始倒计时至0为止。递减至0时，会有相应的信号发送给进程。随后，如果时间间隔值<code>it_interval</code>非0，则会再次将<code>it_value</code>加载至计时器，重新开始向0倒计时。</p>
<p>可以在任何时刻调用<code>getitimer()</code>，以了解定时器的当前状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys&#x2F;time.h&gt;</span><br><span class="line">int getitimer(int which, const struct itimerval* curr_value) &#x2F;&#x2F;返回0代表成功，-1代表失败</span><br></pre></td></tr></table></figure>
<p>一个更加简单的定时器接口是<code>alarm()</code>系统调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">unsigned int alarm(unsigned int seconds); </span><br></pre></td></tr></table></figure>
<p>其中，参数<code>seconds</code>表示定时器到期的秒数。到期时会向调用进程发送SIGALRM信号。调用<code>alarm</code>会覆盖对定时器的前一个设置，而调用<code>alarm(0)</code>可屏蔽现有定时器。它的返回值是定时器的前一个设置距离到期的剩余秒数，如果未设置定时器则返回0。</p>
<p>取决于当前负载和对进程的调度，系统可能会在定时器到期的瞬间（通常是几分之一秒）之后才去调度其所属进程。但是后续定时器的调度会严格遵守其设置的时间间隔。而且定时器的精度受制于软件时钟的频率，如果定时器值未能与软件时钟间隔的倍数严格匹配，那么定时器值则会向上取整。</p>
<h2 id="休眠"><a class="markdownIt-Anchor" href="#休眠"></a> 休眠</h2>
<p>有时需要将进程挂起一段时间，此时可以使用休眠函数来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">unsigned int sleep(unsigned int seconds)&#x2F;&#x2F;休眠正常结束则返回0，如果因信号而中断则返回剩余秒数</span><br><span class="line"></span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">int nanosleep(const struct timespec* request, struct timespec* remain) &#x2F;&#x2F;返回0代表休眠正常结束，-1代表因信号而中断或者错误。request参数用于设置休眠时间，remain函数为返回的时间</span><br><span class="line">struct timespec&#123;</span><br><span class="line">    time_t tv_sec;</span><br><span class="line">    long tv_nsec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="posix时钟"><a class="markdownIt-Anchor" href="#posix时钟"></a> POSIX时钟</h2>
<p>POSIX时钟所提供的时钟访问API可以支持纳秒级的时间精度，在Linux中调用此API的程序必须以<code>-lrt</code>选项进行编译，从而与<code>librt</code>函数库相链接。POSIX时钟API的三个主要系统调用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;time.h&gt;</span><br><span class="line">int clock_gettime(clockid_t clockid, struct timespec* tp) &#x2F;&#x2F;针对于clockid指定的时钟返回时间，返回0表示成功，-1表示失败</span><br><span class="line">int clock_getres(clockid_t clockid, struct timespec* res) &#x2F;&#x2F;针对于clockid指定的时钟返回时钟分辨率，返回0表示成功，-1表示失败</span><br><span class="line">int clock_settime(clockid_t clockid, const struct timespec* tp) &#x2F;&#x2F;利用参数tp所指向缓冲区中的时间来设置clockid指定的时钟，返回0表示成功，-1表示失败</span><br><span class="line">int clock_getcpuclockid(pid_t pid, clockid_t* clockid) &#x2F;&#x2F;获得进程pid的clockid，如果pid为0则返回调用进程的CPU时间时钟ID；clockid指向一个缓冲区。返回0代表成功，失败则返回一个对应于错误类型的正数</span><br><span class="line">int pthread_getcpuclockid(pthread_t thread, clockid_t* clockid) &#x2F;&#x2F;获取线程thread的clockid。返回0代表成功，失败则返回一个对应于错误类型的正数</span><br><span class="line">int clock_nanosleep(clockid_t clockid, int flags, const struct timespec* request, struct timespec* remain)</span><br></pre></td></tr></table></figure>
<p><code>clockid_t</code>数据类型用于表示时钟标识符，一共有四种类型：</p>
<ul>
<li>CLOCK_REALTIME：可设定的系统级实时时钟</li>
<li>CLOCK_MONOTONIC：不可设定的恒定态时钟</li>
<li>CLOCK_PROCESS_CPUTIME_ID：每进程CPU时间的时钟</li>
<li>CLOCK_THREAD_CPUTIME_ID：每线程CPU时间的时钟</li>
</ul>
<h2 id="posix间隔式定时器"><a class="markdownIt-Anchor" href="#posix间隔式定时器"></a> POSIX间隔式定时器</h2>
<p><code>setitimer()</code>设置的经典UNIX间隔式定时器存在一些制约，而POSIX定时器可以突破这些限制。在Linux中调用此API的程序必须以<code>-lrt</code>选项进行编译，从而与<code>librt</code>函数库相链接。POSIX定时器的生命周期分为三个阶段：创建、启动/停止、删除。</p>
<p>相关的API如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;signal.h&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">int timer_create(clockid_t clockid, struct sigevent* evp, timer_t* timerid) &#x2F;&#x2F;创建一个定时器，使用clockid指定的时钟来进行时间度量。evp决定定时器到期时对应用程序的通知方式，timerid为一个缓冲区。</span><br><span class="line">int timer_settime(timer_t timerid, int flags, const struct itimerspec* value, struct itimerspec* old_value) &#x2F;&#x2F;启动&#x2F;停止定时器，timerid由timer_create()调用返回。flags可以为0，代表相对时间；或者为TIMER_ABSTIME，代表绝对时间</span><br><span class="line">int timer_gettime(timer_t timerid, struct itimerspec* curr_value) &#x2F;&#x2F;返回由timerid指定POSIX定时器的间隔和剩余时间</span><br><span class="line">int timer_delete(timer_t timerid) &#x2F;&#x2F;删除一个定时器</span><br><span class="line">&#x2F;&#x2F;上述调用成功返回0，失败返回-1</span><br></pre></td></tr></table></figure>
<h2 id="文件描述符定时器"><a class="markdownIt-Anchor" href="#文件描述符定时器"></a> 文件描述符定时器</h2>
<p>Linux特有的timerfd API可以从文件描述符中读取其所创建定时器的到期通知。相关的系统调用包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys&#x2F;timerfd.h&gt;</span><br><span class="line">int timerfd_create(int clockid, int flags) &#x2F;&#x2F;创建一个新的定时器对象，并返回一个指代该对象的文件描述符。参数clockid 的值可以设置为CLOCK_REALTIME或CLOCK_MONOTONIC; flags参数可设为TFD_CLOEXEC或TFD_NONBLOCK</span><br><span class="line">int timerfd_settime(int fd, int flags, const struct itimerspec* value, struct itimerspec* old_value) &#x2F;&#x2F;启动&#x2F;停止定时器</span><br><span class="line">int timerfd_gettime(int fd, struct itimerspec* curr_value) &#x2F;&#x2F;返回fd标识定时器的间隔和剩余时间</span><br><span class="line">&#x2F;&#x2F;上述调用成功返回0，失败返回-1</span><br></pre></td></tr></table></figure>
<p>一旦以<code>timerfd_settime()</code>启动了定时器，就可以从相应文件描述符中调用<code>read()</code>来读取定时器的到期信息。出于这一目的，传给<code>read()</code>的缓冲区必须足以容纳一个无符号8字节整型（<code>uint64_t</code>）数。在上次使用<code>timerfd_settime()</code>修改设置以后，或是最后一次执行<code>read()</code>后，如果发生了一起到多起定时器到期事件，那么<code>read()</code>会立即返回，且返回的缓冲区中包含了已发生的到期次数。如果并无定时器到期，<code>read()</code>会一直阻塞直至产生下一个到期。</p>
<p>可以利用<code>select()</code>、<code>poll()</code>和<code>epoll()</code>对<code>timerfd</code>文件描述符进行监控。如果定时器到期，会将对应的文件描述符标记为可读。</p>
<h1 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h1>
<h2 id="基础内容"><a class="markdownIt-Anchor" href="#基础内容"></a> 基础内容</h2>
<h3 id="进程号"><a class="markdownIt-Anchor" href="#进程号"></a> 进程号</h3>
<p>每个进程都有一个进程号（PID），它是一个正数，用来唯一标识系统中的某个进程。对于各种系统调用而言，进程号有时候可以作为传入参数，有时候可以作为返回值。</p>
<p>系统调用<code>getpid</code>返回调用进程的进程号：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>getpid()</code>返回值的数据类型是<code>pid_t</code>，这一数据类型被专门用来存储进程号。创建一个新的进程时，内核会按顺序将下一个可用的进程号分配给新进程使用；而当进程号达到最大值的限制时，内核将重置进程号计数器至300（因为低数值的进程号通常被系统进程和守护进程长期占用，故之间跳过这一区域）。Linux的最大进程号由内核常量<code>PID_MAX</code>所定义。</p>
<p>每个进程都有一个创建自己的父进程，系统调用<code>getppid</code>可以检索父进程的进程号：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>所有进程的始祖是1号进程<code>init</code>，在Linux的命令行输入<code>pstree 1</code>即可看到系统中进程的家族树结构。</p>
<h3 id="进程的内存布局"><a class="markdownIt-Anchor" href="#进程的内存布局"></a> 进程的内存布局</h3>
<p>在Linux系统中，进程的内存被布局到虚拟内存中。每个进程所分配的虚拟内存由很多部分组成，每个部分称为“段”，如下图所示：</p>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151659.png" alt="image-20210625111723877" style="zoom: 67%;" />
<p>每个部分的含义如下：</p>
<ul>
<li>文本段：包含进程运行的程序机器语言指令。为了防止进程通过错误指针修改指令，这段内存被设置为只读；同时因为多个进程可以运行同一程序，故这一段内存可共享，这样便可将程序代码映射到多个进程的虚拟地址空间中。</li>
<li>初始化数据段：包含显式初始化的全局变量和静态变量。当程序加载到内存时，从可执行文件中读取这些变量的值。</li>
<li>未初始化数据段：包含未进行显式初始化的全局变量和静态变量，程序启动之前，这段内存的所有值被初始化为0。</li>
<li>栈：动态增长和收缩的段，由栈帧组成，系统会为每一个当前调用的函数分配一个栈帧。栈帧中存储了函数的局部变量、实参和返回值。</li>
<li>堆：可以在运行时为变量动态分配内存的一块区域。</li>
</ul>
<p>虚拟内存的规划之一是将每个程序使用的内存切割成小型的、固定大小的“页”（page）单元。相应地，将RAM 划分成一系列与虚拟内存页尺寸相同的页帧。任一时刻，每个程序仅有部分页需要驻留在物理内存页帧中。这些页构成了所谓驻留集（resident set）。程序未使用的页拷贝保存在交换区（swap area）内（磁盘空间中的保留区域，作为计算机RAM 的补充），仅在需要时才会载入物理内存。若进程欲访问的页面目前并未驻留在物理内存中，将会发生页面错误（page fault），内核即刻挂起进程的执行，同时从磁盘中将该页面载入内存。由于程序访问的空间和时间局部性特征，程序即便仅有部分地址空间存在于RAM 中，依然可能得以执行。</p>
<p>为支持这一组织方式，内核需要为每个进程维护一张页表（page table）。该页表描述了每页在进程虚拟地址空间（virtual address space）中的位置（可为进程所用的所有虚拟内存页面的集合）。页表中的每个条目要么指出一个虚拟页面在RAM中的所在位置，要么<br />
表明其当前驻留在磁盘上。</p>
<p>在进程虚拟地址空间中，并非所有的地址范围都需要页表条目。通常情况下，由于可能存在大段的虚拟地址空间并未投入使用，故而也无必要为其维护相应的页表条目。若进程试图访问的地址并无页表条目与之对应，那么进程将收到一个SIGSEGV信号。</p>
<p>使用虚拟内存的优点包括：</p>
<ul>
<li>进程与进程，进程和内核互相隔离</li>
<li>适当情况下，两个或者多个进程可以共享内存</li>
<li>通过对页表条目的标记，方便实现内存保护机制</li>
<li>无需关注程序在RAM的物理布局</li>
<li>一个进程所使用的虚拟内存大小可以超过RAM的容量</li>
<li>RAM中可以容纳多个进程所使用的内存，从而提高CPU的利用率</li>
</ul>
<h3 id="栈和栈帧"><a class="markdownIt-Anchor" href="#栈和栈帧"></a> 栈和栈帧</h3>
<p>函数的调用和返回使得栈的增长和收缩呈线性。栈驻留在内存地址的高端并向下增长，栈指针寄存器用于跟踪当前的栈顶。每次调用函数时，会在栈上新分配一帧，而当函数返回时再从栈上将此帧移除。由于函数能够嵌套调用，故栈中可能有多个栈帧。</p>
<p>每个用户栈的栈帧包括如下信息：</p>
<ul>
<li>函数实参和局部变量，函数返回时这些变量会自动被销毁</li>
<li>函数调用的信息，每当一个函数调用另一个函数时，会在被调用函数的栈帧中保存当前寄存器的副本，以便函数返回时能为函数调用者将寄存器恢复原状</li>
</ul>
<h3 id="命令行参数"><a class="markdownIt-Anchor" href="#命令行参数"></a> 命令行参数</h3>
<p>每个C语言程序都必须有一个<code>main()</code>的主函数，作为程序启动的起点。当执行程序时，命令行参数通过两个入参提供给<code>main</code>函数，第一个为<code>int argc</code>，表示命令行参数的个数；第二个参数<code>char *argv[]</code>，是一个指向命令行参数的指针数组，第一个字符串<code>argv[0]</code>指向该程序的名称，最后一个元素<code>argv[argc]</code>为NULL指针，其余参数指向其它的命令行参数。除了最后一个元素之外，其余指针指向的参数都以空字符结尾。</p>
<h3 id="环境列表"><a class="markdownIt-Anchor" href="#环境列表"></a> 环境列表</h3>
<p>每一个进程都有与之相关的环境列表，它是一个字符串数组，其中每个字符串都以名称=值（name=value）的格式定义。而列表中的名称也被称为环境变量。</p>
<p>新进程在创建时，会继承其父进程的环境副本。子进程只有在创建时才能获得其父进程的环境副本，故这一信息传递是单向、一次性的。子进程创建之后，父进程和子进程都可以修改各自的环境变量，而且这些变更对于对方而言都不再可见。</p>
<p>环境变量常见的用途之一是在shell中，通过在自身环境中放置变量值，shell便可以确保将这些值传递给所创建的进程。大多数shell使用export命令向环境中添加变量值。</p>
<blockquote>
<p>备注：shell和bash</p>
<p>Shell是系统的用户界面，相当于操作系统的“外壳”，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行，是在Linux内核与用户之间的解释器程序。</p>
<p>而bash指的是Linux系统中的/bin/bash解释器，它负责向内核翻译以及传达用户/程序指令。而如果在shell脚本的第一行写 #!/bin/bash ，意思就是用 /bin/bash解释器去执行这个脚本。</p>
</blockquote>
<p>通过Linux专有的/proc/PID/environ文件，可以检查任一进程的环境列表。而在C语言程序中，也可以使用全局变量<code>char** environ</code>来访问环境列表。<code>environ</code>和<code>argv</code>参数类似，指向一个以NULL结尾的指针数组，而其它每个指针又指向一个以空字节终止的字符串。</p>
<p>如果要在环境列表里面检索单个值，可以用下面的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span></span><br></pre></td></tr></table></figure>
<p>这一函数接收一个环境变量名称name作为参数，返回相应的value，并以字符串指针的形式传值；如果不存在指定名称的环境变量则返回NULL。</p>
<p>如果要修改环境，可以使用的函数包括：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">string</span>)</span> <span class="comment">//用于添加一个新变量或者修改一个已经存在的变量值，string参数指向一个name=value格式的字符串。如果成功则返回0，失败返回一个非0值</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* value, <span class="keyword">int</span> overwrite)</span> <span class="comment">//用于添加一个新变量或者修改一个已经存在的变量值，如果overwrite参数为0则不会改变已有的环境变量，如果不为0则总是改变环境。如果成功返回0，失败返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span> <span class="comment">//从环境中移除name标识的环境变量，如果成功返回0，失败返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clearenv</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">//清空整个环境，如果成功则返回0，失败返回一个非0值</span></span></span><br></pre></td></tr></table></figure>
<h3 id="非局部跳转"><a class="markdownIt-Anchor" href="#非局部跳转"></a> 非局部跳转</h3>
<p>库函数<code>setjmp()</code>和<code>longjmp()</code>可以执行非局部跳转，此处的非局部指的是跳转的目标位于当前执行函数之外的某个位置。这两个函数可以被用于下面的场景：在一个深层嵌套的函数调用中发生了错误，需要放弃当前任务，从多层函数调用中返回主函数。二者的用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>setjmp</code>函数用于设置跳转点，在后面调用<code>longjmp</code>时就会跳转到<code>setjmp</code>的位置。从编程的角度来看，调用<code>longjmp</code>之后，看起来和第二次调用<code>setjmp</code>返回时完全一样。通过查看<code>setjmp()</code>返回的整数值，可以区分<code>setjmp</code>调用是初始返回还是第二次“返回”。初始调用返回值为0，后续“伪”返回的返回值为<code>longjmp()</code>调用中<code>val</code>参数所指定的任意值。通过对<code>val</code>参数使用不同值，能够区分出程序中跳转至同一目标的不同起跳位置。</p>
<p><code>env</code>参数用于存储当前进程的信息，以及程序计数寄存器和栈指针寄存器的副本等信息，这些信息被用于恢复<code>setjmp</code>处的程序执行状态，从而使得后续的程序可以被接着执行。在调用<code>longjmp</code>时，需要传入与<code>setjmp</code>相同的<code>env</code>变量。由于两个函数的调用通常位于不同的函数，因此<code>env</code>参数常常被设置为全局变量。</p>
<p>在实际工程中，应该尽可能地避免使用<code>setjmp</code>和<code>longjmp</code>这两个函数，因为它们会使得程序地复杂程度变高，使程序难以阅读和维护。</p>
<h3 id="内存分配"><a class="markdownIt-Anchor" href="#内存分配"></a> 内存分配</h3>
<h4 id="在堆上分配内存"><a class="markdownIt-Anchor" href="#在堆上分配内存"></a> 在堆上分配内存</h4>
<p>进程可以通过增加堆的大小来分配内存，通常将堆的当前内存边界称为“Program Break”。在程序开始运行的时候，Program Break位于未初始化数据段的末尾之后。而在Program Break的位置抬升之后，程序可以访问新分配区域内的任何内存地址，而此时物理内存页尚未分配。内核会在进程首次试图访问这些虚拟内存地址时自动分配新的物理内存页。</p>
<p>下面两个系统调用可以操纵Program Break：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span>* end_data_segment)</span> <span class="comment">//返回0代表成功，-1代表失败</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> increment)</span> <span class="comment">//调用成功则返回上一个Program Break的位置，如果返回的指针指向-1则代表失败</span></span></span><br></pre></td></tr></table></figure>
<p><code>brk</code>会将Program Break设置为参数<code>end_data_segment</code>所指向的位置。由于虚拟内存以页为单位进行分配，因此<code>end_data_segment</code>实际会四舍五入到下一个内存页的边界处。而<code>sbrk</code>将Program Break在原有的位置上增加参数<code>increment</code>表示的大小，<code>intptr_t</code>属于整数数据类型，如果传入0则会返回当前Program Break的位置。</p>
<p>需要注意的是，如果试图将Program Break设置为一个低于其初始值的位置，则有可能会导致无法预知的行为。</p>
<p>C语言程序的<code>malloc</code>函数被用于在堆上分配<code>size</code>大小的内存，并返回指向新分配内存起始位置处的指针，其所分配的内存未初始化。这一函数的接口简单，更加方便在多线程程序中使用，且允许随意释放内存块。它的用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure>
<p>如果函数执行成功，则返回分配内存起始位置的指针，失败则返回NULL。由于函数的返回类型为<code>void*</code>，因此可以将其赋值给任意类型的指针。同时<code>malloc</code>返回的内存块已经基于8或者16字节进行内存对齐，从而适宜于高效访问不同类型的数据结构。</p>
<p><code>malloc()</code>的实现很简单。它首先会扫描之前由<code>free()</code>所释放的空闲内存块列表，以求找到尺寸大于或等于要求的一块空闲内存。（取决于具体实现，采用的扫描策略会有所不同）如果这一内存块的尺寸正好与要求相当，就把它直接返回给调用者。如果是一块较大的内存，那么将对其进行分割，在将一块大小相当的内存返回给调用者的同时，把较小的那块空闲内存块保留在空闲列表中。</p>
<p>如果在空闲内存列表中根本找不到足够大的空闲内存块，那么<code>malloc()</code>会调用<code>sbrk()</code>以分配更多的内存。为减少对<code>sbrk()</code>的调用次数，<code>malloc()</code>并未只是严格按所需字节数来分配内存，而是以更大幅度（以虚拟内存页大小的数倍）来增加Program Break，并将超出部分置于空闲内存列表。</p>
<p>堆内存的释放可以使用<code>free</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span></span><br></pre></td></tr></table></figure>
<p><code>free</code>函数将会释放<code>ptr</code>参数所指向的内存块，它应当是之前由<code>malloc</code>或者其它堆内存分配函数之一所返回的地址。</p>
<p>一般情况下，<code>free</code>函数并不降低Program Break的位置，而是将这块内存添加到空闲内存列表中，供后续的<code>malloc</code>函数循环使用。当<code>malloc()</code>分配内存块时，会额外分配几个字节来存放记录这块内存大小的整数值。该整数位于内存块的起始处，而实际返回给调用者的内存地址恰好位于这一长度记录字节之后。当将内存块置于空闲内存列表（双向链表）时，<code>free()</code>会使用内存块本身的空间来存放链表指针，将自身添加到列表中。</p>
<p>此外，还有一些在堆上分配内存的其他函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> numitems, <span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure>
<p>这一函数用于给一组相同对象分配内存，其中<code>numitems</code>指的是对象的个数，<code>size</code>指的是每个对象的大小，已经分配的内存会被初始化为0。而函数的返回值则是一个指向这块内存起始处的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">realloc</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure>
<p>这一函数用来调整一块内存的大小为<code>size</code>，而<code>ptr</code>为需要调整大小的内存块的指针，这块内存应该是之前<code>malloc</code>函数分配的。而<code>realloc</code>函数可能会重新分配一块内存，并将原来的数据复制到新的内存块，这将会占用大量的CPU资源。因此，应该尽量避免调用<code>realloc</code>。</p>
<h4 id="在栈上分配内存"><a class="markdownIt-Anchor" href="#在栈上分配内存"></a> 在栈上分配内存</h4>
<p>由于栈帧也存在扩展空间，因此也可以通过增加栈帧的大小从栈上动态分配内存。<code>alloca</code>函数可以实现这一功能，它的用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;alloca.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">alloca</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure>
<p><code>size</code>参数指定在堆栈上分配的字节数，函数的返回值为指向已分配内存块的指针。</p>
<p>由于编译器将<code>alloca</code>作为内联代码处理，且直接通过调整堆栈指针来实现，加上无需维护空闲内存块列表，因此使用<code>alloca</code>分配内存的速度快于<code>malloc</code>。在使用时需要注意的是，<code>alloca</code>函数分配的内存不需要也绝不能使用<code>free</code>函数释放，当栈帧移除之后（即函数返回）这块内存空间将会被自动释放掉。</p>
<h2 id="系统和进程信息"><a class="markdownIt-Anchor" href="#系统和进程信息"></a> 系统和进程信息</h2>
<h3 id="proc文件系统"><a class="markdownIt-Anchor" href="#proc文件系统"></a> <code>/proc</code>文件系统</h3>
<h4 id="概述-5"><a class="markdownIt-Anchor" href="#概述-5"></a> 概述</h4>
<p>为了提供更加简便的方法来访问内核信息，许多现代的UNIX实现提供了一个<code>/proc</code>虚拟文件系统。该文件系统驻留于<code>/proc</code>目录中，包含了各种用于展示内核信息的文件，并且允许进程通过常规文件I/O系统调用来方便地读取，有时还可以修改这些信息。这一文件系统称为虚拟，是因为其包含的文件和子目录并未存储于磁盘上，而是由内核在进程访问此类信息时动态创建而成。</p>
<h4 id="获取进程有关的信息"><a class="markdownIt-Anchor" href="#获取进程有关的信息"></a> 获取进程有关的信息</h4>
<p>对于系统中的每个进程，内核都提供了相应的目录，命名为<code>/proc/PID</code>，其中PID是进程的ID。在此目录中的各种文件和子目录包含了进程的相关信息，包括：</p>
<ul>
<li><code>status</code>：包含了关于进程的一系列信息，如进程ID、凭证、内存使用量、信号等</li>
<li><code>cmdline</code>：以<code>\0</code>分割的命令行参数</li>
<li><code>cwd</code>：指向当前工作目录的符号连接</li>
<li><code>environ</code>：NAME=value键值对环境列表，用<code>\0</code>分割</li>
<li><code>exe</code>：指向正在执行文件的符号连接</li>
<li><code>fd</code>：文件目录，包含了指向由进程打开文件的符号连接，例如<code>/proc/1968/1</code>是ID为1968的进程中指向标准输出的符号连接</li>
<li><code>maps</code>：内存映射</li>
<li><code>mem</code>：进程的虚拟内存</li>
<li><code>mounts</code>：进程的安装点</li>
<li><code>root</code>：指向根目录的符号连接</li>
<li><code>task</code>：包含了进程中的每个线程，每个线程都对应于一个子目录</li>
</ul>
<h4 id="系统信息"><a class="markdownIt-Anchor" href="#系统信息"></a> 系统信息</h4>
<p>在<code>/proc</code>目录下还包含了一些系统信息，例如：</p>
<ul>
<li><code>/proc/net</code>：有关网络和套接字的状态信息</li>
<li><code>/proc/sys/fs</code>：文件系统的相关设置</li>
<li><code>/proc/sys/kernel</code>：各种常规的内核设置</li>
<li><code>/proc/sys/net</code>：网络和套接字的设置</li>
<li><code>/proc/sys/vm</code>：内存管理设置</li>
<li><code>/proc/sysvipc</code>：有关System V IPC对象的信息</li>
</ul>
<h3 id="系统标识"><a class="markdownIt-Anchor" href="#系统标识"></a> 系统标识</h3>
<p>系统调用<code>uname()</code>返回了一系列关于主机系统的标识信息，用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uname</span><span class="params">(struct utsname* utsbuf)</span></span></span><br></pre></td></tr></table></figure>
<p>其中，<code>utsbuf</code>参数是一个指向<code>utsname</code>的指针，它的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utsname</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> sysname[_UTSNAME_LENGTH]; <span class="comment">//由内核自动设置</span></span><br><span class="line">	<span class="keyword">char</span> nodename[_UTSNAME_LENGTH]; <span class="comment">//由sethostname()系统调用设置</span></span><br><span class="line">	<span class="keyword">char</span> release[_UTSNAME_LENGTH]; <span class="comment">//由内核自动设置</span></span><br><span class="line">	<span class="keyword">char</span> version[_UTSNAME_LENGTH]; <span class="comment">//由内核自动设置</span></span><br><span class="line">	<span class="keyword">char</span> machine[_UTSNAME_LENGTH]; <span class="comment">//由内核自动设置</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _GNU_SOURCE</span></span><br><span class="line">	<span class="keyword">char</span> domainname[_UTSNAME_LENGTH]; <span class="comment">//由setdomainname()系统调用设置</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="进程的创建"><a class="markdownIt-Anchor" href="#进程的创建"></a> 进程的创建</h2>
<p>系统调用<code>fork()</code>可以创建一个新的进程，它的用法为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这一系统调用执行完成之后，将会存在两个进程，这两个进程都会从<code>fork()</code>的返回处继续往下执行。这两个进程执行相同的程序代码段，但是各自拥有不同的栈段、数据段和堆段拷贝。子进程的栈、数据和堆段开始时完全复制于父进程。而在此之后，每个进程可以修改各自的栈数据和堆段的变量，对另一进程完全没有影响。</p>
<p>程序代码可以通过<code>fork()</code>的返回值来区分父进程和子进程。在父进程中，这一系统调用返回的时子进程的进程ID，而在子进程中则返回0。如果无法创建子进程，则父进程返回-1。</p>
<p>执行<code>fork()</code>之后，子进程会获得父进程所有文件描述符的副本。因此这意味着父、子进程中对应的文件描述符会指向相同的打开文件句柄（其中含有当前文件偏移量、文件状态标志，这些属性在父子进程中共享）。因此如果子进程更新了文件偏移量，那么这也会影响到父进程中相应的描述符。</p>
<p>在执行<code>fork()</code>之后，父进程和子进程执行的特定顺序是不确定的，如果要保证某一特定执行顺序，则需要使用一些同步技术如信号等。</p>
<h2 id="进程的终止"><a class="markdownIt-Anchor" href="#进程的终止"></a> 进程的终止</h2>
<h3 id="api-2"><a class="markdownIt-Anchor" href="#api-2"></a> API</h3>
<p>进程的终止有两种方式，一种为异常终止，通过接收一个信号而引发；而另一个方式是使用<code>_exit()</code>系统调用正常终止：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure>
<p>其中，<code>status</code>参数定义了进程的终止状态，父进程可以调用<code>wait()</code>来获取该状态。虽然它为<code>int</code>数据类型，但是只有低8位可以被父进程使用。调用<code>_exit()</code>的程序总是会成功终止。</p>
<p>但是程序一般不会直接调用<code>_exit()</code>，而是调用库函数<code>exit()</code>，它会在调用<code>_exit()</code>之前执行各种动作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>exit()</code>系统调用执行的动作包括：</p>
<ul>
<li>调用退出处理程序，即通过<code>atexit()</code>和<code>on_exit()</code>注册的函数，其执行顺序和注册顺序相反。</li>
<li>刷新<code>stdio</code>流缓冲区</li>
<li>使用由<code>status</code>提供的值，执行<code>_exit()</code>系统调用。</li>
</ul>
<p>程序的另一种终止方法是从<code>main()</code>函数中返回，或者一直执行到函数的结尾处。执行<code>return n</code>其实等同于执行<code>exit(n)</code>。如果<code>main()</code>函数无返回值，则同样会执行<code>exit()</code>函数，但是返回值与C语言的标准以及编译器选项有关。</p>
<h3 id="进程终止的细节"><a class="markdownIt-Anchor" href="#进程终止的细节"></a> 进程终止的细节</h3>
<p>在进程终止时，无论是正常还是异常终止，都会发生如下动作：</p>
<ul>
<li>关闭所有打开的文件描述符、目录流、信息目录描述符和字符集转换描述符</li>
<li>释放进程持有的任何文件锁</li>
<li>分离任何已经连接的System V共享内存段，且对应于各段的<code>shm_nattch</code>计数器值将会减一</li>
<li>进程为每个System V信号量设置的<code>semadj</code>值将会被加到信号量值中</li>
<li>如果该进程是一个管理终端的管理进程，那么系统会向终端前台进程组中的每个进程发送SIGHUP信号，接着终端与会话脱离</li>
<li>关闭该进程打开的任何POSIX有名信号量</li>
<li>关闭该进程打开的任何POSIX消息队列</li>
<li>如果某进程组称为孤儿，且该组中存在任何已停止进程，则组中所有进程都会收到SIGHUP信号，随后收到SIGCONT信号</li>
<li>移除该进程通过<code>mlock()</code>或者<code>mlockall()</code>建立的任何内存锁</li>
<li>取消该进程调用<code>mmap()</code>所创建的任何内存映射</li>
</ul>
<h3 id="退出处理程序"><a class="markdownIt-Anchor" href="#退出处理程序"></a> 退出处理程序</h3>
<p>退出处理程序指的是由程序设计者提供的函数，在调用<code>exit()</code>使得程序正常终止时会自动执行（异常终止或者调用<code>_exit()</code>则不会调用）。注册退出处理程序的函数有两个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*func)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">on_exit</span><span class="params">(<span class="keyword">void</span> (*func)(<span class="keyword">int</span>, <span class="keyword">void</span>*), <span class="keyword">void</span>* args)</span></span>;</span><br><span class="line"><span class="comment">//返回0代表成功，非0值代表失败</span></span><br></pre></td></tr></table></figure>
<p>可以注册多个退出处理程序，甚至将同一个函数注册多次。当应用程序调用<code>exit()</code>时，这些函数的执行顺序与注册顺序相反。但是如果其中任意一个退出处理程序无法返回，那么就不再调用剩余的处理程序。</p>
<p>通过<code>fork()</code>创建的子进程会继承父进程注册的退出处理函数。而进程调用<code>exec()</code>时，会移除所有已注册的退出处理程序。</p>
<h2 id="进程监控"><a class="markdownIt-Anchor" href="#进程监控"></a> 进程监控</h2>
<h3 id="等待子进程"><a class="markdownIt-Anchor" href="#等待子进程"></a> 等待子进程</h3>
<p>对于需要创建子进程的程序来说，父进程可以监测子进程的终止时间和过程是很有必要的。系统调用<code>wait()</code>等待调用进程的任意一个子进程终止，同时在参数<code>status</code>所指向的缓冲区中返回该子进程的终止状态：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span>* status)</span> <span class="comment">//如果成功则返回终止的进程ID号，失败返回-1</span></span></span><br></pre></td></tr></table></figure>
<p>这一系统调用会执行如下的动作：</p>
<ol>
<li>如果调用这一函数时没有任何子进程终止，则这一调用将一直阻塞，直到某个子进程终止；如果调用时已有子进程终止，则立即返回。需要注意的是，如果在同一时刻有多个子进程同时退出，<code>wait</code>处理它们的顺序没有任何的规定。</li>
<li>如果<code>status</code>非空，则关于子进程如何终止的信息会通过它指向的整型变量返回</li>
<li>内核将为父进程下所有子进程的运行总量追加进程CPU时间以及资源使用数据</li>
<li>将终止子进程的ID作为<code>wait()</code>的结果返回</li>
</ol>
<p>出错时返回-1，可能的错误原因之一是调用进程并无已经终止的子进程，此时会将<code>errno</code>设置为ECHILD。</p>
<p>系统调用<code>wait()</code>存在很多限制，包括：</p>
<ul>
<li>如果父进程已经创建了多个子进程，无法等待某个特定子进程的完成，只能按顺序等待下一个子进程的终止</li>
<li>如果没有子进程退出，则一直保持阻塞状态。有时会希望执行非阻塞的等待</li>
<li>只能发现那些已经终止的子进程，无法处理子进程因为某个信号而停止或者已停止子进程收到信号恢复执行的情况</li>
</ul>
<p>为了解决这些限制，可以使用<code>waitpid()</code>系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span>* status, <span class="keyword">int</span> options)</span> <span class="comment">//如果成功则返回子进程ID，失败则返回0或-1</span></span></span><br></pre></td></tr></table></figure>
<p><code>waitpid</code>与<code>wait</code>的返回值和<code>status</code>参数的含义相同。参数<code>pid</code>表示需要等待的具体子进程，如果大于0则表示等待进程ID为<code>pid</code>的子进程，如果等于0则等待与父进程同一个进程组的所有子进程，如果小于-1则等待进程标识符等于<code>pid</code>绝对值的所有子进程，如果等于-1则等待任意子进程。参数<code>options</code>是一个位掩码，可以按位或操作包含这些标志：<code>WUNTRACED</code>（除返回终止子进程的信息外，还返回因信号而停止的子进程信息）、<code>WCONTINUED</code>（返回那些收到SIGCONT信号而恢复执行的已停止子进程的状态信息）、<code>WNOHANG</code>（如果参数<code>pid</code>指定的子进程并未发生状态改变，则立即返回而不会阻塞，此时返回0。</p>
<p>由<code>wait</code>或者<code>waitpid</code>返回的<code>status</code>值可以用来区分不同的子进程事件。有一组标准宏可以用来解析等待状态值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line">WIFEXITED(status) <span class="comment">//如果子进程正常结束则返回真，使用宏WEXITSTATUS(status)可以进一步查看子进程的退出状态</span></span><br><span class="line">WIFSIGNALED(status) <span class="comment">//如果通过信号杀死子进程则返回真，使用宏WTERMSIG(status)返回导致子进程终止的信号编号</span></span><br><span class="line">WIFSTOPPED(status) <span class="comment">// 如果子进程因为信号而停止则返回真，使用WSTOPSIG(status)可以返回导致子进程停止的信号编号</span></span><br><span class="line">WIFCONTINUED(status) <span class="comment">//如果子进程收到SIGCONT而恢复执行，则返回真</span></span><br></pre></td></tr></table></figure>
<p>在Linux系统中，也可以使用<code>waitid</code>系统调用来等待子进程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">waitid</span><span class="params">(<span class="keyword">idtype_t</span> idtype, <span class="keyword">id_t</span> id, <span class="keyword">siginfo_t</span>* infop, <span class="keyword">int</span> options)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回-1代表失败，如果返回0则代表成功，或者是在设置WNOHANG标志下无子进程可以等待</span></span></span><br></pre></td></tr></table></figure>
<p>其中，<code>idtype</code>和<code>id</code>指定了需要等待的子进程，<code>idtype</code>可以为下面三个参数中的其中一个：</p>
<ul>
<li><code>P_ALL</code>：等待任何子进程，同时忽略id值</li>
<li><code>P_PID</code>：等待进程ID为id进程的子进程</li>
<li><code>P_PGID</code>：等待进程组ID为id各进程的所有子进程</li>
</ul>
<p><code>waitid</code>可以更加精确地控制子进程，可以通过位运算指定如下的标识：</p>
<ul>
<li><code>WEXITED</code>：等待已终止的子进程，无论其是否正常返回</li>
<li><code>WSTOPPED</code>：等待已通过信号而停止的子进程</li>
<li><code>WCONTINUED</code>：等待经信号SIGCONT恢复的子进程</li>
<li><code>WNOHANG</code>：非阻塞调用</li>
<li><code>WNOWAIT</code>：返回子进程状态，但子进程依然处于可等待状态，稍后可再次等待并获取相同信息</li>
</ul>
<h3 id="孤儿进程与僵尸进程"><a class="markdownIt-Anchor" href="#孤儿进程与僵尸进程"></a> 孤儿进程与僵尸进程</h3>
<p>孤儿进程指的是父进程先于子进程结束的情况，此时孤儿进程将会由<code>init</code>进程（进程ID为1，即所有进程始祖）来接管。</p>
<p>僵尸进程指的是在父进程执行<code>wait</code>之前就已经终止的子进程。此时，内核会将子进程转为僵尸进程，这将会释放掉子进程使用的大部分资源供其它进程使用。子进程会在内核进程表中保留一条记录，其中包含子进程ID、终止状态、资源使用数据等信息。这确保了父进程总是可以执行<code>wait</code>方法。当父进程执行完<code>wait</code>之后，内核会自动删除僵尸进程；如果父进程结束之前没有调用<code>wait</code>，那么init进程将会接管这些僵尸进程并删除。</p>
<p>因此，如果父进程创建了某一子进程且一直未退出，但是未执行<code>wait</code>，在内核的进程表中将为这一子进程永久保留一条记录，如果存在大量的僵尸进程，它们将会填满内核进程表，从而阻碍新进程的创建。在设计长生命周期的父进程（如网络服务器和shell）时要特别注意这一点。</p>
<h3 id="sigchld信号"><a class="markdownIt-Anchor" href="#sigchld信号"></a> SIGCHLD信号</h3>
<p>前面介绍的系统调用将会导致阻塞或者轮询，从而造成了CPU资源浪费，并增加了应用程序复杂度。为了规避这些问题，可以采样针对SIGCHLD信号的处理程序。</p>
<p>无论一个子进程于何时终止，系统都会向其父进程发送SIGCHLD 信号。对该信号的默认处理是将其忽略，不过也可以使用信号处理程序来捕获它。还有另一种移植性稍差的处理方法，进程可选择将对SIGCHLD 信号的处置置为忽略（<code>SIG_IGN</code>），这时将立即丢弃终止子进程的状态（因此其父进程从此也无法获取到这些信息），子进程也不会成为僵尸进程。</p>
<h2 id="程序执行"><a class="markdownIt-Anchor" href="#程序执行"></a> 程序执行</h2>
<h3 id="执行新程序"><a class="markdownIt-Anchor" href="#执行新程序"></a> 执行新程序</h3>
<p>系统调用<code>execve()</code>可以将新程序加载到某一进程的内存空间。在这一操作过程中，将会丢弃掉旧的程序，而进程的栈、数据和堆段也将会被新程序的对应部分替换。在执行了各种C语言函数库的运行时启动代码和程序的初始化代码之后，将会从新程序的<code>main()</code>函数处开始执行。这一系统调用的使用方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">char</span>* <span class="keyword">const</span> argv[], <span class="keyword">char</span>* <span class="keyword">const</span> envp[])</span></span>; <span class="comment">//如果执行失败则返回-1，成功则永不返回</span></span><br></pre></td></tr></table></figure>
<p>其中，参数<code>pathname</code>包含了准备载入当前进程空间新程序的路径名，可以为绝对或者相对路径；参数<code>argv</code>用来给程序传递命令行参数；最后一个参数<code>envp</code>指定了新程序的的环境列表。在调用<code>execve</code>之后，因为同一进程依然存在，所以进程ID保持不变。</p>
<p>如果函数返回则表明发生错误，可以从<code>errno</code>来判断原因。可能返回的错误有：<code>EACCES</code>，代表<code>pathname</code>指向的不是常规文件、文件不可执行或者其中某一级目录不可搜索；<code>ENOENT</code>，代表<code>pathname</code>指向的文件不存在；<code>ENOEXEC</code>，代表系统无法识别文件格式；<code>ETXTBSY</code>，代表存在进程以写入方式打开<code>pathname</code>指代的文件；<code>E2BIG</code>，代表参数列表和环境列表所需空间总和超出了允许的最大值。</p>
<p>基于<code>execve</code>系统调用，还有下面的多种库函数可以选择，它们在为新程序指定程序名、参数列表以及环境变量的方式上有所不同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">const</span> <span class="keyword">char</span>* arg, …, <span class="keyword">char</span>* <span class="literal">NULL</span>, <span class="keyword">char</span>* <span class="keyword">const</span> envp[])</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">const</span> <span class="keyword">char</span>* arg, …, <span class="keyword">char</span>* <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">const</span> <span class="keyword">char</span>* arg, …, <span class="keyword">char</span>* <span class="literal">NULL</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>这些函数的差异体现在函数名称在<code>exec</code>之后的不同后缀：</p>
<ul>
<li>后缀p代表系统会在由环境变量PATH所指定的目录列表中寻找相应的执行文件，允许只提供程序的文件名而不提供完整路径。如果文件名称中包含&quot;/&quot;则将其视为相对或者绝对路径名，不再使用变量PATH来搜索文件。</li>
<li>后缀l代表以字符串列表的形式来指定参数，而不使用数组来描述<code>argv</code>列表。字符串列表需要以NULL指针来终止。</li>
<li>后缀e代表允许手动为新程序指定环境变量，而其余函数则使用调用者当前环境作为新程序的环境</li>
</ul>
<h3 id="文件描述符与信号"><a class="markdownIt-Anchor" href="#文件描述符与信号"></a> 文件描述符与信号</h3>
<p>默认情况下，由<code>exec()</code>的调用程序所打开的所有文件描述符在<code>exec()</code>的执行过程中会保持打开状态，且在新程序中依然有效。如果要改变这一设定，可以在打开文件描述符时设置<code>FD_CLOEXEC</code>标志。</p>
<p><code>exec()</code>在执行时会将现有进程的文本段丢弃。该文本段可能包含了由调用进程创建的信号处理器程序。既然处理器已经不知所踪，内核就会将对所有已设信号的处置重置为<code>SIG_DFL</code>，而对所有其他信号（即将处置置为<code>SIG_IGN</code>或<code>SIG_DFL</code>的信号）的处置则保持不变。</p>
<h3 id="执行shell命令"><a class="markdownIt-Anchor" href="#执行shell命令"></a> 执行shell命令</h3>
<p>程序可以通过调用<code>system()</code>函数来执行任意的shell命令，用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* command)</span></span></span><br></pre></td></tr></table></figure>
<p>函数会创建一个子进程来运行shell，并执行命令<code>command</code>。它的使用十分简便，但是效率很低，因为在调用过程中需要创建至少两个进程，一个用于运行shell，另一个或者多个用于shell所执行的命令。</p>
<h2 id="进程组和会话"><a class="markdownIt-Anchor" href="#进程组和会话"></a> 进程组和会话</h2>
<h3 id="概述-6"><a class="markdownIt-Anchor" href="#概述-6"></a> 概述</h3>
<p>进程组由一个或多个共享同一进程组标识符（PGID）的进程组成。进程组ID是一个数字，其类型与进程ID一样（<code>pid_t</code>）。一个进程组拥有一个进程组首进程，该进程是创建该组的进程，其进程ID为该进程组的ID，新进程会继承其父进程所属的进程组ID。进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。</p>
<p>会话是一组进程组的集合。进程的会话成员关系是由其会话标识符（SID）确定的，会话标识符与进程组ID一样，是一个类型为<code>pid_t</code>的数字。会话首进程是创建该新会话的进程，其进程ID会成为会话 ID。新进程会继承其父进程的会话ID。</p>
<p>一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立，而一个终端最多只会成为一个会话的控制终端。在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入其中一个信号生成终端字符之后，该信号会被发送到前台进程组中的所有成员。</p>
<p>进程组和会话是为支持shell作业控制而定义的抽象概念，用户通过shell能够交互式地在前台或后台运行命令。例如登录shell是会话首进程和终端的控制进程，也是其自身进程组的唯一成员；从shell发出的每个命令或者通过管道连接的一组命令都会导致一个或者多个进程的创建，并且shell会将其放入一个新的进程组中。当命令或者管道连接的一组命令以&amp;符号结束时会在后台进程组中运行这些命令，否则会在前台进程组中运行这些命令。而在窗口环境中，每个终端窗口都有一个独立的会话，而窗口的启动shell就是会话首进程和终端的控制进程。</p>
<h3 id="进程组"><a class="markdownIt-Anchor" href="#进程组"></a> 进程组</h3>
<p>每个进程都拥有一个以数字表示的进程组ID，表示该进程所属的进程组。新进程会继承其父进程的进程组ID，要查看进程组ID可以使用下面的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//返回进程的组ID号，返回值与调用进程的进程 ID 匹配的话就说明该调用进程是其进程组的首进程。</span></span><br></pre></td></tr></table></figure>
<p>修改进程组ID可以使用下面的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stdpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>; <span class="comment">//返回0为成功，-1为失败</span></span><br></pre></td></tr></table></figure>
<p>如果<code>pid</code>的值为0，则调用进程的进程组ID就会被改变；如果<code>pgid</code>设置为0，那么ID为<code>pid</code>进程的进程组ID就会被设置为<code>pid</code>的值。在其它情况下，如果<code>pid</code>和<code>pgid</code>参数指定同一个进程，那么就会创建一个新的进程组，且这个指定的进程为新组的首进程；如果两个参数指定不同的进程，那么会将一个进程从一个进程组移到另一个进程组。</p>
<p>控制终端保留了前台进程组的概念，前台进程组是唯一能够自由地读取和写入控制终端的进程组。在一个会话中，在同一时刻只有一个进程能成为前台进程，会话中的其他所有进程都是后台进程组。要获取或者修改一个终端的进程组可以使用下面的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">tcgetpgrp</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcsetpgrp</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="会话"><a class="markdownIt-Anchor" href="#会话"></a> 会话</h3>
<p>一个进程的会话成员关系是由其会话ID来定义的，会话ID是一个数字。新进程会继承其父进程的会话ID。要查看会话ID可以使用<code>getsid()</code>系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getsid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>; <span class="comment">//失败返回-1，成功返回指定进程的会话ID。如果pid为0则返回调用进程的会话ID</span></span><br></pre></td></tr></table></figure>
<p>要创建一个新会话可以使用<code>setsid()</code>系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//成功则返回一个新会话的ID号，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p>调用进程成为新会话的首进程和该会话中新进程组的首进程，调用进程的进程组ID和会话ID会被设置成该进程的进程ID。调用进程没有控制终端，且所有之前到控制终端的连接都会被断开。如果调用进程是一个进程组首进程，那么<code>setsid()</code>调用会报出EPERM错误，这一限制避免了破坏会话和进程组之间严格的两级层次。</p>
<p>一个会话中的所有进程可能会拥有一个控制终端。会话在被创建出来的时候是没有控制终端的，当会话首进程首次打开一个终端，且这个终端还没有成为某个会话的控制终端时，则会建立控制终端，除非在调用<code>open()</code>时指定O_NOCTTY标记。而一个终端至多只能成为一个会话的控制终端。当会话首进程打开了一个控制终端之后它同时也成为了该终端的控制进程。在发生终端断开之后，内核会向控制进程发送一个SIGHUP信号来通知这一事件的发生。如果一个进程拥有一个控制终端，那么打开特殊文件<code>/dev/tty</code>就能够获取该终端的文件描述符。</p>
<h2 id="进程优先级和调度"><a class="markdownIt-Anchor" href="#进程优先级和调度"></a> 进程优先级和调度</h2>
<h3 id="进程优先级"><a class="markdownIt-Anchor" href="#进程优先级"></a> 进程优先级</h3>
<p>Linux与大多数其他UNIX实现一样，调度进程使用CPU的默认模型是循环时间共享。这种模型中，每个进程轮流使用CPU一段时间，这段时间被称为时间片。循环时间共享方式满足了交互式多任务系统的公平性和响应度两个需求。在这种调度算法下，进程无法直接控制何时使用CPU以及使用CPU的时间。在默认情况下，每个进程轮流使用CPU 直至时间片被用光或自己自动放弃CPU。</p>
<p>进程特性nice值允许进程间接地影响内核的调度算法。每个进程都拥有一个nice值，其取值范围为−20（高优先级）～19（低优先级），默认值为0。需要注意的是，进程的调度不是严格按照nice值的层次进行的，nice值仅是一个权重因素，它导致内核调度器倾向于调度拥有高优先级的进程。给一个进程赋一个低优先级（即高nice值）并不会导致它完全无法用到CPU，但会导致它使用CPU的时间变少。nice值对进程调度的影响程度则依据Linux内核版本的不同而不同。</p>
<p>特权进程可以修改任意进程的优先级，而非特权进程只能修改自己的优先级，以及有效用户ID匹配进程的优先级。非特权进程可以降低或者在一定范围内提升nice值，而特权进程则可以任意修改nice值。</p>
<p>使用<code>fork()</code>创建子进程时，会继承nice值，并且该值会在<code>exec()</code>调用中得到保持。</p>
<p>要获取或者修改优先级可以使用下面的系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who)</span></span>; <span class="comment">//如果成功则返回nice值，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who, <span class="keyword">int</span> prio)</span></span>; <span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>which</code>参数用于确定<code>who</code>参数如何被解释，它的取值及其对<code>who</code>的解释如下：</p>
<ul>
<li>PRIO_PROCESS：操作进程ID为<code>who</code>的进程，如果<code>who</code>为0则使用调用者的进程ID。</li>
<li>PRIO_PGRP：操作进程组ID为<code>who</code>的进程组中的所有成员，如果<code>who</code>为0则使用调用者的进程组。</li>
<li>PRIO_USER：操作所有真实用户ID为<code>who</code>的进程，如果<code>who</code>为0则使用调用者的真实用户ID。</li>
</ul>
<h3 id="实时进程调度"><a class="markdownIt-Anchor" href="#实时进程调度"></a> 实时进程调度</h3>
<p>Linux提供了另外两种实时调度策略：SCHED_RR和SCHED_FIFO，使用这两种策略中任意一种策略进行调度的进程的优先级，都要高于标准循环时间分享策略（SCHED_OTHER）来调度的进程。Linux 提供了 99 个实时优先级，其数值从1（最低）～99（最高），并且这个取值范围同时适用于两个实时调度策略。每个策略中的优先级是等价的，这意味着如果两个进程拥有同样的优先级，则两个都符合运行条件，运行哪个则取决于被调度的顺序。</p>
<p>在SCHED_RR（循环）策略中，优先级相同的进程以循环时间分享的方式执行。进程每次使用CPU的时间为一个固定长度的时间片。一旦被调度执行之后，使用SCHED_RR策略的进程会保持对CPU的控制，直到时间片被消耗完、自愿放弃CPU、程序终止、或是被优先级更改的进程抢占。对于前两种放弃控制的情况，进程将会被放在调度队列的队尾；而如果是被抢占，则会被放在队列的头部。这种调度方式会严格按照优先级的顺序进行调度。</p>
<p>SCHED_FIFO（先入先出）策略与SCHED_RR策略类似，它们之间最主要的差别在于在SCHED_FIFO策略中不存在时间片。一旦一个SCHED_FIFO进程获得了CPU的控制权之后，它就会一直执行到程序自愿放弃CPU、程序终止、或是被优先级更高的进程抢占。</p>
<p>要查看调度策略的优先级范围，可以使用下面的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_get_priority_min</span><span class="params">(<span class="keyword">int</span> policy)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_get_priority_max</span><span class="params">(<span class="keyword">int</span> policy)</span></span>;</span><br><span class="line"><span class="comment">//policy代表要查询的调度策略，一般为SCHED_FIFO和SCHED_RR。成功则返回相应的优先级数值，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p>要修改一个进程的调度策略和优先级的方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_setscheduler</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> policy, <span class="keyword">const</span> struct sched_param* param)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sched_priority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>fork()</code>创建的子进程会继承父进程的调度策略和优先级，并且在<code>exec()</code>调用中会保持这些信息。</p>
<p><code>sched_setparam()</code>系统调用提供了<code>sched_setscheduler()</code>函数的一个功能子集。它修改一个进程的调度策略，但不会修改其优先级:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sched.t&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_setparam</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">const</span> struct sched_param* param)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>要查看调度策略和优先级可以使用如下的系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_getscheduler</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_getparam</span><span class="params">(<span class="keyword">pid_t</span> pid, struct sched_param* param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>实时进程如果要自愿释放CPU可以使用<code>sched_yield</code>系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_yield</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>要查看SCHED_RR调度时间片的大小可以使用下面的系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_rr_get_interval</span><span class="params">(<span class="keyword">pid_t</span> pid, struct timespec* tp)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cpu亲和力"><a class="markdownIt-Anchor" href="#cpu亲和力"></a> CPU亲和力</h3>
<p>当一个进程在一个多处理器系统上被重新调度时无需在上一次执行的CPU上运行。但是出于性能优化的考虑，有时需要为进程设置硬CPU亲和力，显式地将其限制在某一个或者一组CPU上运行。</p>
<p>要修改和获取进程的硬CPU亲和力可以使用下面的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_setaffinity</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">size_t</span> len, <span class="keyword">cpu_set_t</span>* <span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_getaffinity</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">size_t</span> len, <span class="keyword">cpu_set_t</span>* <span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p><code>cpu_set_t</code>数据类型是一个位掩码，但是通常将其看作是不透明结构，对它的操作使用下面几个宏来完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CPU_ZERO</span><span class="params">(<span class="keyword">cpu_set_t</span>* <span class="built_in">set</span>)</span></span>; <span class="comment">//将set初始化为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CPU_SET</span><span class="params">(<span class="keyword">int</span> cpu, <span class="keyword">cpu_set_t</span>* <span class="built_in">set</span>)</span></span>; <span class="comment">//将cpu添加到set中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CPU_CLR</span><span class="params">(<span class="keyword">int</span> cpu, <span class="keyword">cpu_set_t</span>* <span class="built_in">set</span>)</span></span>; <span class="comment">//将cpu从set中删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CPU_ISSET</span><span class="params">(<span class="keyword">int</span> cpu, <span class="keyword">cpu_set_t</span>* <span class="built_in">set</span>)</span></span>; <span class="comment">//检查cpu是否包含在set中</span></span><br></pre></td></tr></table></figure>
<h2 id="进程资源"><a class="markdownIt-Anchor" href="#进程资源"></a> 进程资源</h2>
<h3 id="进程资源使用"><a class="markdownIt-Anchor" href="#进程资源使用"></a> 进程资源使用</h3>
<p>要查看调用进程或其子进程用掉的各类系统资源的统计信息，可以使用<code>getrusage()</code>系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrusage</span><span class="params">(<span class="keyword">int</span> who, struct rusage* res_usage)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>who</code>参数指定需要查询资源使用信息的进程，它的取值为下列的其中一个：</p>
<ul>
<li>RUSAGE_SELF：返回调用进程的相关信息</li>
<li>RUSAGE_CHILDREN：返回调用进程的所有被终止和处于等待状态的子进程相关的信息。</li>
<li>RUSAGE_THREAD：返回调用线程相关的信息</li>
</ul>
<p><code>res_usage</code>参数是一个指向<code>rusage</code>结构的指针，其中存储了各类系统资源使用的详细信息。</p>
<h3 id="进程资源限制"><a class="markdownIt-Anchor" href="#进程资源限制"></a> 进程资源限制</h3>
<p>每个进程都用一组资源限值，它们可以用来限制进程能够消耗的各种系统资源。要查看或者修改资源限制，可以使用下面的系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit* rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit* rlim)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span>&#123;</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_cur;</span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>resource</code>参数标识出了需读取或修改的资源限制，<code>rlim</code>参数用来返回限制值或指定新的资源限制值。<code>resource</code>参数可以使用的值包括：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151827.png" alt="image-20210714161535465" /></p>
<h2 id="daemon进程"><a class="markdownIt-Anchor" href="#daemon进程"></a> DAEMON进程</h2>
<h3 id="概述-7"><a class="markdownIt-Anchor" href="#概述-7"></a> 概述</h3>
<p>daemon进程通常指的是在后台运行并且不拥有控制终端，且生命周期很长的进程。例如httpd、inetd等进程。</p>
<h3 id="创建流程"><a class="markdownIt-Anchor" href="#创建流程"></a> 创建流程</h3>
<p>要创建一个daemon进程，程序要完成下面的步骤：</p>
<ol>
<li>执行<code>fork()</code>，然后父进程退出，子进程继续执行。这保证子进程可以一直在后台执行，且子进程不会成为一个进程组的首进程</li>
<li>子进程调用<code>setsid()</code>，开启一个新会话，并释放它与控制终端的所有关联关系</li>
<li>如果daemon 后面可能会打开一个终端设备，那么必须要采取措施来确保这个设备不会成为控制终端。例如使用O_NOCTTY标记，或者在<code>setsid()</code>之后调用执行第二个<code>fork()</code>并退出父进程</li>
<li>清除进程的<code>umask</code>，确保创建文件和目录时的所需权限</li>
<li>修改进程当前工作目录为根目录</li>
<li>关闭daemon从其父进程继承而来的所有打开着的文件描述符</li>
<li>daemon 通常会打开/dev/null并使用<code>dup2()</code>（或类似的函数）使所有这些描述符指向这个设备</li>
</ol>
<p>一些函数库提供了<code>daemon()</code>函数，可以将调用者变为一个daemon进程。</p>
<h3 id="重新初始化"><a class="markdownIt-Anchor" href="#重新初始化"></a> 重新初始化</h3>
<p>有时需要修改daemon的操作参数，或者让其对文件进行处理，因此需要为daemon进程设置一些重新初始化的方法。一种方案是让daemon为SIGHUP信号建立一个处理器，并且在收到此信号时采取措施。由于daemon没有控制终端，因此内核永远不会向daemon发送SIGHUP信号。这样daemon就可以借助这个信号达到目的。</p>
<h3 id="syslog工具"><a class="markdownIt-Anchor" href="#syslog工具"></a> syslog工具</h3>
<p>由于daemon是在后台运行的，因此通常无法像其他程序那样将消息输出到关联终端上。这个问题的一种解决方式是将消息写入到一个特定于应用程序的日志文件中。syslog 工具提供了一个集中式日志工具，系统中的所有应用程序都可以使用这个工具来记录日志消息。</p>
<p>syslog API 由以下三个主要函数构成：</p>
<ul>
<li><code>openlog</code>：为后续的<code>syslog</code>调用建立默认设置</li>
<li><code>syslog</code>：记录一条日志消息</li>
<li><code>closelog</code>：完成日志消息记录之后，拆除与日志之间的连接</li>
</ul>
<p>它们的使用方法为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">openlog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ident, <span class="keyword">int</span> log_options, <span class="keyword">int</span> facility)</span></span>; <span class="comment">//ident时一个指向字符串的指针，syslog()输出的每一条消息都会包含这个字符串；log_options是一个位掩码，用于设置log的格式；facility参数表示记录日志消息的应用程序的类别，指定了后续的syslog()调用中所使用的默认facility值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span>; <span class="comment">//priority参数是facility和level值的或运算结果，用于设置记录日志消息的应用程序以及消息的严重程度，另一个参数是一个格式字符串以及相应的参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closelog</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//关闭日志</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setlogmask</span><span class="params">(<span class="keyword">int</span> mask_priority)</span></span>; <span class="comment">//设置一个可以过滤由syslog写入消息的掩码</span></span><br></pre></td></tr></table></figure>
<p><code>/etc/syslog.conf</code>配置文件控制syslogd daemon的操作，这个文件由规则和注释构成。通过这一文件，可以实现一些更加强大的规则，例如指定消息发送的位置、指定发送消息的类型等。</p>
<h1 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h1>
<h2 id="概述-8"><a class="markdownIt-Anchor" href="#概述-8"></a> 概述</h2>
<p>线程是允许应用程序并发执行多个人物的一种机制，一个进程可以包含多个线程。同一程序中的所有线程会独立执行相同区域，且共享同一份全局内存区域。因此，线程之间可以方便、快速地共享信息，同时创建线程的速度也比创建进程要快得多。</p>
<p>线程之间共享的属性包括：全局内存、进程ID和父进程ID、进程组ID和会话ID、控制终端、进程凭证、打开的文件描述符、记录锁、信号处置、文件系统的相关信息、间隔定时器和POSIX定时器、System V信号量撤销值、资源限制、CPU时间消耗、资源消耗、nice值</p>
<p>各线程独有的属性包括：线程ID、信号掩码、线程特有数据、备选信号栈、errno变量、浮点型环境、实时调度策略和优先级、CPU亲和力、Linux特有的Capability、栈，本地变量和函数的调用链接信息。</p>
<h2 id="创建与终止"><a class="markdownIt-Anchor" href="#创建与终止"></a> 创建与终止</h2>
<p>启动程序时，产生的进程只有单条线程，被称为初始或者主线程。函数<code>pthread_create()</code>负责创建一条新的线程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span>* thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span>* attr, <span class="keyword">void</span>*(*start)(<span class="keyword">void</span> *), <span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"><span class="comment">//执行成功返回0，识别返回一个正数代表错误码</span></span></span><br></pre></td></tr></table></figure>
<p>新线程通过调用带有参数<code>arg</code>的函数<code>start</code>，即<code>start(arg)</code>来开始执行。而调用<code>pthread_create</code>的线程则会接着继续执行该调用之后的程序语句。参数<code>thread</code>指向一个<code>pthread_t</code>类型的缓冲区，在<code>pthread_create()</code>返回之前，会在此保持一个该线程的唯一标识，后续的<code>Pthreads</code>函数将会使用该标识来引用此线程。参数<code>attr</code>是一个指向<code>pthread_attr_t</code>对象的指针，该对象指定了新线程的各种属性，如果将其设置为NULL，则创建新线程时将会使用各种默认属性。</p>
<p>如果要终止线程，有如下几种方法：</p>
<ul>
<li>线程start函数执行return语句并返回指定值</li>
<li>线程调用<code>pthread_exit()</code></li>
<li>调用<code>pthread_cancel()</code>取消线程</li>
<li>任意线程调用了<code>exit()</code>，或者主线程执行了return语句，此时会导致进程中的所有线程立即终止。</li>
</ul>
<p><code>pthread_exit()</code>函数将终止调用线程，且其返回值可以由另一个线程通过调用<code>pthread_join()</code>来获取，使用方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span>* retval)</span></span></span><br></pre></td></tr></table></figure>
<p>执行这一函数相当于在线程的<code>start</code>函数中执行return，但是这一函数可以在线程<code>start</code>函数所调用的任意函数中被调用。参数<code>retval</code>指定了线程的返回值，它所指向的内容不应被分配到线程栈中，因为线程终止之后无法确定线程栈中的内容是否有效。</p>
<h2 id="线程的连接与分离"><a class="markdownIt-Anchor" href="#线程的连接与分离"></a> 线程的连接与分离</h2>
<p>默认情况下，线程是可连接的，也就是说当其退出时，其它线程可以获取其返回状态。函数<code>pthread_join()</code>等待由<code>thread</code>标识的线程终止，如果线程已经终止则立刻返回，用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span>** retval)</span> <span class="comment">//返回0代表成功，失败则返回代表失败类型的正数</span></span></span><br></pre></td></tr></table></figure>
<p>如果<code>retval</code>是非空指针，将会保存线程终止时返回值的拷贝，即线程调用<code>return</code>或者<code>pthread_exit()</code>时传入的值。</p>
<p>如果线程没有被分离，则必须使用<code>pthread_join</code>来进行连接，否则在线程终止时将会产生一个僵尸线程。</p>
<p>需要注意的是，一个进程的任意线程都可以调用<code>pthread_join</code>与该进程的任何其它线程连接起来，即线程之间的关系对等；这与进程间的层次关系不同，进程只能由父进程对子进程调用<code>wait</code>。但是可以连接不代表任意线程的连接能够成功，可以限制只能连接特定的线程ID，且线程连接也不能以非阻塞方式进行。</p>
<p>有时，我们并不关心线程的返回状态，只希望系统在线程终止时可以自动清理并移除，此时可以使用<code>pthread_detach()</code>系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>; <span class="comment">//返回0代表成功，失败则返回代表失败类型的正数</span></span><br></pre></td></tr></table></figure>
<p>这一系统调用传入<code>thread</code>指定要分离的线程标识符，调用成功之后线程便会处于分离状态，在此之后不能再使用<code>pthread_join()</code>来获取其状态，也无法使其重返可连接的状态。</p>
<h2 id="线程同步"><a class="markdownIt-Anchor" href="#线程同步"></a> 线程同步</h2>
<h3 id="互斥量"><a class="markdownIt-Anchor" href="#互斥量"></a> 互斥量</h3>
<p>互斥量用于确保同时仅有一个线程可以访问某一项共享资源，它可以保证访问操作的原子性。互斥量只有两种状态：已锁定和未锁定。任何时候，至多只有一个线程可以锁定该互斥量；而一旦线程锁定互斥量，则成为该互斥量的所有者，只有该线程才可以给互斥量解锁。</p>
<p>一般情况下，对每一个共享资源会使用不同的互斥量，而每一个线程在访问同一资源时将采用如下步骤：针对共享资源锁定互斥量、访问共享资源、对互斥量解锁。</p>
<p>创建一个互斥量的方法分为静态和动态两种。静态分配一个互斥量的方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mtx = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure>
<p>在静态初始化一个互斥量之后，互斥量处于未锁定状态。</p>
<p>而动态分配与销毁一个互斥量的方法为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span>* attr)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//返回0代表成功，失败则返回代表失败类型的正数</span></span></span><br></pre></td></tr></table></figure>
<p>在<code>pthread_mutex_init</code>函数中，参数<code>mutex</code>指定函数执行初始化操作的目标互斥量，参数<code>attr</code>是指向<code>pthread_mutexattr_t</code>类型对象的指针，该对象在函数调用之前已经被初始化处理，用于定义互斥量的属性。如果这一参数被设为NULL，那么互斥量的各种属性将会取默认值。而当动态分配的互斥量<code>mutex</code>不需要再被使用之后，便可以使用<code>pthread_mutex_destroy</code>函数将其销毁。</p>
<p>使用下面两个函数可以锁定或者解锁某个互斥量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"><span class="comment">//返回0代表成功，失败则返回代表失败类型的正数</span></span><br></pre></td></tr></table></figure>
<p>在调用<code>pthread_mutex_lock</code>时，需要指定互斥量，如果互斥量当前处于未锁定状态，则会锁定互斥量并立即返回；如果其它线程已锁定了这个互斥量，那么这一调用将会一直堵塞，直到该互斥量被解锁，而此时将会锁定互斥量并返回。如果一个线程在调用<code>pthread_mutex_lock</code>时，已经将目标的互斥量锁定，则线程会陷入死锁状态。</p>
<p>函数<code>pthread_mutex_unlock</code>将会解锁之前已经被锁定的互斥量。如果对处于未锁定状态的互斥量进行解锁，或者是解锁由其它线程锁定的互斥量都会返回错误。</p>
<p>有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。要避免此类死锁问题，最简单的方法是定义互斥量的层级关系。当多个线程对一组互斥量操作时，总是应该以相同顺序对该组互斥量进行锁定。</p>
<p><code>pthread_mutexattr_t</code>类型的变量可为互斥量设置不同的属性。使用<code>pthread_mutexattr_init(pthread_mutexattr_t* attr)</code>函数可以初始化一个<code>pthread_mutexattr_t</code>类型的变量；<code>pthread_mutexattr_settype(pthread_mutexattr_t* attr, int flags)</code>函数可以添加属性；当<code>pthread_mutexattr_t</code>类型的变量不需要再使用时，可以使用函数<code>pthread_mutexattr_destroy(pthread_mutexattr_t&amp; attr)</code>将其释放掉。</p>
<h3 id="条件变量"><a class="markdownIt-Anchor" href="#条件变量"></a> 条件变量</h3>
<p>条件变量允许一个线程就某个共享变量（或其他共享资源）的状态变化通知其他线程，并让其他线程等待（堵塞于）这一通知。条件变量总是结合互斥量使用。条件变量就共享变量的状态改变发出通知，而互斥量则提供对该共享变量访问的互斥（mutual exclusion）。</p>
<p>同互斥量一样，条件变量的分配有静态和动态之分。静态创建的方法为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure>
<p>动态创建与销毁环境变量的函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span>* cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span>* attr)</span></span>; <span class="comment">//参数cond代表要初始化的条件变量，attr参数用来设置条件变量的属性，如果设置为NULL则代表使用默认属性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span>* cond)</span> <span class="comment">//当cond不再需要时可以使用这一系统调用将其销毁</span></span></span><br></pre></td></tr></table></figure>
<p>条件变量的主要操作是发送信号和等待。发送信号操作即通知一个或多个处于等待状态的线程，某个共享变量的状态已经改变。等待操作是指在收到一个通知前一直处于阻塞状态。相关的函数包括：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span>* cond)</span></span>; <span class="comment">//只保证唤醒至少一条遭到阻塞的线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span>* cond)</span></span>; <span class="comment">//唤醒所有遭到阻塞的线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span>* cond, <span class="keyword">pthread_mutex_t</span>* mutex)</span></span>; <span class="comment">//阻塞一个线程，直至收到条件变量cond的通知</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span>* cond, <span class="keyword">pthread_mutex_t</span>* mutex, <span class="keyword">const</span> struct timespec* abstime)</span></span>; <span class="comment">//与pthread_cond_wait类似，但是有一个等待时间上限，超过上限则返回ETIMEOUT错误</span></span><br><span class="line"><span class="comment">//返回0代表成功，失败则返回代表失败类型的正数</span></span><br></pre></td></tr></table></figure>
<p>每个条件变量都有与之相关的判断条件，涉及一个或者多个共享变量。由于代码从<code>pthread_cond_wait</code>返回时，并不能确定判断条件的状态，因此应该重新检查判断条件，在条件不满足的情况下继续等待。所以必须使用while循环而不是if语句来控制对<code>pthread_cond_wait()</code>的调用。</p>
<h2 id="线程安全"><a class="markdownIt-Anchor" href="#线程安全"></a> 线程安全</h2>
<p>若函数可同时供多个线程安全调用，则称之为线程安全函数；反之，如果函数不是线程安全的，则不能并发调用。实现线程安全有多种方式，一是将函数与互斥量关联使用，二是将共享变量与互斥量关联起来。因此，在多线程的程序中如果要用到一些系统调用或者库函数，需要确定它们的线程安全性。</p>
<p>实现函数线程安全最为有效的方式就是使其可重入，应以这种方式来实现所有新的函数库。而对于已有的函数而言，使用线程特有数据技术，可以无需修改函数接口而实现已有函数的线程安全。</p>
<p>要使用线程特有数据的一般步骤如下：</p>
<ul>
<li>函数创建一个键（key），用来将不同函数使用的线程特有数据项区分开来。可以使用调用函数<code>pthread_key_create()</code>函数来创建，这一调用也允许调用者自定义一个析构函数，用于释放为该键分配的存储块</li>
<li>函数为每个调用者线程创建线程特有的数据块</li>
<li>函数使用<code>pthread_setspecific()</code>和<code>pthread_getspecific()</code>来存储或者提取数据</li>
</ul>
<p>要创建一个新键可以使用<code>pthread_key_create()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_create</span><span class="params">(<span class="keyword">pthread_key_t</span>* key, <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span> *))</span></span>; <span class="comment">//成功返回0，失败则返回代表失败类型的正数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dest</span><span class="params">(<span class="keyword">void</span> *value)</span> <span class="comment">//destructor的函数格式定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//release storage pointed by value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要线程终止时与<code>key</code>的关联值不为<code>NULL</code>，Pthreads API 会自动执行解构函数，并将与<code>key</code>的关联值作为参数传入解构函数。传入的值通常是与该键关联，且指向线程特有数据块的指针。如果无需解构，那么可将<code>destructor</code>设置为<code>NULL</code>。</p>
<p>而存储与取出数据的函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key, <span class="keyword">const</span> <span class="keyword">void</span>* value)</span></span>; <span class="comment">//将value对应的数据存储一个副本，并将其与key相关联。成功返回0，失败则返回代表失败类型的正数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>; <span class="comment">//返回一个指向数据副本的指针，如果key没有对应的数据则返回NULL</span></span><br></pre></td></tr></table></figure>
<p>一种更简单的方法是使用线程局部存储。如果要创建线程局部变量，只需要简单地在全局或者静态变量的声明中包含<code>__thread</code>说明符即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __thread buf[<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<p>带有这一说明符的变量，每个线程都拥有一份对变量的拷贝。线程局部存储中的变量将会一直存在直到线程终止。</p>
<h2 id="线程取消"><a class="markdownIt-Anchor" href="#线程取消"></a> 线程取消</h2>
<p>有时候，需要向线程发送请求让它立即退出，例如一个图形用户界面的应用程序的取消按钮就对应于终止后台某一线程正在执行的任务。在这种情况下，主线程（即控制图形用户界面）需要请求后台线程退出。</p>
<p>函数<code>pthread_cancel()</code>向一个指定线程发送取消请求：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>; <span class="comment">//成功返回0，失败则返回代表失败类型的正数</span></span><br></pre></td></tr></table></figure>
<p>发送取消请求之后，函数立即返回，不会等待目标线程的退出。目标线程对这一指令的响应过程可以使用下面两个函数进行控制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcancelstate</span><span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span>* oldstate)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span>* oldtype)</span></span></span><br><span class="line"><span class="function"><span class="comment">//成功返回0，失败则返回代表失败类型的正数</span></span></span><br></pre></td></tr></table></figure>
<p>其中，<code>state</code>参数可以设置为<code>PTHREAD_CANCEL_DISABLE</code>或者<code>PTHREAD_CANCEL_ENABLE</code>，分别对应于线程不可取消和线程可以取消。<code>oldstate</code>用于保存前一个状态。</p>
<p>参数<code>type</code>可以设置为<code>PTHREAD_CANCEL_ASYNCHRONOUS</code>，代表可能会在任何时刻取消线程，因此一般原则是可异步取消的线程不应该分配任何资源，也不能获取互斥量或锁；或者<code>PTHREAD_CANCEL_DEFERED</code>，代表取消请求保持挂起状态直到到达取消点（有一系列的取消点函数，可以查阅相关资料），这也是新建线程的默认类型。参数<code>oldtype</code>保存之前的状态。</p>
<p>如果线程执行的是一个不包含取消点的循环，则永远不会响应取消请求。如果要手动加入取消点，则可以使用下面的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_testcancel</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果一个线程已有处于挂起状态的取消请求，那么只要调用该函数，则线程会立即终止。</p>
<p>在线程执行到取消点时，如果仅仅是直接退出，则很可能会导致一些共享变量或者Pthreads对象处于不一致的状态，导致进程中的其它线程产生错误结果、死锁等。因此，线程可以设置清理函数，当线程被取消时会自动执行这些函数，用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_push</span><span class="params">(<span class="keyword">void</span> (*routine)(<span class="keyword">void</span>*), <span class="keyword">void</span>* arg)</span></span>; <span class="comment">//向清理函数栈添加清理函数，arg值会传入routine中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="keyword">int</span> execute)</span></span>; <span class="comment">//移除清理函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">routine</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//执行清理过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程实现细节"><a class="markdownIt-Anchor" href="#线程实现细节"></a> 线程实现细节</h2>
<h3 id="线程id"><a class="markdownIt-Anchor" href="#线程id"></a> 线程ID</h3>
<p>进程内部的每一个线程都有一个唯一的线程ID作为标识。线程ID会返回给<code>pthread_create()</code>的调用者，一个线程可以使用<code>pthread_self()</code>函数来获取自己的线程ID：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>而<code>pthread_equal()</code>可以检查两个线程的ID是否相同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> t1, <span class="keyword">pthread_t</span> t2)</span></span>; <span class="comment">//如果相等返回非0，不相等返回0</span></span><br></pre></td></tr></table></figure>
<h3 id="线程栈"><a class="markdownIt-Anchor" href="#线程栈"></a> 线程栈</h3>
<p>创建线程时，每个线程都有一个属于自己的线程栈，且大小固定。主线程的线程栈要大一些，除此之外的所有线程栈大小都相等。使用函数<code>pthread_attr_setstacksize()</code>可以设置线程栈的大小。</p>
<h3 id="线程和信号"><a class="markdownIt-Anchor" href="#线程和信号"></a> 线程和信号</h3>
<p>在UNIX信号模型中，一些方面属于进程层面（即进程中的所有线程共享），另一些方面属于线程层面。一些关键规则包括：</p>
<ul>
<li>信号动作属于进程层面。如果某进程的任一线程收到任何未经（特殊）处理的信号，且其缺省动作为stop 或terminate，那么将停止或者终止该进程的所有线程。</li>
<li>对信号的处置属于进程层面，进程中的所有线程共享对每个信号的处置设置</li>
<li>信号的发送既可针对整个进程，也可针对某个特定线程。如果信号产生源于线程上下文的特定硬件指令执行、线程试图对断开的管道进行写操作、或者由函数<code>pthread_kill()</code>或<code>pthread_sigqueue()</code>所发出的信号，那么这些信号是面向线程的，除此之外的信号是面向进程的。</li>
<li>当多线程程序收到一个信号，且该进程已然为此信号创建了信号处理程序时，内核会任选一条线程来接收这一信号，并在该线程中调用信号处理程序对其进行处理。</li>
<li>信号掩码（mask）是针对每个线程而言，每个线程可以设置自己的信号掩码</li>
<li>针对为整个进程所挂起（pending）的信号，以及为每条线程所挂起的信号，内核都分别维护有记录</li>
</ul>
<p>刚创建的新线程会从其创建者处继承信号掩码的一份拷贝。线程可以使用<code>pthread_sigmask()</code>来改变或/并获取当前的信号掩码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span>* <span class="built_in">set</span>, <span class="keyword">sigset_t</span>* oldset)</span></span>; <span class="comment">//成功返回0，失败返回代表失败类型的正数</span></span><br></pre></td></tr></table></figure>
<p>它的用法与<code>sigprocmask</code>完全相同。</p>
<p>如果要向一个线程发送信号，可以使用<code>pthread_kill()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_kill</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">int</span> sig)</span></span>; <span class="comment">//成功返回0，失败返回代表失败类型的正数</span></span><br></pre></td></tr></table></figure>
<p>Linux特有的函数<code>pthread_sigqueue()</code>将<code>pthread_kill()</code>和<code>sigqueue()</code>的功能合并，可以向同一进程的另一线程发送携带数据的信号：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_sigqueue</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">int</span> sig, <span class="keyword">const</span> <span class="keyword">union</span> sigval value)</span></span>; <span class="comment">//成功返回0，失败返回代表失败类型的正数</span></span><br></pre></td></tr></table></figure>
<p>由于没有任何Pthreads API属于异步信号安全函数，因此当多线程应用程序处理异步产生的信号时，通常不应该将信号处理函数作为接收信号到达的通知机制。推荐的方法是所有线程都阻塞进程可能接收的所有异步信号，然后再创建一个专用线程来接收信号，从而实现同步接收异步产生的信号。</p>
<h3 id="线程和进程控制"><a class="markdownIt-Anchor" href="#线程和进程控制"></a> 线程和进程控制</h3>
<p>对于<code>exec()</code>系列函数，只要有任意一个线程调用它，则调用程序将被完全替换。除了调用<code>exec</code>的线程之外，其余线程立刻消失。没有任何线程会针对线程特有数据执行解构函数（destructor），也不会调用清理函数（cleanup handler）。该进程的所有互斥量（为进程私有）和属于进程的条件变量都会消失。调用<code>exec()</code>之后，调用线程的线程ID 是不确定的。</p>
<p>当多线程进程调用<code>fork()</code>时，仅会将发起调用的线程复制到子进程中。（子进程中该线程的线程ID与父进程中发起<code>fork()</code>调用线程的线程ID相一致。）其他线程均在子进程中消失，也不会为这些线程调用清理函数以及针对线程特有数据的解构函数。这将会导致全局变量的状态以及所有的Pthreads对象都会在子进程中得以保留，可能会导致线程阻塞或者内存泄漏。因此，推荐在多线程程序中的<code>fork()</code>调用后紧跟<code>exec()</code>调用；或者使用<code>pthread_atfork()</code>系统调用来创建fork处理函数。</p>
<p>如果任何线程调用了<code>exit()</code>，或者主线程执行了return，那么所有线程都将消失，也不会执行线程特有数据的解构函数以及清理函数。</p>
<h3 id="linux的线程实现"><a class="markdownIt-Anchor" href="#linux的线程实现"></a> Linux的线程实现</h3>
<p>目前Linux的线程实现为NPTL，它属于一对一实现的线程模型，即内核分别对每个线程做调度处理。线程同步操作通过内核系统调用实现。Linux的线程使用函数<code>clone()</code>创建，并指定如下标志：CLONE_VM|CLONE_FILES|CLONE_FS|CLONE_SIGHAND|CLONE_THREAD|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID|CLONE_SYSVSEM。</p>
<p>系统调用<code>clone</code>的用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clone</span><span class="params">(<span class="keyword">int</span> (*func)(<span class="keyword">void</span> *), <span class="keyword">void</span>* child_stack, <span class="keyword">int</span> flags, <span class="keyword">void</span>* func_arg, <span class="keyword">pid_t</span>* ptid, struct user_desc* tls, <span class="keyword">pid_t</span>* ctid)</span></span>; <span class="comment">//成功返回子进程编号，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>clone</code>生成的子进程在继续运行时会调用<code>func</code>参数指定的函数，它的参数由<code>func_arg</code>指定。<code>flags</code>参数存放位掩码，用于控制<code>clone</code>的操作。</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151803.png" alt="image-20210714115006363" /></p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151807.png" alt="image-20210714115027789" /></p>
<p>在Linux系统中，实际上线程和进程都是内核调度实体（Kernel Scheduling Entity, KSE），只是与其他KSE之间对属性（虚拟内存、打开文件描述符、对信号的处置、进程ID等）的共享程度不同。</p>
<h1 id="信号"><a class="markdownIt-Anchor" href="#信号"></a> 信号</h1>
<h2 id="概述-9"><a class="markdownIt-Anchor" href="#概述-9"></a> 概述</h2>
<h3 id="信号产生"><a class="markdownIt-Anchor" href="#信号产生"></a> 信号产生</h3>
<p>信号是事件发生时对进程的通知机制，有时也被称为软件中断。一个具有合适权限的进程可以向另一个进程发送信号，这一用法可以作为一种同步技术，或是进程间通信的方式。但是将信号利用于通信的场景很少，因为标准信号不能排队处理，实时信号也存在对信号排队数量的限制，而且信号可携带的信息量也有限。</p>
<p>发往进程的信号通常都源于内核，引发内核为进程产生信号的各类事件包括：</p>
<ul>
<li>硬件发生异常，即硬件检测到一个错误条件并通知内核，然后再由内核发送相应信号给相关进程。硬件异常的例子包括执行一条异常的机器语言指令、引用无法访问的内存区域等。</li>
<li>用户键入能够产生信号的终端特殊字符，包括中断字符、暂停字符等。</li>
<li>发生了软件事件。例如针对于文件描述符的输出变为有效、定时器到期、进程执行的CPU事件超限、进程的某个子进程退出等。</li>
</ul>
<p>信号的生成分为两种方式：同步生成和异步生成。异步生成指的是引发信号产生的事件与进程的执行无关，例如子进程终止、输入中断字符等。对于这类信号，进程一般无法预测其接收信号的时间。而另一种为同步生成，指的是进程本身的执行产生信号，例如执行特定的机器语言指令导致了硬件异常，或者是进程使用<code>raise()</code>、<code>kill()</code>或者<code>killpg()</code>向自身发送信号。</p>
<p>针对于每个信号，都定义了一个唯一的小整数，从1开始对它们进行标记。在头文件<code>&lt;signal.h&gt;</code>中，以<code>SIGxxxx</code>形式的符号名对这些整数做了定义。在Linux中，编号1-31所对应的信号为标准信号，用于内核向进程通知事件；而其余编号表示实时信号。</p>
<h3 id="信号的传递与响应"><a class="markdownIt-Anchor" href="#信号的传递与响应"></a> 信号的传递与响应</h3>
<p>同步产生的信号会立即传递，例如硬件异常会触发一个即时信号；而当进程使用<code>raise()</code>向自身发送信号时，信号也会在<code>raise()</code>调用返回之前就已经发出。</p>
<p>而对于异步信号来说，它们在产生之后，可能会在稍后被传递给某一个进程，中间可能会存在一个瞬时延迟。在产生和到达期间，信号处于等待状态。这是因为内核将等待信号传递给进程的时机为，该进程正在执行，且发生由内核态到用户态的下一次切换时。这意味着只有在系统调用完成时，或者进程再度获得调度时（即一个时间片的开始处），才会发生信号的传递。</p>
<p>如果要确保一段代码不被传递来的信号所中断，可以将信号添加到进程的信号掩码中，这样便会阻塞信号的到达。如果所产生的信号属于阻塞之列，则信号将保持等待状态直到稍后对其解除阻塞。如果一个进程同时解除对多个等待信号的阻塞，那么所有这些信号都会立即传递给该进程。Linux内核会按照信号编号的升序来传递信号。</p>
<p>信号到达之后，进程将视具体信号执行如下的默认操作之一：</p>
<ul>
<li>忽略信号：内核将信号丢弃，信号对进程没有产生任何影响（相当于进程永远不知道曾经出现过该信号）</li>
<li>终止进程：进程异常终止</li>
<li>产生核心转储文件，同时进程终止：核心转储文件包含了进程虚拟内存的镜像，可将其加载到调试器中，以检查进程终止时的状态</li>
<li>停止进程：暂停进程的执行</li>
<li>恢复进程：在之前暂停之后，再次恢复进程的执行</li>
</ul>
<blockquote>
<p>备注—核心转储文件的概念：</p>
<p>特定信号会引发进程创建一个核心转储文件并终止运行，核心转储指的是内含进程终止时内存映像的一个文件。将这一内存映像加载到调试器中，即可查明信号到达时程序代码和数据的状态。</p>
<p>例如在程序运行时键入退出字符（Ctrl+\），则会生成SIGQUIT信号，此时shell会显示core dump信息，代表生成了核心转储文件。这一文件创建于进程的工作目录中，名为core。</p>
</blockquote>
<p>除了根据特定信号产生上述的默认行为，程序也可以改变信号到达时的响应行为，也将其称为对信号的处置设置。程序可将信号的处置设为如下之一：</p>
<ul>
<li>采取默认行为：即撤销之前对于信号处置的修改，恢复其默认处置</li>
<li>忽略信号：适用于默认行为是终止进程的信号</li>
<li>执行信号处理器程序：这一程序是程序员编写的函数，用于执行适当任务以响应传递来的信号</li>
</ul>
<h3 id="信号类型"><a class="markdownIt-Anchor" href="#信号类型"></a> 信号类型</h3>
<p>下表所示为Linux系统与信号相关的信息：</p>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151724.png" alt="image-20210701143620837" style="zoom:67%;" />
<p>其中，信号值在不同的硬件架构下也具有不同的编号。默认列显示的是信号的默认行为，term表示信号终止进程，core表示进程产生核心转储文件并退出，ignore表示忽略该信号，stop表示信号停止了进程，cont表示信号恢复了一个已停止的进程。</p>
<h2 id="信号集"><a class="markdownIt-Anchor" href="#信号集"></a> 信号集</h2>
<p>许多信号相关的系统调用都需要能够表示一组不同的信号。多个信号可以使用一个称为信号集的数据结构来表示，其系统数据类型为<code>sigset_t</code>。可以用来操纵信号集的函数有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span>* <span class="built_in">set</span>)</span> <span class="comment">//初始化一个未包含任何成员的信号集</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span>* <span class="built_in">set</span>)</span> <span class="comment">//初始化一个信号集，使其包含所有信号</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span>* <span class="built_in">set</span>, <span class="keyword">int</span> sig)</span> <span class="comment">//向一个信号集中添加单个信号</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span>* <span class="built_in">set</span>, <span class="keyword">int</span> sig)</span> <span class="comment">//移除一个信号集中的单个信号</span></span></span><br><span class="line"><span class="function"><span class="comment">//上面四个函数返回0表示成功，返回-1表示失败</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span>* <span class="built_in">set</span>, <span class="keyword">int</span> sig)</span> <span class="comment">//判断信号sig是否是信号集set的成员，如果是则返回1，否则返回0</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigandset</span><span class="params">(<span class="keyword">sigset_t</span>* dest, <span class="keyword">sigset_t</span>* left, <span class="keyword">sigset_t</span>* right)</span> <span class="comment">//将left与right的交集放在dest集</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigorset</span><span class="params">(<span class="keyword">sigset_t</span>* dest, <span class="keyword">sigset_t</span>* left, <span class="keyword">sigset_t</span>* right)</span> <span class="comment">//将left与right的并集放在dest集</span></span></span><br><span class="line"><span class="function"><span class="comment">//上面两个函数返回0表示成功，返回-1表示失败</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigisemptyset</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span>* <span class="built_in">set</span>)</span> <span class="comment">//如果set是一个空信号集则返回1，否则返回0</span></span></span><br></pre></td></tr></table></figure>
<h2 id="信号掩码"><a class="markdownIt-Anchor" href="#信号掩码"></a> 信号掩码</h2>
<p>内核会为每个进程维护一个信号掩码，即一组信号，并将阻塞其针对该进程的传递。如果将遭阻塞的信号发送给某进程，那么对该信号的传递将延后，直至从进程信号掩码中移除该信号，从而解除阻塞为止。</p>
<p>向信号掩码中添加信号的方式有：</p>
<ul>
<li>调用信号处理器程序时，可将引发调用的信号自动添加到信号掩码中，是否发生这一情况要视<code>sigaction()</code>函数在安装信号处理器程序时使用的标志而定。</li>
<li>使用<code>sigaction()</code>函数建立信号处理器程序时，可以指定一组额外信号，当调用该处理器程序时会将其阻塞。</li>
<li>使用<code>sigprocmask()</code>系统调用，随时显式地向信号掩码中添加或者移除信号。</li>
</ul>
<p><code>sigprocmask()</code>的使用方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span>* <span class="built_in">set</span>, <span class="keyword">sigset_t</span>* oldset)</span> <span class="comment">//返回0代表成功，-1代表失败</span></span></span><br></pre></td></tr></table></figure>
<p>这一函数既可以修改进程的信号掩码，也可以获得现有的掩码。其中，<code>how</code>参数指定了函数想给信号掩码带来的变化，它的值可以为：</p>
<ul>
<li>SIG_BLOCK：将<code>set</code>指向信号集内的指定信号添加到信号掩码中</li>
<li>SIG_UNBLOCK：将<code>set</code>指向信号集内的指定信号从信号掩码中移除</li>
<li>SIG_SETMASK：将<code>set</code>指向的信号集赋给信号掩码</li>
</ul>
<p>如果<code>oldset</code>参数不为空，则它应该指向一个<code>sigset_t</code>结构的缓冲区，用于返回之前的信号掩码。如果要获取信号掩码但是对其不做改动，则可以将<code>set</code>参数设为空值，此时将忽略<code>how</code>参数。</p>
<h2 id="特殊信号"><a class="markdownIt-Anchor" href="#特殊信号"></a> 特殊信号</h2>
<p>一些特定的信号在传递、处置和处理方面适用于一些特殊规则：</p>
<ul>
<li>SIGKILL和SIGSTOP：SIGKILL的默认行为是终止一个进程，SIGSTOP信号的默认行为是停止一个进程，二者的默认行为均无法改变。同样，这两个信号也不能被阻塞。</li>
<li>SIGCONT和停止信号：如果一个进程处于停止状态，那么一个SIGCONT 信号的到来总是会促使其恢复运行，即使该进程正在阻塞或者忽略SIGCONT 信号。因为只有这种方法可以恢复一个处于停止状态的进程。每当进程收到SIGCONT 信号时，会将处于等待状态的停止信号丢弃。相反，如果任何停止信号传递给了进程，那么进程将自动丢弃任何处于等待状态的SIGCONT 信号。</li>
<li>如果程序在执行时发现，已将对由终端产生信号的处置置为了SIG_IGN（忽略），那么程序通常不应试图去改变信号处置。与之相关的信号有：SIGHUP、SIGINT、SIGQUIT、SIGTTIN、SIGTTOU 和SIGTSTP。</li>
</ul>
<p>而系统中的硬件异常也可以产生SIGBUS、SIGFPE、SIGILL，和SIGSEGV信号，在硬件异常的情况下，如果进程从此类信号的处理器函数中返回，或者是进程忽略或阻塞了这类信号，那么进程的行为未定义。正确处理硬件产生信号的方法有两种，要么接受信号的默认行为（进程终止），要么为其编写不会正常返回的处理器函数。</p>
<h2 id="改变信号处置"><a class="markdownIt-Anchor" href="#改变信号处置"></a> 改变信号处置</h2>
<h3 id="api-3"><a class="markdownIt-Anchor" href="#api-3"></a> API</h3>
<p>UNIX系统提供了两种方法来改变信号处置：<code>signal()</code>和<code>sigaction()</code>。<code>signal()</code>的接口相对简单，但是它的行为在不同的UNIX实现之间存在差异。因此，建立信号处理器应该优先考虑使用<code>sigaction()</code>函数。</p>
<p><code>signal</code>的用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span>(*signal(<span class="keyword">int</span> sig, <span class="keyword">void</span> (*handler)(<span class="keyword">int</span>))) (<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<p>其中，第一个参数<code>sig</code>标识希望修改处置的信号编号；第二个参数<code>handler</code>则标识信号抵达时所调用函数的地址。该函数无返回值，并接受一个整型参数。<code>handler</code>所对应的信号处理器函数一般具有如下格式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*Code for handler*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果调用<code>signal</code>成功，则返回之前的信号处置函数，它是一枚指针，指向带有一个整型参数且无返回值的函数。</p>
<p><code>handler</code>参数也可以用如下值来代替函数地址：</p>
<ul>
<li><code>SIG_DFL</code>：将信号处置重置为默认值</li>
<li><code>SIG_IGN</code>：忽略该信号</li>
</ul>
<p><code>sigaction</code>的用法比<code>signal</code>要更灵活一些。<code>sigaction()</code>允许在获取信号处置的同时无需将其改变，并且，还可设置各种属性对调用信号处理器程序时的行为施以更加精准的控制。此外，在建立信号处理器程序时，<code>sigaction()</code>较之<code>signal()</code>函数可移植性更佳。它的用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">const</span> struct sigaction* act, struct sigaction* oldact)</span> <span class="comment">//返回0表示成功，-1表示失败</span></span></span><br></pre></td></tr></table></figure>
<p><code>sig</code>参数标识想要获取或改变的信号编号。该参数可以是除去SIGKILL和SIGSTOP之外的任何信号。<code>act</code>参数是一枚指针，指向描述信号新处置的数据结构。如果仅对信号的现有处置感兴趣，那么可将该参数指定为<code>NULL</code>。<code>oldact</code>参数是指向同一结构类型的指针，用来返回之前信号处置的相关信息。如果无意获取此类信息，那么可将该参数指定为<code>NULL</code>。</p>
<p><code>sigaction</code>结构类型如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>&#123;</span></span><br><span class="line">	<span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> (*sa_handler)(<span class="keyword">int</span>); </span><br><span class="line">        <span class="keyword">void</span> (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span>*, <span class="keyword">void</span>*);</span><br><span class="line">    &#125;__sigaction_handler; <span class="comment">//对应于signal函数的handler参数</span></span><br><span class="line">	<span class="keyword">sigset_t</span> sa_mask; <span class="comment">//信号掩码</span></span><br><span class="line">	<span class="keyword">int</span> sa_flags; <span class="comment">//位掩码</span></span><br><span class="line">	<span class="keyword">void</span> (*sa_restorer)(<span class="keyword">void</span>); <span class="comment">//仅供内部使用，用于确保信号处理器程序完成之后，会调用专用的sigreturn()系统调用，借此来恢复进程的执行上下文</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>sa_mask</code>字段定义了一组信号，在调用由<code>sa_handler</code>所定义的处理器程序时将阻塞该组信号。当调用信号处理器程序时，会在调用信号处理器之前，将该组信号中当前未处于进程掩码之列的任何信号自动添加到进程掩码中。这些信号将保留在进程掩码中，直至信号处理器函数返回，届时将自动删除这些信号。此外，引发对处理器程序调用的信号将自动添加到进程信号掩码中，保证不会递归地中断自己。</p>
<p>而<code>sa_flags</code>字段是一个位掩码，指定用于控制信号处理过程中的各种选项。</p>
<h3 id="信号处理器函数"><a class="markdownIt-Anchor" href="#信号处理器函数"></a> 信号处理器函数</h3>
<h4 id="设计原则"><a class="markdownIt-Anchor" href="#设计原则"></a> 设计原则</h4>
<p>信号处理器程序（也称为信号捕捉器）是当指定信号传递给进程时将会调用的一个函数。调用信号处理器程序，可能会随时打断主程序流程；内核代表进程来调用处理器程序，当处理器返回时，主程序会在处理器打断的位置恢复执行。</p>
<p>一般而言，信号处理器函数设计地越简单越好，这将降低引发竞争条件的风险。两种常见的设计方式为：</p>
<ol>
<li>信号处理器函数设置全局性标志变量并退出。主程序对此标志进行周期性检查，一旦置位便采取相应动作</li>
<li>信号处理器函数执行某种类型的清理动作，接着终止进程或者使用非本地跳转，将栈解开并将控制返回到主程序的预定位置</li>
</ol>
<p>在信号处理器函数中，并非所有的系统调用和库函数都可以安全调用。在编写信号处理器函数时有两种选择：</p>
<ul>
<li>确保信号处理器函数代码本身可重入，且只调用异步信号安全的函数</li>
<li>当主程序执行不安全函数，或者操作信号处理器函数也可以更新的全局数据结构时，阻塞信号的传递（这一要求有些困难，）</li>
</ul>
<blockquote>
<p>备注—可重入与异步信号安全的概念</p>
<p>可重入指的是，函数由两条或多条线程调用时，即便是交叉执行，其效果也与各线程以未定义顺序依次调用时一致。例如更新全局变量或静态数据结构的函数可能是不可重入的。</p>
<p>如果某一函数是可重入的，又或者信号处理器函数无法将其中断时，就称该函数是异步信号安全的。</p>
</blockquote>
<p>而如果必须要共享某些全局变量，则可以在声明变量的时候使用<code>volatile</code>关键字，并且使用<code>sig_atomic_t</code>来保证读写操作的原子性。也就是说，所有在主程序和信号处理器函数之间共享的全局变量应声明为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">sig_atomic_t</span> flag</span><br></pre></td></tr></table></figure>
<h4 id="终止信号处理器函数"><a class="markdownIt-Anchor" href="#终止信号处理器函数"></a> 终止信号处理器函数</h4>
<p>信号处理器函数的终止方式包括：</p>
<ul>
<li>返回主程序</li>
<li>使用<code>_exit()</code>终止进程，处理器函数可以提前做一些清理工作</li>
<li>使用<code>kill()</code>发送信号来杀掉进程</li>
<li>从信号处理器函数中执行非本地跳转</li>
<li>使用<code>abort()</code>函数终止进程，并产生核心转储</li>
</ul>
<p>如果使用<code>longjmp()</code>来退出信号处理器函数，这一系统调用是否会恢复信号掩码取决于具体的UNIX实现。因此，最好是使用如下一对系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> savesigs)</span> <span class="comment">//第一次调用设置跳转点时返回0，通过siglongjmp返回跳转点时返回非0值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> val)</span></span></span><br></pre></td></tr></table></figure>
<p>在<code>sigsetjmp</code>函数中多出了一个参数<code>savesigs</code>，如果它被设置为非0值，那么<code>sigsetjmp</code>会将进程的当前掩码保存在<code>env</code>中，之后通过相同<code>env</code>参数的<code>siglongjmp</code>调用进行恢复；如果它被设置为0，则不会保存和恢复进程的信号掩码。</p>
<p>需要注意的是，这两个函数都不是异步信号安全的。</p>
<p><code>abort()</code>的使用方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数<code>abort()</code>通过产生<code>SIGABRT</code>信号来终止调用进程，对这一信号的默认动作是产生核心转储文件并终止进程。无论阻塞或者忽略<code>SIGABRT</code>信号，<code>abort()</code>调用均不受影响；而且除非进程捕获<code>SIGABRT</code>信号之后信号处理器函数尚未返回，否则<code>abort()</code>必须终止进程。</p>
<h4 id="sa_siginfo标志"><a class="markdownIt-Anchor" href="#sa_siginfo标志"></a> SA_SIGINFO标志</h4>
<p>如果在使用<code>sigaction()</code>创建处理器函数的时候，设置了<code>SA_SIGINFO</code>标志，那么在收到信号时，处理器函数可以获取该信号的一些附加信息。为了获取这一信息，需要将处理器函数声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">siginfo_t</span>* siginfo, <span class="keyword">void</span>* ucontext)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中<code>sig</code>表示信号编号，<code>siginfo</code>是用于提供信号附加信息的一个数据结构，<code>ucontext</code>则是一个指向<code>ucontext_t</code>类型数据结构的指针，该结构提供了用户上下文信息，用于描述调用信号处理器函数之前的进程状态。</p>
<h4 id="系统调用的中断和重启"><a class="markdownIt-Anchor" href="#系统调用的中断和重启"></a> 系统调用的中断和重启</h4>
<p>信号处理器函数返回之后，默认情况下，系统调用失败，并将<code>errno</code>设置为EINTR。如果希望遭到中断的系统调用可以继续运行，则可以在<code>sigaction</code>调用中设置<code>SA_RESTART</code>标志。</p>
<p>需要注意的是，并非所有的系统调用都可以通过指定<code>SA_RESTART</code>来达到自动重启的目的。</p>
<h2 id="信号相关操作"><a class="markdownIt-Anchor" href="#信号相关操作"></a> 信号相关操作</h2>
<h3 id="发送信号"><a class="markdownIt-Anchor" href="#发送信号"></a> 发送信号</h3>
<p>一个进程可以使用<code>kill()</code>系统调用向另一个进程发送信号（之所以用kill，是因为早期的UNIX实现中，大多数信号的默认行为是终止进程）。它的用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span> <span class="comment">//返回0表示成功，-1表示失败</span></span></span><br></pre></td></tr></table></figure>
<p>其中<code>sig</code>代表要发送的信号。<code>pid</code>参数用于标识一个或者多个目标进程，如何解释这一参数要视其具体数值：</p>
<ul>
<li>如果<code>pid</code>大于0，则发送信号给<code>pid</code>指定的进程</li>
<li>如果<code>pid</code>等于0，则发送信号给与调用进程同组的每个进程，包括调用进程自身</li>
<li>如果<code>pid</code>小于-1，那么会向组ID等于该<code>pid</code>绝对值的进程组内所有下属进程发送信号</li>
<li>如果<code>pid</code>等于-1，那么除去init和调用进程自身之外，给它有权将信号发往的所有进程发送信号。这一方式也称为广播信号</li>
</ul>
<p>如果没有进程与指定的<code>pid</code>匹配，则<code>kill</code>调用失败，同时将<code>errno</code>设置为ESRCH（即查无此进程）。</p>
<p>进程要发送信号给另一个进程，还需要适当权限，权限的规则如下：</p>
<ul>
<li>特权级进程可以向任何进程发送信号</li>
<li>以root用户和组运行的init进程（进程号为1）仅接收已安装了处理器函数的信号，这可以防止系统管理员意外杀死init进程</li>
<li><code>SIGCONT</code>信号需要特殊处理。无论对用户ID的检查结果如何，非特权进程可以向同一会话中的任何其他进程发送这一信号</li>
<li>如果发送者的实际或有效用户ID匹配于接受者的实际用户ID或者保存设置用户ID（saved set-user-id），那么非特权进程也可以向另一进程发送信号</li>
</ul>
<p>如果进程无权发送信号给所请求的<code>pid</code>，那么<code>kill()</code>调用将失败，且将<code>errno</code>置为EPERM。若<code>pid</code>所指为一系列进程（即<code>pid</code>是负值）时，只要可以向其中之一发送信号，则<code>kill()</code>调用成功。</p>
<p><code>kill()</code>函数的另一种用法是，如果将参数<code>sig</code>设置为0（即空信号），则无信号发送。但是此时仍然会执行错误检查，查看是否可以向目标进程发送信号。利用这一特点，可以使用空信号来检测具有特定ID的进程是否存在。如果发送空信号失败，且<code>errno</code>是EPERM，也或者是调用成功，则表示进程存在。</p>
<p>此外，还有一些其它的发送信号方式。</p>
<p><code>raise()</code>函数用于给自身发送信号，用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span> <span class="comment">//成功返回0，失败返回一个非0值</span></span></span><br></pre></td></tr></table></figure>
<p><code>killpg()</code>函数向某一进程组的所有成员发送一个信号，用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">killpg</span><span class="params">(<span class="keyword">pid_t</span> pgrp, <span class="keyword">int</span> sig)</span> <span class="comment">//成功返回0，失败返回-1</span></span></span><br></pre></td></tr></table></figure>
<h3 id="显示信号描述"><a class="markdownIt-Anchor" href="#显示信号描述"></a> 显示信号描述</h3>
<p>每个信号都有一串与之相关的可打印说明，这些描述位于数组<code>sys_siglist</code>中。例如可以直接使用<code>sys_siglist[SIGPIPE]</code>来获取对<code>SIGPIPE</code>信号的描述。另一种办法是使用<code>strsignal</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strsignal</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psignal</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br></pre></td></tr></table></figure>
<p><code>strsignal</code>函数对<code>sig</code>参数进行边界检查，然后返回一枚指针，指向针对于该信号的可打印描述字符串，或者是当信号编号无效时指向错误字符串。</p>
<p><code>psignal</code>函数所示为<code>msg</code>参数所给定的字符串，后面跟有一个冒号，随后是对应于<code>sig</code>的信号描述。</p>
<h3 id="处于等待状态的信号"><a class="markdownIt-Anchor" href="#处于等待状态的信号"></a> 处于等待状态的信号</h3>
<p>如果某进程接受了一个该进程正在阻塞的信号，那么会将该信号填加到进程的等待信号集。当（且如果）之后解除了对该信号的锁定时，会随之将信号传递给此进程。<code>sigpending()</code>系统调用可以确定进程中处于等待状态的信号：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span>* <span class="built_in">set</span>)</span> <span class="comment">//返回0表示成功，-1表示失败</span></span></span><br></pre></td></tr></table></figure>
<p>这一调用为调用进程返回处于等待状态的信号集，并将其置于<code>set</code>指向的<code>sigset_t</code>结构中。而等待信号集仅仅是一个掩码，仅表明信号是否发生，而未表明其发生的次数。如果同一个信号在阻塞状态下发生多次，那么会将该信号记录在等待信号集中，并在随后只传递一次。</p>
<h3 id="等待信号"><a class="markdownIt-Anchor" href="#等待信号"></a> 等待信号</h3>
<p>调用<code>pause</code>将暂停进程执行，直到信号处理器函数中断该调用，或者一个未处理信号终止进程。也就是说，只有当前进程接收到信号之后，进程才可能会继续执行下去，否则会一直等待信号的到来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">//返回-1，并且将errno设置为EINTR</span></span></span><br></pre></td></tr></table></figure>
<p>处理信号时，<code>pause()</code>会遭到中断并返回。</p>
<p>在对信号编程时偶尔会遇到如下的情况，需要临时阻塞一个信号，以防止其信号处理器不会将某些关键代码片段的执行中断，然后解除对这一信号的阻塞并暂停执行，直到有信号到达。而解除并暂停执行这一步操作需要保证其原子性，否则可能会出现竞争条件。因此，可以使用<code>sigsuspend</code>系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsuspend</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span>* mask)</span></span></span><br></pre></td></tr></table></figure>
<p>这一系统调用将<code>mask</code>所指向的信号集来替换进程的信号掩码，然后挂起进程的指向，直到其捕获到信号，并从信号处理器中返回。一旦处理器返回，进程的信号掩码将被恢复为调用前的值。</p>
<p>若<code>sigsuspend()</code>因信号的传递而中断，则将返回−1，并将<code>errno</code>置为EINTR。如果<code>mask</code>指向的地址无效，则<code>sigsuspend()</code>调用失败，并将<code>errno</code>置为EFAULT。</p>
<p>另一个替代方案是使用<code>sigwaitinfo()</code>系统调用，可以用来同步接收信号：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigwaitinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span>* <span class="built_in">set</span>, <span class="keyword">siginfo_t</span>* info)</span> <span class="comment">//成功则返回发送的信号数目，失败返回-1</span></span></span><br></pre></td></tr></table></figure>
<p>这一系统调用会挂起进程的执行，直到<code>set</code>所对应信号集中的某一信号抵达。如果在调用时，<code>set</code>中的某一信号已经处于等待状态，那么函数会立即返回。传递来的信号就会从进程的等待信号队列中移除，并将返回信号编号作为函数结果。</p>
<p><code>info</code>参数如果不为空，则会指向经初始化处理的<code>siginfo_t</code>结构，其中包含的信息与提供给信号处理器函数的这一参数相同。</p>
<p>它的一个变体是<code>sigtimedwait()</code>系统调用，这一函数允许指定等待时限：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigtimedwait</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span>* <span class="built_in">set</span>, <span class="keyword">siginfo_t</span>* info, <span class="keyword">const</span> struct timespec* timeout)</span> <span class="comment">//成功则返回发送的信号数目，失败返回-1</span></span></span><br></pre></td></tr></table></figure>
<p>其中<code>timeout</code>参数指向一个<code>timespec</code>数据结构，是指向如下数据结构的一枚指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>&#123;</span></span><br><span class="line">	<span class="keyword">time_t</span> tv_sec;</span><br><span class="line">	<span class="keyword">long</span> tv_nsec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过文件描述符获取信号"><a class="markdownIt-Anchor" href="#通过文件描述符获取信号"></a> 通过文件描述符获取信号</h3>
<p>Linux提供了一个非标准的<code>signalfd()</code>系统调用，利用它可以创建一个特殊的文件描述符，发往调用者的信号都可以从该描述符中读取。用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/signalfd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">signalfd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">sigset_t</span>* mask, <span class="keyword">int</span> flags)</span> <span class="comment">//成功则返回相应的文件描述符，失败返回-1</span></span></span><br></pre></td></tr></table></figure>
<p>其中，<code>mask</code>参数是一个信号集，指定了有意通过<code>signalfd</code>文件描述符来读取的信号；<code>fd</code>参数如果为-1，则创建一个新的文件描述符，否则会修改与<code>fd</code>相关的<code>mask</code>值，且要求这一<code>fd</code>一定是由之前<code>signalfd()</code>的一次调用创建而得。<code>flags</code>参数可以设置为SFD_CLOEXEC和<code>SFD_NONBLOCK</code>。</p>
<p>创建了文件描述符之后，便可以使用<code>read()</code>从中读取信号。提供给<code>read</code>的缓冲区必须足够大，至少能够容纳一个<code>signalfd_siginfo</code>结构。</p>
<h2 id="实时信号"><a class="markdownIt-Anchor" href="#实时信号"></a> 实时信号</h2>
<h3 id="概述-10"><a class="markdownIt-Anchor" href="#概述-10"></a> 概述</h3>
<p>实时信号用于弥补对于标准信号的限制，相比于标准信号，它具有如下这些优势：</p>
<ul>
<li>信号范围有所扩大，可用于应用程序自定义的目的。</li>
<li>对实时信号采取队列化管理。如果将某个实时信号的多个实例发送给一个进程，则会多次传递该信号</li>
<li>当发送一个实时信号时，可为信号指定伴随数据。</li>
<li>不同实时信号的传递顺序具有保障，信号的优先级与编号有关，编号越小则优先级越高</li>
</ul>
<p>在<code>&lt;signal.h&gt;</code>头文件中定义的RTSIG_MAX常量表征实时信号的可用数量，常量SIGRTMIN和SIGRTMAX则分别表示可用实时信号编号的最小值和最大值。</p>
<h3 id="发送实时信号"><a class="markdownIt-Anchor" href="#发送实时信号"></a> 发送实时信号</h3>
<p>系统调用<code>sigqueue()</code>将<code>sig</code>指定的实时信号发送给由<code>pid</code>指定的进程。用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigqueue</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig, <span class="keyword">const</span> <span class="keyword">union</span> sigval value)</span> <span class="comment">//返回0代表成功，-1代表失败</span></span></span><br></pre></td></tr></table></figure>
<p>使用<code>sigqueue</code>发送信号的权限与<code>kill</code>的要求一致，也可以发送空信号（即信号0）。但是<code>sigqueue</code>不能通过将<code>pid</code>设置为负值而向整个进程组发送信号。参数<code>value</code>是一个<code>sigval</code>类型的联合体，指定了信号的伴随数据，具有以下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> sigval&#123;</span><br><span class="line">	<span class="keyword">int</span> sival_int;</span><br><span class="line">	<span class="keyword">void</span>* sival_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦触及到排队信号的数量限制，<code>sigqueue</code>调用将会失败，同时将<code>errno</code>设置为EAGAIN，表示需要再次发送信号。</p>
<h3 id="处理实时信号"><a class="markdownIt-Anchor" href="#处理实时信号"></a> 处理实时信号</h3>
<p>实时信号的处理方式与标准信号一样，可以使用<code>signal()</code>或者<code>sigaction()</code>函数来处理实时信号。</p>
<h1 id="进程间通信"><a class="markdownIt-Anchor" href="#进程间通信"></a> 进程间通信</h1>
<p>UNIX 系统上各种通信和同步工具可以根据功能分成三类：</p>
<ul>
<li>通信：这些工具关注进程之间的数据交换。</li>
<li>同步：这些进程关注进程和线程操作之间的同步。</li>
<li>信号：尽管信号的主要作用并不在此，但在特定场景下仍然可以将它作为一种同步技术。更罕见的是信号还可以作为一种通信技术：信号编号本身是一种形式的信息，并且可以在实时信号上绑定数据（一个整数或指针）。</li>
</ul>
<p>这些工具的分类如下图所示：</p>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151917.png" alt="image-20210715103944465" style="zoom:67%;" />
<p>通常使用通用术语进程间通信（IPC）指代所有这些工具。</p>
<h2 id="管道和fifo"><a class="markdownIt-Anchor" href="#管道和fifo"></a> 管道和FIFO</h2>
<h3 id="概述-11"><a class="markdownIt-Anchor" href="#概述-11"></a> 概述</h3>
<p>管道可以用来在相关进程之间传递数据。FIFO 是管道概念的一个变体，它们之间的一个重要差别在于FIFO 可以用于任意进程间的通信。一个管道有如下几个特征：</p>
<ul>
<li>一个管道是一个字节流。从管道中读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是什么。此外，通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序与它们被写入管道的顺序是完全一样的。</li>
<li>如果试图从一个当前为空的管道中读取数据，将会被阻塞直到至少有一个字节被写入到管道中为止。如果管道的写入端被关闭了，那么从管道中读取数据的进程在读完管道中剩余的所有数据之后将会看到文件结束，即<code>read()</code>返回0</li>
<li>管道的数据传递方向是单向的，一端用于写入，另一端用于读取</li>
<li>如果多个进程写入同一个管道，那么如果它们在一个时刻写入的数据量不超过PIPE_BUF字节（Linux系统下这个值为4096），那么就可以确保写入的数据不会发生相互混合的情况。</li>
<li>管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的。一旦管道被填满之后，后续向该管道的写入操作就会被阻塞直到读者从管道中移除了一些数据为止。</li>
</ul>
<h3 id="创建与使用"><a class="markdownIt-Anchor" href="#创建与使用"></a> 创建与使用</h3>
<p><code>pipe</code>系统调用可以创建一个新的管道：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> filedes[<span class="number">2</span>])</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>如果调用成功，则会在数组<code>filedes</code>中返回两个打开的文件描述符，<code>filedes[0]</code>表示管道的读取端，<code>filedes[1]</code>表示管道的写入端。</p>
<p>与所有的文件描述符一样，可以使用<code>read</code>和<code>write</code>系统调用在管道上执行I/O操作。一旦向管道的写入端写入数据之后立即就能从管道的读取端读取数据。管道上的<code>read()</code>调用会读取的数据量为所请求的字节数与管道中当前存在的字节数两者之间较小的那个，而管道为空时则阻塞。也可以在管道上使用<code>stdio</code>函数（<code>printf()</code>、<code>scanf()</code>等），只需要首先使用<code>fdopen()</code>获取一个与<code>filedes</code>中的某个描述符对应的文件流即可。</p>
<p>由于子进程会继承父进程的文件描述符的副本，因此可以通过管道来实现相关进程之间的通信。相关进程指的是这些进程来自于同一个祖先进程，且管道由祖先进程所创建。这些进程必须关闭未使用的管道文件描述符，否则会导致出错。</p>
<p>当所有子进程都关闭了管道的写入端的文件描述符之后，父进程在管道上的<code>read()</code>就会结束并返回文件结束（0）。根据这一特性可以将管道作为一种进程同步的方法。这种方法可以同来协调一个进程的动作使之与多个其他（相关）进程匹配。当然，也可以使用其它的同步结构。</p>
<p>创建管道时，为管道两端分配文件描述符将会优先选择可用描述符中数值最小的，因此可以使用这一特性，将管道的输入和输出端绑定为进程的标准输入或输出。可以通过创建管道时先关闭标准输入/输出，或者是使用<code>dup2</code>来复制文件描述符。</p>
<h3 id="与shell命令通信"><a class="markdownIt-Anchor" href="#与shell命令通信"></a> 与shell命令通信</h3>
<p>管道的一个常见用途是执行shell命令，并读取其输出或向其发送一些输入。<code>popen</code>和<code>pclose</code>函数可以简化这一任务：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE* <span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* command, <span class="keyword">const</span> <span class="keyword">char</span>* mode)</span></span>; <span class="comment">//成功返回文件流，失败返回NULL，并设置errno表示失败原因</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE* stream)</span></span>; <span class="comment">//成功则返回子进程的结束状态，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>popen</code>函数创建一个管道，然后创建一个子进程来执行shell，而shell又创建了一个子进程来执行<code>command</code>字符串。<code>mode</code>参数是一个字符串，它确定调用进程是从管道中读取数据（<code>'r'</code>），也就是命令的输出被送入到管道的输入端；还是将数据写入到管道中（<code>'w'</code>），也就是命令的输入来自于调用进程。</p>
<p>使用<code>system()</code>时，shell命令的执行是被封装在单个函数调用中的；而使用<code>popen()</code>时，调用进程是与shell命令并行运行的，然后会调用<code>pclose()</code>。</p>
<h3 id="fifo"><a class="markdownIt-Anchor" href="#fifo"></a> FIFO</h3>
<p>从语义上来讲，FIFO 与管道类似，它们两者之间最大的差别在于FIFO 在文件系统中拥有一个名称，并且其打开方式与打开一个普通文件是一样的。这样就能够将FIFO 用于非相关进程之间的通信（如客户端和服务器）。</p>
<p>一旦打开了FIFO，就能在它上面使用与操作管道和其他文件的系统调用一样的I/O系统调用。与管道一样，FIFO 也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的名称也由此而来：先入先出。FIFO 有时候也被称为命名管道。</p>
<p>创建一个FIFO的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo [-m mode] pathname</span><br></pre></td></tr></table></figure>
<p>其中<code>pathname</code>指的是创建的FIFO的名称，<code>-m</code>选项用来指定权限<code>mode</code>（工作方式与<code>chmod</code>一样）</p>
<p>要在程序中创建一个FIFO，则可以使用<code>mkfifo()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">mode_t</span> mode)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>当一个进程打开一个FIFO的一端时，如果FIFO的另一端还没有被打开，那么该进程会被阻塞。但有些时候阻塞并不是期望的行为，而这可以通过在调用<code>open()</code>时指定O_NONBLOCK标记来实现。如果打开FIFO是为了写入，并且还没有打开FIFO的另一端来读取数据，那么<code>open()</code>调用会失败，并将<code>errno</code>设置为ENXIO。</p>
<h3 id="读写语义"><a class="markdownIt-Anchor" href="#读写语义"></a> 读写语义</h3>
<p>管道和FIFO上<code>read()</code>操作的语义可以总结为下表：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151929.png" alt="image-20210715141636626" /></p>
<p><code>write()</code>操作的语义如下表：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151932.png" alt="image-20210715141715046" /></p>
<h2 id="system-v-ipc"><a class="markdownIt-Anchor" href="#system-v-ipc"></a> System V IPC</h2>
<h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3>
<p>System V IPC是首先在System V中被广泛使用的三种IPC机制的名称并且之后被移植到了大多数UNIX实现中以及被加入了各种标准中。System V IPC包括三种不同的进程间通信机制：消息队列、信号量和共享内存。System V IPC的编程接口可汇总为下表：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151937.png" alt="image-20210715143528480" /></p>
<h3 id="消息队列"><a class="markdownIt-Anchor" href="#消息队列"></a> 消息队列</h3>
<h4 id="创建或打开"><a class="markdownIt-Anchor" href="#创建或打开"></a> 创建或打开</h4>
<p>使用<code>msgget()</code>系统调用可以创建一个新的消息队列，或者获得一个已有队列的标识符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>; <span class="comment">//成功则返回消息队列的编号，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>key</code>参数可以设置为IPC_PRIVATE，这样会创建一个新的IPC对象；或者是使用<code>ftok()</code>函数生成。<code>msgflg</code>参数可以为0，或者加上掩码IPC_CREAT（如果key不存在则创建新的消息队列）、IPC_EXCL（如果指定IPC_CREAT且key对应的队列已存在，则返回错误）。</p>
<h4 id="消息交换"><a class="markdownIt-Anchor" href="#消息交换"></a> 消息交换</h4>
<p>消息队列上的I/O操作可以使用下面的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span>* msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>; <span class="comment">//成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">ssizt_t</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span>* msgp, <span class="keyword">size_t</span> maxmsgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span>; <span class="comment">//成功返回读取的字节数，失败返回-1</span></span><br><span class="line"><span class="comment">//msgp参数通常写为如下的数据结构：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mymsg</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>msgsnd</code>系统调用向消息队列写入一条信息，<code>msqid</code>代表消息队列标识符，<code>msgp</code>为要发送的消息，<code>msgsz</code>为发送的消息长度，<code>msgflg</code>为位掩码，用于控制<code>msgsnd</code>的操作，目前只定义了IPC_NOWAIT这一个标记，代表执行非阻塞的发送操作。</p>
<p>向消息队列写入消息要求具备在该队列上的写权限。</p>
<p><code>msgrcv</code>系统调用从消息队列中读取（以及删除）一条消息，并将其内容复制到<code>msgp</code>指向的缓冲区，<code>maxmsgsz</code>代表<code>mtext</code>的最大长度。读取消息的顺序无需与消息被发送的一致。可以根据<code>mtype</code>字段的值来选择消息，而这个选择过程是由<code>msgtyp</code>参数来控制的：如果<code>msgtyp</code>等于0，则删除队列的第一条信息；如果大于0，则将队列中第一条<code>mtype</code>等于<code>msgtyp</code>的消息删除并返回给调用进程；如果小于0则将等待消息当成优先队列，返回<code>mtype</code>最小，且数值小于等于<code>msgtyp</code>绝对值的第一条消息。<code>msgflg</code>是一个位掩码，可以为IPC_NOWAIT、MSG_EXCEPT、MSG_NOERROR这三个掩码其中0个或多个的或运算。</p>
<h4 id="消息队列控制"><a class="markdownIt-Anchor" href="#消息队列控制"></a> 消息队列控制</h4>
<p><code>msgctl</code>系统调用可以控制消息队列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds* buf)</span></span>; <span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>msqid</code>代表要操作的消息队列；<code>cmd</code>指定队列上要执行的操作，它的取值为如下三个中的一个：</p>
<ul>
<li>IPC_RMID：立即删除消息队列对象及其关联的<code>msqid_ds</code>数据结构，队列中所有剩余消息丢失，所有被阻塞的读写进程会被唤醒</li>
<li>IPC_STAT：将与这个消息队列关联的<code>msqid_ds</code>数据结构的副本放到<code>buf</code>指向的缓冲区中</li>
<li>IPC_SET：使用<code>buf</code>指向的缓冲区提供的值更新与这个消息队列关联的<code>msqid_ds</code>数据结构中被选中的字段。</li>
</ul>
<h4 id="关联数据结构"><a class="markdownIt-Anchor" href="#关联数据结构"></a> 关联数据结构</h4>
<p>每个消息队列都有一个关联的<code>msqid_ds</code>数据结构，形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span> <span class="comment">//所有权和许可</span></span><br><span class="line">    <span class="keyword">time_t</span> msg_stime; <span class="comment">//创建队列时为0，后续每次调用msgsnd成功都会将其设置为当前时间</span></span><br><span class="line">    <span class="keyword">time_t</span> msg_rtime; <span class="comment">//创建队列时为0，后续每次调用msgrcv成功都会将其设置为当前时间</span></span><br><span class="line">    <span class="keyword">time_t</span> msg_ctime; <span class="comment">//创建消息队列，以及执行IPC_SET成功都会将其设置为当前时间 </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> __msg_cbytes; <span class="comment">//创建时为0，后续代表所有消息的mtext字段包含字节数总和</span></span><br><span class="line">    <span class="keyword">msgqnum_t</span> msg_qnum; <span class="comment">//创建时为0，后面代表队列的消息总数</span></span><br><span class="line">    <span class="keyword">msglen_t</span> msg_qbytes; <span class="comment">//mtext字段的字节总数上限</span></span><br><span class="line">    <span class="keyword">pid_t</span> msg_lspid; <span class="comment">//创建时为0，后面每次调用msgsnd成功会设置为调用进程的ID</span></span><br><span class="line">    <span class="keyword">pid_t</span> msg_lrpid; <span class="comment">//创建时为0，后面每次调用msgrcv成功会设置为调用进程的ID</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h4>
<ol>
<li>消息队列是通过标识符引用的，而不是像大多数其他UNIX I/O机制那样使用文件描述符。因此无法使用基于文件描述符的I/O技术</li>
<li>使用键而不是文件名来标识消息队列，会增加额外的程序设计复杂性</li>
<li>消息队列无连接，内核不会维护引用队列的进程数</li>
<li>消息队列总数、消息大小以及单个队列的容量都有限制</li>
</ol>
<h3 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h3>
<h4 id="简介-2"><a class="markdownIt-Anchor" href="#简介-2"></a> 简介</h4>
<p>System V信号量不是用来在进程间传输数据的，而是用来同步进程的动作。信号量的一个常见用途是同步对一块共享内存的访问以防止出现一个进程在访问共享内存的同时另一个进程更新这块内存的情况。</p>
<p>一个信号量是一个由内核维护的整数，其值被限制为大于或等于0。在一个信号量上可以执行各种操作（即系统调用），包括：</p>
<ul>
<li>将信号量设置为一个绝对值</li>
<li>在信号量当前值的基础上加/减1</li>
<li>等待信号量的值等于0</li>
</ul>
<p>当减小一个信号量的值时，内核会将所有试图将信号量值降低到0之下的操作阻塞。如果信号量的当前值不为0，那么等待信号量的值等于0的调用进程将会发生阻塞。</p>
<p>使用System V 信号量的常规步骤如下。</p>
<ul>
<li>使用<code>semget()</code>创建或打开一个信号量集。</li>
<li>使用<code>semctl()</code> SETVAL或SETALL操作初始化集合中的信号量。（只有一个进程需要完成这个任务。</li>
<li>使用<code>semop()</code>操作信号量值。使用信号量的进程通常会使用这些操作来表示一种共享资源的获取和释放。</li>
<li>当所有进程都不再需要使用信号量集之后使用<code>semctl()</code> IPC_RMID 操作删除这个集合。（只有一个进程需要完成这个任务。）</li>
</ul>
<h4 id="创建或打开-2"><a class="markdownIt-Anchor" href="#创建或打开-2"></a> 创建或打开</h4>
<p><code>semget()</code>系统调用创建一个新信号量集，或者获取一个既有集合的标识符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg)</span></span>; <span class="comment">//成功返回信号量的标识符，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>key</code>参数可以设置为IPC_PRIVATE，这样会创建一个新的IPC对象；或者是使用<code>ftok()</code>函数生成。如果要创建一个新的信号量集，那么<code>nsem</code>参数会指定信号量的数量（必须大于0）；如果要获取一个既有集的标识符，则<code>nsem</code>参数需要小于或等于集合大小。<code>semflg</code>参数为一个位掩码，指定了施加于新信号量集之上的权限或需检查的一个既有集合的权限。</p>
<h4 id="控制信号量"><a class="markdownIt-Anchor" href="#控制信号量"></a> 控制信号量</h4>
<p><code>semctl()</code>系统调用在一个信号量集或集合中的单个信号量上执行各种控制操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, <span class="keyword">union</span> semun arg)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>semid</code>参数是操作所施加的信号量集的标识符。对于那些在单个信号量上执行的操作，<code>semnum</code>参数标识出了集合中的具体信号量。对于其他操作则会忽略这个参数，并且可以将其设置为0。<code>cmd</code>参数指定了需执行的操作。</p>
<p>第四个参数<code>arg</code>是一个<code>union</code>类型的变量，需要在程序中显式定义这个类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> semun&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span>* <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>* <span class="built_in">array</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__linux__)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>* __<span class="title">buf</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cmd</code>参数可以设置的值及其对应的操作如下：</p>
<ul>
<li>常规控制操作：
<ul>
<li>IPC_RMID：立即删除信号量集及其关联的<code>semid_ds</code>数据结构</li>
<li>IPC_STAT：在<code>arg.buf</code>指向的缓冲器中放置一份与这个信号量集相关联的<code>semid_ds</code>数据结构的副本</li>
<li>IPC_SET：使用<code>arg.buf</code>指向的缓冲器中的值来更新与信号量集关联的<code>semid_ds</code>数据结构中的字段</li>
</ul>
</li>
<li>获取和初始化信号量值
<ul>
<li>GETVAL：返回由<code>semid</code>指定的信号量中第<code>semnum</code>个信号量的值</li>
<li>SETVAL：将<code>semid</code>指定的信号量集中的第<code>semnum</code>个信号量的值初始化为<code>arg.val</code></li>
<li>GETALL：获取由<code>semid</code>指向的信号量集中所有信号量的值并将它们放在<code>arg.array</code>指向的数组中。程序员必须要确保该数组具备足够的空间。这个操作将忽略<code>semnum</code>参数</li>
<li>SETALL：使用<code>arg.array</code>指向的数组中的值初始化<code>semid</code>指向的集合中的所有信号量。这个操作将忽略<code>semnum</code>参数</li>
</ul>
</li>
<li>获取单个信号量的信息
<ul>
<li>GETPID：返回上一个在该信号量上执行<code>semop()</code>进程的ID</li>
<li>GETNCNT：返回正在等待信号量值增长的进程数</li>
<li>GETZCNT：返回正在等待信号量的值变为0的进程数</li>
</ul>
</li>
</ul>
<h4 id="信号量关联数据结构"><a class="markdownIt-Anchor" href="#信号量关联数据结构"></a> 信号量关联数据结构</h4>
<p>每个信号量集都有一个关联的<code>semid_ds</code>数据结构，其形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span> <span class="comment">//在创建信号量集时初始化这个子结构中的字段</span></span><br><span class="line">    <span class="keyword">time_t</span> sem_otime; <span class="comment">//在创建信号量集时会将这个字段设置为0，然后在每次成功的semop()调用或当信号量值因SEM_UNDO操作而发生变更时将这个字段设置为当前时间</span></span><br><span class="line">    <span class="keyword">time_t</span> sem_ctime; <span class="comment">//在创建信号量时以及每个成功的IPC_SET、SETALL和SETVAL操作执行完毕之后将这个字段设置为当前时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sem_nsems; <span class="comment">//在创建集合时将这个字段的值初始化为集合中信号量的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="信号量操作"><a class="markdownIt-Anchor" href="#信号量操作"></a> 信号量操作</h4>
<p><code>semop</code>系统调用在<code>semid</code>标识的信号量集中的信号量上面执行一个或者多个操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf* sops, <span class="keyword">unsigned</span> <span class="keyword">int</span> nsops)</span></span>; <span class="comment">//返回0代表成功，-1代表失败</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semtimedop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf* sops, <span class="keyword">unsigned</span> <span class="keyword">int</span> nsops, struct timespec* timeout)</span></span>; <span class="comment">//可以指定调用阻塞的时间上限，返回0代表成功，-1代表失败</span></span><br></pre></td></tr></table></figure>
<p><code>sops</code>参数是一个指向数组的指针，数组中包含了需要执行的操作，<code>nsops</code>参数给出了数组的大小（数组至少需包含一个元素）。操作将会按照在数组中的顺序以原子的方式被执行。<code>sop</code>数组中的元素是形式如下的结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> sem_num; <span class="comment">//代表在哪个信号量上面执行操作</span></span><br><span class="line">    <span class="keyword">short</span> sem_op; <span class="comment">//大于0就把它的值加到信号量值；等于0则检查信号量确定它是否为0，不为0则阻塞；小于0就把信号量的值减去它，如果相减为负值则会一直阻塞直到操作之后不会出现负值</span></span><br><span class="line">    <span class="keyword">short</span> sem_flg; <span class="comment">//可以为IPC_NOWAIT和SEM_UNDO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果存在多个因减小一个信号量值而发生阻塞的进程，它们对该信号量减去的值是一样的，那么当条件允许时无法确定到底哪个进程会首先被允许执行操作。另一方面，如果多个因减小一个信号量值而发生阻塞的进程对该信号量减去的值是不同的，那么会按照先满足条件先服务的顺序来进行。</p>
<p>假设一个进程在调整完一个信号量值（如减小信号量值使之等于0）之后终止了，不管是有意终止还是意外终止。在默认情况下，信号量值将不会发生变化。这样就可能会给其他使用这个信号量的进程带来问题。为避免这种问题的发生，在通过<code>semop()</code>修改一个信号量值时可以使用SEM_UNDO标记。当指定这个标记时，内核会记录信号量操作的效果，然后在进程终止时撤销这个操作。不管进程是正常终止还是非正常终止，撤销操作都会发生。</p>
<h4 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2"></a> 缺点</h4>
<ul>
<li>信号量是通过标识符而不是大多数UNIX I/O 和IPC 所采用的文件描述符来引用的。这使得执行诸如同时等待一个信号量和文件描述符的输入之类的操作就会变得比较困难。</li>
<li>使用键而不是文件名来标识信号量增加了额外的编程复杂度。</li>
<li>创建和初始化信号量需要使用单独的系统调用意味着在一些情况下必须要做一些额外的编程工作来防止在初始化一个信号量时出现竞争条件。</li>
<li>内核不会维护引用一个信号量集的进程数量。这就给确定何时删除一个信号量集增加了难度，并且难以确保一个不再使用的信号量集会被删除。</li>
<li>System V 提供的编程接口过于复杂。在通常情况下，一个程序只会操作一个信号量。同时操作集合中多个信号量的能力有时侯是多余的。</li>
<li>信号量的操作存在诸多限制。这些限制是可配置的，但如果一个应用程序超出了默认限制的范围，那么在安装应用程序时就需要完成额外的工作。</li>
</ul>
<h3 id="共享内存"><a class="markdownIt-Anchor" href="#共享内存"></a> 共享内存</h3>
<h4 id="简介-3"><a class="markdownIt-Anchor" href="#简介-3"></a> 简介</h4>
<p>共享内存允许两个或多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会成为一个进程用户空间内存的一部分，因此这种IPC机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。</p>
<p>另一方面，共享内存这种IPC机制不由内核控制意味着通常需要使用某些同步方法，使得进程不会出现同时访问共享内存的情况。</p>
<p>为使用一个共享内存段通常需要执行下面的步骤。</p>
<ul>
<li>调用 <code>shmget()</code>创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。</li>
<li>使用<code>shmat()</code>来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。</li>
<li>此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由<code>shmat()</code>调用返回的<code>addr</code> 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。</li>
<li>调用<code>shmdt()</code>来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步。</li>
<li>调用<code>shmctl()</code>来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会被销毁。只有一个进程需要执行这一步。</li>
</ul>
<h4 id="创建或打开-3"><a class="markdownIt-Anchor" href="#创建或打开-3"></a> 创建或打开</h4>
<p><code>shmget()</code>系统调用创建一个新的共享内存段或者获取一个既有段的标识符，新创建的内存段中，所有内容会被初始化为0：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>; <span class="comment">//成功则返回共享内存段的标识符，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>key</code>参数是IPC_PRIVATE值或由<code>ftok()</code>生成的键。<code>size</code>代表要分配的字节数，会被提升到最近的系统分页大小的整数倍。<code>shmflg</code>参数用于控制<code>shmget</code>的操作，可以为IPC_CREAT、IPC_EXCL、SHM_HUGETLB（允许使用巨页的共享内存段）、SHM_NORESERVE这四个值进行或运算的结果。</p>
<h4 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h4>
<p><code>shmat()</code>系统调用可以将<code>shmid</code>标识的共享内存段附加到调用进程的虚拟地址空间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span>* shmaddr, <span class="keyword">int</span> shmflg)</span></span>; <span class="comment">//成功则返回共享内存段的地址，失败返回NULL</span></span><br></pre></td></tr></table></figure>
<p><code>shmaddr</code>和<code>shmflg</code>位掩码参数中SHM_RND位的设置控制着段如何被附加上去：</p>
<ul>
<li>如果<code>shmaddr</code>为NULL，那么段会被附加到内核选择的一个合适的地址</li>
<li>如果<code>shmaddr</code>不为NULL，且没有设置SHM_RND，则会被附加到<code>shmaddr</code>指定的地址处，它必须是系统分页大小的倍数</li>
<li>如果<code>shmaddr</code>不为NULL，并且设置了SHM_RND，那么段会被映射到的地址为在<code>shmaddr</code>中提供的地址被舍入到最近的常量SHMLBA（shared memory low boundaryaddress）的倍数。这个常量等于系统分页大小的某个倍数。</li>
</ul>
<p>要附加一个共享内存段以供只读访问，那么就需要在<code>shmflg</code>中指定SHM_RDONLY标记。如果在<code>shmflg</code>中指定了SHM_REMAP，在指定了这个标记之后<code>shmaddr</code>的值不能为NULL。这个标记要求<code>shmat()</code>调用替换起点在<code>shmaddr</code>处长度为共享内存段的长度的任何既有共享内存段或内存映射。</p>
<p>当一个进程不再需要访问一个共享内存段时就可以调用<code>shmdt()</code>，将该段分离出其虚拟地址空间。<code>shmaddr</code>参数标识出了待分离的段，它应该是由之前的<code>shmat()</code>调用返回的一个值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* shmaddr)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>通过<code>fork()</code>创建的子进程会继承其父进程附加的共享内存段。因此，共享内存为父进程和子进程之间的通信提供了一种简单的IPC 方法。</p>
<p>在<code>exec()</code>操作之后，所有附加的共享内存段都会被分离。在进程终止之后共享内存段也会自动被分离。</p>
<h4 id="控制操作"><a class="markdownIt-Anchor" href="#控制操作"></a> 控制操作</h4>
<p><code>shmctl()</code>系统调用在<code>shmid</code>标识的共享内存段上执行一组控制操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds* buf)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p><code>cmd</code>参数规定了待执行的控制操作，<code>buf</code>参数与控制操作有关，只有部分操作需要指定它的值，其余操作可以设为NULL。</p>
<p>可以执行的操作如下：</p>
<ul>
<li>常规控制操作：
<ul>
<li>IPC_RMID：标记这个共享内存段及其关联<code>shmid_ds</code>数据结构以便删除。如果当前没有进程附加该段，那么就会执行删除操作，否则就在所有进程都已经与该段分离（即当<code>shmid_ds</code>数据结构中<code>shm_nattch</code>字段的值为0 时）之后再执行删除操作。</li>
<li>IPC_STAT：将与这个共享内存段关联的<code>shmid_ds</code>数据结构的一个副本放置到<code>buf</code>指向的缓冲区中。</li>
<li>IPC_SET：使用<code>buf</code>指向的缓冲区中的值来更新与这个共享内存段相关联的<code>shmid_ds</code>数据结构中被选中的字段。</li>
</ul>
</li>
<li>加锁和解锁共享内存：
<ul>
<li>SHM_LOCK：操作将一个共享内存段锁进内存。</li>
<li>SHM_UNLOCK：操作为共享内存段解锁以允许它被交换出去。</li>
</ul>
</li>
</ul>
<h4 id="共享内存关联数据结构"><a class="markdownIt-Anchor" href="#共享内存关联数据结构"></a> 共享内存关联数据结构</h4>
<p>每个共享内存段都有一个关联的<code>shmid_ds</code>数据结构，其形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span> <span class="comment">//所有权和权限</span></span><br><span class="line">    <span class="keyword">size_t</span> shm_segsz; <span class="comment">//共享内存段所需要的字节数，即shmget()调用中size的值</span></span><br><span class="line">    <span class="keyword">time_t</span> shm_atime; <span class="comment">//在创建共享内存段时会将这个字段设置为0，当一个进程附加该段时会将这个字段设置为当前时间</span></span><br><span class="line">    <span class="keyword">time_t</span> shm_dtime; <span class="comment">//在创建共享内存段时会将这个字段设置为0，当一个进程与该段分离之后会将这个字段设置为当前时间</span></span><br><span class="line">    <span class="keyword">time_t</span> shm_ctime; <span class="comment">//当段被创建时以及每个成功的IPC_SET操作都会将这个字段设置为当前时间。</span></span><br><span class="line">    <span class="keyword">pid_t</span> shm_cpid; <span class="comment">//被设置成使用shmget()创建这个段的进程ID。</span></span><br><span class="line">    <span class="keyword">pid_t</span> shm_lpid; <span class="comment">//在创建共享内存段时会将这个字段设置为0，后续每个成功的shmat()或shmdt()调用会将这个字段设置成调用进程的ID。</span></span><br><span class="line">    <span class="keyword">shmatt_t</span> shm_nattch; <span class="comment">//统计当前附加该段的进程数。在创建段时会将这个字段初始化为0，然后每次成功的shmat()调用会递增这个字段的值，每次成功的shmdt()调用会递减这个字段的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="posix-ipc"><a class="markdownIt-Anchor" href="#posix-ipc"></a> POSIX IPC</h2>
<h3 id="简介-4"><a class="markdownIt-Anchor" href="#简介-4"></a> 简介</h3>
<p>POSIX.1b实时扩展定义了一组IPC机制，它们与System V IPC 机制类似。这组机制中包括消息队列、信号量和共享内存。它们的编程接口总结如下：</p>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808151956.png" alt="image-20210716155455960" style="zoom:67%;" />
<p>要访问一个POSIX IPC对象就必须要通过某种方式来识别出它。规定的唯一一种用来标识POSIX IPC对象的可移植的方式是使用以斜线打头后面跟着一个或多个非斜线字符的名字，如<code>/myobject</code>。</p>
<h3 id="消息队列-2"><a class="markdownIt-Anchor" href="#消息队列-2"></a> 消息队列</h3>
<h4 id="打开-关闭和断开"><a class="markdownIt-Anchor" href="#打开-关闭和断开"></a> 打开、关闭和断开</h4>
<p>打开一个消息队列可以使用<code>mq_open</code>函数，调用成功则返回一个消息队列描述符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">mqd_t</span> <span class="title">mq_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> oflag, <span class="keyword">mode_t</span> mode, struct mq_attr* attr)</span></span>; <span class="comment">//成功则返回消息队列描述符，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>name</code>参数为消息队列的标识；<code>oflag</code>参数是位掩码，可以包含的值有O_CREAT、O_EXCL、O_RDONLY、O_WRONLY、O_RDWR和O_NONBLOCK；<code>mode</code>参数是一个位掩码，用于指定施加于消息队列的权限，它可取的值与文件上的掩码值一样；<code>attr</code>参数指定了新消息队列的特性，如果使用NULL则使用默认特性创建队列。</p>
<p>消息队列描述符和打开着的消息队列之间的关系，与文件描述符和打开着的文件描述符之间的关系类似。消息队列描述符是一个进程级别的句柄，它引用了系统中打开着的消息队列描述表中的一个条目，而该条目则引用了一个消息队列对象。</p>
<p>在<code>fork()</code>中，子进程会接收其父进程的消息队列描述符的副本，并且这些描述符会引用同样的打开着的消息队列描述符。当一个进程执行了一个<code>exec()</code>或终止时，所有其打开的消息队列描述符会被关闭。</p>
<p>消息队列的关闭使用<code>mq_close</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_close</span><span class="params">(<span class="keyword">mqd_t</span> mqdes)</span></span>; <span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p>关闭一个消息队列并不会删除该队列。要删除队列则需要使用<code>mq_unlink()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>; <span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>
<h4 id="消息队列特性"><a class="markdownIt-Anchor" href="#消息队列特性"></a> 消息队列特性</h4>
<p>消息队列所具有的特性被保存在<code>mq_attr</code>结构中，它的形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mq_attr</span>&#123;</span></span><br><span class="line">	<span class="keyword">long</span> mq_flags; <span class="comment">//消息队列特性标识符</span></span><br><span class="line">    <span class="keyword">long</span> mq_maxmsg; <span class="comment">//消息队列中最大的信息数量</span></span><br><span class="line">    <span class="keyword">long</span> mq_msgsize; <span class="comment">//消息队列中每条信息大小上限</span></span><br><span class="line">    <span class="keyword">long</span> mq_curmsgs; <span class="comment">//消息队列中目前的消息数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要获取一个消息队列的信息，可以使用<code>mq_getattr()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_getattr</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, struct mq_attr* attr)</span></span>; <span class="comment">//返回0代表成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>要修改消息队列特性，可以使用<code>mq_setattr()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_setattr</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> struct mq_attr* newattr, struct mq_attr* oldattr)</span></span>; <span class="comment">//返回0代表成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<h4 id="交换消息"><a class="markdownIt-Anchor" href="#交换消息"></a> 交换消息</h4>
<p>要发送消息到消息队列，可以使用<code>mq_send</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_send</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> <span class="keyword">char</span>* msg_ptr, <span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> <span class="keyword">int</span> msg_prio)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>msg_len</code>指定了<code>msg_ptr</code>指向的消息的长度，其值必须小于或等于队列的<code>mq_msgsize</code>特性，否则会返回EMSGSIZE错误。<code>msg_prio</code>表示消息的优先级，消息在队列中是按照优先级的倒序排列，0表示优先级最低。</p>
<p>如果消息队列已经满了（即已经达到了队列的<code>mq_maxmsg</code>限制），那么后续的<code>mq_send()</code>调用会阻塞直到队列中存在可用空间为止，或者在O_NONBLOCK标记起作用时立即失败并返回EAGAIN错误。</p>
<p><code>mq_receive</code>函数从<code>mqdes</code>引用的消息队列中删除一条优先级最高、存在时间最长的消息，并把删除的消息放置在<code>msg_ptr</code>指向的缓冲区：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">mq_receive</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">char</span>* msg_ptr, <span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> <span class="keyword">int</span>* msg_prio)</span></span>; <span class="comment">//成功则返回接收的字节数，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p>不管消息的实际大小是什么，<code>msg_len</code>（即<code>msg_ptr</code>指向的缓冲区的大小）必须要大于或等于队列的<code>mq_msgsize</code>特性，否则<code>mq_receive()</code>就会失败并返回EMSGSIZE错误。如果<code>msg_prio</code>不为NULL，那么接收到的消息的优先级会被复制到<code>msg_prio</code>指向的位置处。</p>
<p>如果消息队列当前为空，那么<code>mq_receive()</code>会阻塞直到存在可用的消息，或在O_NONBLOCK标记起作用时会立即失败并返回EAGAIN 错误。</p>
<p>如果要为发送和接收消息设置超时时间，则可以使用下面的两个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_timedsend</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> <span class="keyword">char</span>* msg_ptr, <span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> <span class="keyword">int</span> msg_prio, <span class="keyword">const</span> struct timespec* abs_timeout)</span></span>; <span class="comment">//成功则返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">mq_timedreceive</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">char</span>* msg_ptr, <span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> <span class="keyword">int</span>* msg_prio, <span class="keyword">const</span> struct timespec* abs_timeout)</span></span>; <span class="comment">//成功则返回接收的字节数，失败返回-1</span></span><br></pre></td></tr></table></figure>
<h4 id="消息通知"><a class="markdownIt-Anchor" href="#消息通知"></a> 消息通知</h4>
<p>POSIX 消息队列能够接收之前为空的队列上有可用消息的异步通知（即队列从空变成了非空）。这个特性意味着已经无需执行一个阻塞的调用，或将消息队列描述符标记为非阻塞并在队列上定期执行<code>mq_receive()</code>调用。进程可以选择通过信号的形式，或通过在一个单独的线程中调用一个函数的形式来接收通知。</p>
<p><code>mq_notify</code>函数使得调用进程在消息描述符<code>mqdes</code>引用的空队列有一条消息进入时，可以接收到通知：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_notify</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> struct sigevent* notification)</span></span>; <span class="comment">//成功则返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>notification</code>参数指定了进程接收通知的机制。</p>
<p>关于消息通知需要注意以下几点：</p>
<ul>
<li>在任何一个时刻都只有一个进程（“注册进程”）能够向一个特定的消息队列注册接收通知。也就是说一个消息队列只能接受一个进程的注册，只给该进程发送通知</li>
<li>只有当一条新消息进入之前为空的队列时，注册进程才会收到通知</li>
<li>当向注册进程发送了一个通知之后就会删除注册信息</li>
<li>只有当前不存在其他在该队列上调用<code>mq_receive()</code>而发生阻塞的进程时，注册进程才会收到通知。</li>
<li>一个进程可以通过在调用<code>mq_notify()</code>时传入一个值为NULL的<code>notification</code>参数，撤销自己在消息通知上的注册信息。</li>
</ul>
<h4 id="posix和system-v消息队列比较"><a class="markdownIt-Anchor" href="#posix和system-v消息队列比较"></a> POSIX和System V消息队列比较</h4>
<p>POSIX消息队列有如下优势：</p>
<ul>
<li>接口简单，且与传统的UNIX文件模型一致</li>
<li>使用引用计数，简化了确定何时删除一个对象的任务</li>
<li>消息通知特性允许一个（单个）进程能够在一条消息进入之前为空的队列时异步地通过信号或线程的实例化来接收通知。</li>
<li>在 Linux（不包括其他UNIX 实现）上可以使用<code>poll()</code>、<code>select()</code>以及<code>epoll</code>来监控POSIX消息队列</li>
</ul>
<p>但是POSIX消息队列也有一些劣势：</p>
<ul>
<li>可移植性稍差</li>
<li>POSIX消息队列严格按照优先级排序，不能像System V消息队列按照类型选择消息</li>
</ul>
<h3 id="信号量-2"><a class="markdownIt-Anchor" href="#信号量-2"></a> 信号量</h3>
<h4 id="概述-12"><a class="markdownIt-Anchor" href="#概述-12"></a> 概述</h4>
<p>POSIX信号量有两种：</p>
<ul>
<li>命名信号量：这种信号量拥有一个名字。通过使用相同的名字调用<code>sem_open()</code>，不相关的进程能够访问同一个信号量。</li>
<li>未命名信号量：这种信号量没有名字，相反，它位于内存中一个预先商定的位置处。未命名信号量可以在进程之间或一组线程之间共享。当在进程之间共享时，信号量必须位于一个共享内存区域中（System V、POSIX或<code>mmap()</code>）。当在线程之间共享时，信号量可以位于被这些线程共享的一块内存区域中（如在堆上或在一个全局变量中）。</li>
</ul>
<p>POSIX信号量的运作方式与System V信号量类似，即POSIX信号量是一个整数，其值是不能小于0 的。如果一个进程试图将一个信号量的值减小到小于0，那么取决于所使用的函数，调用会阻塞或返回一个表明当前无法执行相应操作的错误。</p>
<h4 id="命名信号量"><a class="markdownIt-Anchor" href="#命名信号量"></a> 命名信号量</h4>
<p>下列函数用于命名信号量的使用过程：</p>
<ul>
<li><code>sem_open()</code>函数打开或创建一个信号量并返回一个句柄以供后续调用使用，如果这个调用会创建信号量的话，还会对所创建的信号量进行初始化。</li>
<li><code>sem_post(sem)</code>和<code>sem_wait(sem)</code>函数分别递增和递减一个信号量值。</li>
<li><code>sem_getvalue()</code>函数获取一个信号量的当前值。</li>
<li><code>sem_close()</code>函数删除调用进程与它之前打开的一个信号量之间的关联关系。</li>
<li><code>sem_unlink()</code>函数删除一个命名信号量，并将其标记为在所有进程关闭该信号量时删除该信号量。</li>
</ul>
<p>打开命名信号量<code>sem_open()</code>函数的使用方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sem_t</span>* <span class="title">sem_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> oflag, <span class="keyword">mode_t</span> mode, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>; <span class="comment">//成功则返回信号量的一个指针，失败返回NULL</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>name</code>为信号量的名称，<code>oflag</code>参数是一个位掩码，它确定是打开一个已有的信号量（将<code>oflag</code>设置为0）还是创建并打开一个新的信号量（<code>oflag</code>的值为O_CREAT且<code>name</code>对应的信号量不存在）。如果这一函数被用来打开一个既有信号量，则调用时只需要传入<code>name</code>和<code>oflag</code>参数；如果要创建一个新的信号量，则还需要指定<code>mode</code>和<code>value</code>参数。其中<code>mode</code>是一个位掩码，指定了新信号量的权限，它可取的值与文件上的位值一样；<code>value</code>是一个无符号整数，指定了信号量的初始值。</p>
<p>当一个进程打开一个命名信号量时，系统会记录进程与信号量之间的关联关系。<code>sem_close()</code>函数会终止这种关联关系（即关闭信号量），释放系统为该进程关联到该信号量之上的所有资源，并递减引用该信号量的进程数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_close</span><span class="params">(<span class="keyword">sem_t</span>* sem)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>打开的命名信号量在进程终止或进程执行了一个<code>exec()</code>时会自动被关闭。</p>
<p>关闭一个信号量并不会删除这个信号量，而要删除信号量则需要使用<code>sem_unlink()</code>。<code>name</code>标识的信号量将会在所有进程都使用完这个信号量时就被销毁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<h4 id="信号量操作-2"><a class="markdownIt-Anchor" href="#信号量操作-2"></a> 信号量操作</h4>
<p>要等待一个信号量，可以使用下面的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span>* sem)</span></span>; <span class="comment">//如果信号量的值大于0，则函数立即返回，并将信号量的值减1；如果信号量等于0则会一直阻塞，直到信号量的值大于0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span>* sem)</span></span>; <span class="comment">//非阻塞版本，如果递减操作无法被立即执行则返回EAGAIN错误</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_timedwait</span><span class="params">(<span class="keyword">sem_t</span>* sem, <span class="keyword">const</span> struct timespec* abs_timeout)</span></span>; <span class="comment">//设定阻塞的时间限制，如果到达时间限制之后仍无法递减信号量，则返回ETIMEDOUT错误</span></span><br><span class="line"><span class="comment">//上面的函数返回0表示成功，返回-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>要发布一个信号量则可以使用<code>sem_post()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span>* sem)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p><code>sem_post()</code>调用会将<code>sem</code>引用信号量的值加1。如果在<code>sem_post</code>调用之前信号量的值为0，并且其它某个进程或者线程因等待递减这个信号量而阻塞，则等待进程会被唤醒。哪个等待进程会被唤醒与系统的调度策略有关。</p>
<p>要获取信号量的当前值，则可以使用<code>sem_getvalue()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_getvalue</span><span class="params">(<span class="keyword">sem_t</span>* sem, <span class="keyword">int</span>* sval)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>这一函数调用会将<code>sem</code>引用的信号量的当前值通过<code>sval</code>指向的变量返回。如果一个或多个进程（或线程）当前正在阻塞以等待递减信号量值，那么<code>sval</code>中的返回值将取决于实现，在Linux系统中会返回0。</p>
<h4 id="未命名信号量"><a class="markdownIt-Anchor" href="#未命名信号量"></a> 未命名信号量</h4>
<p>未命名信号量（也被称为基于内存的信号量）是类型为<code>sem_t</code>并存储在应用程序分配的内存中的变量。通过将这个信号量放在由几个进程或线程共性的内存区域中就能够使这个信号量对这些进程或线程可用。</p>
<p>操作未命名信号量所使用的函数与操作命名信号量使用的函数是一样的，除此之外还需要使用<code>sem_init()</code>和<code>sem_destroy(sem)</code>两个函数。</p>
<p><code>sem_init()</code>使用<code>value</code>参数指定的值，来对<code>sem</code>指向的未命名信号量进行初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span>* sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p><code>pshared</code>参数表明信号量是在线程还是进程间共享。如果<code>pshared</code>等于0，那么信号量将会在调用进程中的线程间进行共享。在这种情况下，<code>sem</code>通常被指定成一个全局变量的地址或分配在堆上的一个变量的地址。线程共享的信号量具备进程持久性，它在进程终止时会被销毁；如果<code>pshared</code>不等于0，那么信号量将会在进程间共享。在这种情况下，<code>sem</code>必须是共享内存区域（一个POSIX 共享内存对象、一个使用<code>mmap()</code>创建的共享映射、或一个System V共享内存段）中的某个位置的地址。</p>
<p>要销毁未命名信号量，则需要使用<code>sem_destroy()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span>* sem)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>这一函数将会销毁信号量<code>sem</code>，其中<code>sem</code>必须是一个之前使用<code>sem_init()</code>进行初始化的未命名信号量。只有不存在进程或者线程在等待一个信号量时，才能安全销毁这个信号量。</p>
<h3 id="共享内存-2"><a class="markdownIt-Anchor" href="#共享内存-2"></a> 共享内存</h3>
<h4 id="概述-13"><a class="markdownIt-Anchor" href="#概述-13"></a> 概述</h4>
<p>POSIX共享内存能够让无关进程共享一个映射区域而无需创建一个相应的映射文件。要使用 POSIX 共享内存对象需要完成下列任务。</p>
<ol>
<li>使用<code>shm_open()</code>函数打开一个与指定的名字对应的对象。<code>shm_open()</code>函数与<code>open()</code>系统调用类似，它会创建一个新共享对象或打开一个既有对象。<code>shm_open()</code>会返回一个引用该对象的文件描述符。</li>
<li>将上一步中获得的文件描述符传入<code>mmap()</code>调用并在其<code>flags</code>参数中指定MAP_SHARED。这会将共享内存对象映射进进程的虚拟地址空间。与<code>mmap()</code>的其他用法一样，一旦映射了对象之后就能够关闭该文件描述符而不会影响到这个映射。</li>
</ol>
<h4 id="创建共享内存对象"><a class="markdownIt-Anchor" href="#创建共享内存对象"></a> 创建共享内存对象</h4>
<p>创建一个共享内存对象的方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shm_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> oflag, <span class="keyword">mode_t</span> mode)</span></span>; <span class="comment">//成功则返回文件描述符，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>name</code>参数代表待创建或者打开的共享内存对象；<code>oflag</code>参数用于改变调用行为，可以对下面几个值取或运算：O_CREAT（如果对象不存在则创建对象）、O_EXCL（确保调用者是对象的创建者）、O_RDONLY（打开只读访问）、O_RDWR（打开读写访问）、O_TRUNC（将对象长度截断为0）。在一个新共享内存对象被创建时，其所有权和组所有权将根据调用<code>shm_open()</code>的进程的有效用户和组ID来设定，对象权限将会根据<code>mode</code>参数中设置的掩码值来设定。<code>mode</code>参数能取的位值与文件上的权限位值是一样的。</p>
<p><code>shm_open()</code>返回的文件描述符会设置<code>close-on-exec</code>标记，因此当程序执行了一个<code>exec()</code>时文件描述符会被自动关闭。</p>
<p>一个新共享内存对象被创建时其初始长度会被设置为0。这意味着在创建完一个新共享内存对象之后通常在调用<code>mmap()</code>之前需要调用<code>ftruncate()</code>来设置对象的大小，以及后续使用<code>ftruncate()</code>来扩大或者收缩共享内存对象。在扩展一个共享内存对象时，新增加的字节会被自动初始化为0。</p>
<p>在任何时候都可以在<code>shm_open()</code>返回的文件描述符上使用<code>fstat()</code>以获取一个<code>stat</code>结构，该结构的字段会包含与这个共享内存对象相关的信息。使用<code>fchmod()</code>和<code>fchown()</code>能够分别修改共享内存对象的权限和所有权。</p>
<h4 id="删除共享内存对象"><a class="markdownIt-Anchor" href="#删除共享内存对象"></a> 删除共享内存对象</h4>
<p>POSIX共享内存对象至少具备内核持久性，即它们会持续存在直到被显式删除或系统重启。当不再需要一个共享内存对象时就应该使用<code>shm_unlink()</code>删除它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shm_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p><code>shm_unlink()</code>函数会删除通过<code>name</code>指定的共享内存对象。删除一个共享内存对象不会影响对象的既有映射（它会保持有效直到相应的进程调用<code>munmap()</code>或终止），但会阻止后续的<code>shm_open()</code>调用打开这个对象。一旦所有进程都解除映射这个对象，对象就会被删除，其中的内容会丢失。</p>
<h2 id="socket"><a class="markdownIt-Anchor" href="#socket"></a> SOCKET</h2>
<h3 id="简介-5"><a class="markdownIt-Anchor" href="#简介-5"></a> 简介</h3>
<p>socket是一种IPC方法，它允许位于同一主机（计算机）或使用网络连接起来的不同主机上的应用程序之间交换数据。在一个典型的客户端/服务器场景中，应用程序使用socket进行通信的方式如下：</p>
<ul>
<li>各个应用程序创建一个socket</li>
<li>服务器将自己的socket绑定到一个地址上，使得客户端可以定位到它的位置</li>
</ul>
<p>socket存在于一个通信domain中，它确定了识别出一个socket的方法，并确定其通信范围。现代操作系统至少支持UNIX、IPv4和IPv6这三个domain。它们的区别如下图：</p>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808152010.png" alt="image-20210719145219281" style="zoom:67%;" />
<p>每一个socket实现都至少提供了流和数据报这两种类型。流socket提供了一个可靠的双向字节流通信信道，可以保证发送的数据完整地到达接收端，但是数据不存在消息边界的概念。它类似于使用一对允许在两个应用程序之间双向通信的管道，但是socket允许在网络上进行通信。流socket的正常工作需要一对相互连接的socket，因此它也常常被称为面向连接的。</p>
<p>而数据报socket则允许数据以数据报的消息形式进行交换，因此数据的消息边界被保留下来。但是这种方式的数据传输是不可靠的，消息到达可能是无序的、重复的甚至无法到达。它属于无连接的socket。</p>
<h3 id="系统调用-2"><a class="markdownIt-Anchor" href="#系统调用-2"></a> 系统调用</h3>
<p>要创建一个socket，可以使用<code>socket()</code>系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>; <span class="comment">//成功则返回一个文件描述符，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p>其中<code>domain</code>参数指定了socket的通信domain；<code>type</code>参数指定了socket类型，创建流socket时为SOCK_STREAM，创建数据报socket时被设为SOCK_DGRAM；<code>protocol</code>参数通常被设置为0。</p>
<p>如果要将一个socket绑定到一个地址上，则可以使用<code>bind()</code>系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* addr, <span class="keyword">socklen_t</span> addrlen)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>sockfd</code>参数是一个<code>socket()</code>调用获得的文件描述符，<code>addr</code>参数为一个指针，指向socket绑定的地址的结构，这个数据结构类型取决于socket domain。<code>addrlen</code>参数则指定了地址结构数据的大小。一般来说，会将一个服务器的socket绑定到一个众所周知的地址，这个地址是固定的，且客户端应用程序提前知道。</p>
<p><code>sockaddr</code>数据结构的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family; <span class="comment">//即AF_*，代表socket的domain</span></span><br><span class="line">    <span class="keyword">char</span>* sa_data; <span class="comment">//socket地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要关闭一个socket，则可以使用<code>close()</code>函数，这会将双向通信通道的两端全部关闭。如果要实现更精确的控制，则可以使用<code>shutdown()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> how)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>how</code>参数的值可以为如下几种：</p>
<ul>
<li>SHUT_RD：关闭连接的读端，之后的读操作将会返回文件结尾</li>
<li>SHUT_WR：关闭连接的写端，后续再执行写操作则会产生SIGPIPE信号以及EPIPE错误</li>
<li>SHUT_RDWR：将连接的读写端全部关闭</li>
</ul>
<p>需要注意的是，<code>shutdown()</code>并不会关闭文件描述符，必须调用<code>close()</code>关闭。</p>
<h3 id="流socket"><a class="markdownIt-Anchor" href="#流socket"></a> 流socket</h3>
<p>流socket的运作原理如下：</p>
<ol>
<li><code>socket()</code>系统调用将会创建一个socket，这相当于安装一个电话。为了使得两个应用程序能够通信，每个应用程序都必须要创建一个socket。</li>
<li>一个应用程序在进行通信之前必须要将其socket连接到另一个应用程序的socket上。两个socket的连接过程如下：
<ol>
<li>一个应用程序调用<code>bind()</code>将socket绑定到一个地址上，然后调用<code>listen()</code>通知内核它接受接入连接的意愿。</li>
<li>其它应用程序通过调用<code>connect()</code>建立连接，同时指定需要连接的socket地址</li>
<li>调用<code>listen()</code>的应用程序使用<code>accept()</code>接受连接。如果在对等应用程序调用<code>connect()</code>之前执行了<code>accept()</code>，那么<code>accept()</code>操作会阻塞。</li>
</ol>
</li>
<li>一旦建立了一个连接之后，就可以在应用程序之间进行双向数据传输，直到其中一个使用<code>close()</code>关闭连接为止。通信是通过传统的<code>read()</code>和<code>write()</code>系统调用，或通过一些提供了额外功能的socket特定系统调用（如<code>send()</code>和<code>recv()</code>）来完成的。</li>
</ol>
<p>流socket通常可以分为主动和被动两种。在默认情况下，使用<code>socket()</code>创建的socket是主动的。一个主动的socket可用在<code>connect()</code>调用中，来建立一个到被动socket的连接。而一个被动socket（也被称为监听socket）是一个通过调用<code>listen()</code>以被标记成允许接入连接的socket。在大多数使用流socket的应用程序中，服务器会执行被动式打开，而客户端会执行主动式打开。</p>
<p>这一过程中涉及到的系统调用包括：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* addr, <span class="keyword">socklen_t</span>* addrlen)</span></span>; <span class="comment">//成功则返回文件描述符，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* addr, <span class="keyword">socklen_t</span> addrlen)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<h3 id="数据报socket"><a class="markdownIt-Anchor" href="#数据报socket"></a> 数据报socket</h3>
<p>数据报socket的运作原理如下：</p>
<ol>
<li>所有需要发送和接收数据报的应用程序都需要使用<code>socket()</code>创建一个数据报socket。这可以理解为创建两个邮箱。</li>
<li>为允许另一个应用程序发送其数据报，一个应用程序需要使用<code>bind()</code>将其socket绑定到一个众所周知的地址上。一般来讲，一个服务器会将其socket绑定到一个众所周知的地址上，而一个客户端会通过向该地址发送一个数据报来发起通信。</li>
<li>要发送一个数据报，一个应用程序需要调用<code>sendto()</code>，它接收的其中一个参数是数据报发送到的socket的地址。</li>
<li>为接收一个数据报，一个应用程序需要调用<code>recvfrom()</code>，它在没有数据报到达时会阻塞。由于<code>recvfrom()</code>允许获取发送者的地址，因此可以在需要的时候发送一个响应。</li>
<li>当不再需要socket时，应用程序需要使用<code>close()</code>关闭socket。</li>
</ol>
<p>其中涉及到的系统调用有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buffer, <span class="keyword">size_t</span> length, <span class="keyword">int</span> flags, struct sockaddr* src_addr, <span class="keyword">socklen_t</span>* addrlen)</span></span>; <span class="comment">//成功则返回接收的字节数，如果返回0则代表EOF，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>* buffer, <span class="keyword">size_t</span> length, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr* dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>; <span class="comment">//成功返回发送的字节数，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p>其中<code>flags</code>是一个位掩码，控制socket特定的I/O特性。对于<code>recvfrom</code>函数来说，如果不关心发送者的地址，那么可以将<code>src_addr</code>和<code>addrlen</code>都指定为NULL，此时等价于使用<code>recv()</code>来接收一个数据报。</p>
<p>不管<code>length</code>的参数值是什么，<code>recvfrom()</code>只会从一个数据报socket中读取一条消息。如果消息的大小超过了length字节，那么消息会被静默地截断为length字节。</p>
<h3 id="unix-domain"><a class="markdownIt-Anchor" href="#unix-domain"></a> UNIX domain</h3>
<p>在UNIX domain中，socket地址使用路径名来表示，地址结构的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span>&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sun_family; <span class="comment">//总是等于AF_UNIX</span></span><br><span class="line">    <span class="keyword">char</span> sun_path[<span class="number">108</span>]; <span class="comment">//以NULL结尾的字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于UNIX domain socket的使用需要注意：</p>
<ul>
<li>无法将一个socket绑定到一个既有路径名上（<code>bind()</code>会失败并返回EADDRINUSE 错误）。通常会将一个socket绑定到一个绝对路径名上，这样这个socket就会位于文件系统中的一个固定地址处</li>
<li>一个socket只能绑定到一个路径名上，相应地，一个路径名只能被一个socket绑定</li>
<li>无法使用<code>open()</code>打开一个socket</li>
<li>当不再需要一个socket时，可以使用<code>unlink()</code>（或<code>remove()</code>）删除其路径名条目</li>
</ul>
<p>对于UNIX domain socket来讲，数据报的传输是在内核中发生的，并且也是可靠的。所有消息都会按顺序被递送，并且也不会发生重复的状况。</p>
<p>Linux 特有的一项特性是，它允许将一个UNIX domain socket绑定到一个名字上，但不会在文件系统中创建该名字。要创建一个抽象绑定，就需要将<code>sun_path</code>字段的第一个字节指定为null字节（\0）。这样就能够将抽象socket名字与传统的UNIX domain socket路径名区分开来。余下的字节为socket定义了抽象名称。</p>
<p>socket文件的所有权和权限决定了哪些进程能够与这个socket进行通信。</p>
<ul>
<li>要连接一个UNIX domain流socket，需要在该socket文件上拥有写权限。</li>
<li>要通过一个UNIX domain数据报socket发送一个数据报，需要在该socket文件上拥有写权限。</li>
<li>此外，需要在存放socket路径名的所有目录上都拥有执行（搜索）权限。</li>
</ul>
<p>有时候需要让单个进程创建一对socket并将它们连接起来。<code>socketpair</code>系统调用可以快捷地实现这一操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> sockfd[<span class="number">2</span>])</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>domain</code>参数必须为AF_UNIX，<code>type</code>可以为SOCK_DGRAM或SOCK_STREAM，<code>protocol</code>参数必须为0，<code>sockfd</code>数组返回引用这两个相互连接socket的文件描述符。</p>
<h3 id="internet-domain"><a class="markdownIt-Anchor" href="#internet-domain"></a> Internet domain</h3>
<p>Internet domain流socket是基于TCP之上的，它们提供了可靠的双向字节流通信信道。而Internet domain数据报socket是基于UDP之上的，它属于不可靠连接。Internet domain socket的地址有IPv4和IPv6两种，它们分别对应的数据结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family; <span class="comment">//总为AF_INET</span></span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port; <span class="comment">//网络字节序的端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">//地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> __pad[X]; <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span> s_addr; <span class="comment">//无符号的32位整数，代表IPv4的4字节地址，需要转为网络字节序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span>&#123;</span></span><br><span class="line">	<span class="keyword">sa_family_t</span> sin6_family; <span class="comment">//总为AF_INET6</span></span><br><span class="line">    <span class="keyword">in_port_t</span> sin6_port; <span class="comment">//端口号</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_flowinfo; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span> <span class="comment">//地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_scope_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> s6_addr[<span class="number">16</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用通用的<code>sockaddr_storage</code>结构，这个数据结构的空间足以存储任意类型的socket地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ss_aligntype uint32_t</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span>&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> ss_family;</span><br><span class="line">    __ss_aligntype __ss_align;</span><br><span class="line">    <span class="keyword">char</span> __ss_padding[SS_PADSIZE];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于IP地址在计算机中被存储为二进制形式，不方便阅读，下面两个函数可以方便将IPv4和IPv6地址的二进制形式和点分十进制表示法或者十六进制字符串表示法之间转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">char</span>* src_str, <span class="keyword">void</span>* addrptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">void</span>* addrptr, <span class="keyword">char</span>* dst_str, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>inet_pton()</code>用于将<code>src_str</code>中所包含的字符串转换为网络字节序的二进制IP地址，<code>domain</code>参数为AF_INET或者AF_INET6，转换得到的地址会被放在<code>addrptr</code>指向的结构中；而<code>inet_ntop()</code>函数执行逆向的转换，<code>addrptr</code>指向一个待转换的<code>in_addr</code>或者<code>in_addr6</code>结构，得到的字符串会被存放在<code>dst_str</code>指向的缓冲区中，<code>len</code>参数为缓冲区的大小。如果<code>len</code>的值太小，不足以存放转换后的地址，那么函数会返回NULL并将errno设置为ENOSPC。</p>
<p>为了正确计算缓冲区大小，可以使用下面两个常量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INET_ADDRSTRLEN 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INET6_ADDRSTRLEN 46</span></span><br></pre></td></tr></table></figure>
<p>一个多字节的整数可能会以大端序或者小端序这两种不同的顺序来存储。在特定主机上使用的字节序称为主机字节序，它与硬件架构有关；而在网络中传递的顺序被称为网络字节序，它被规定为大端序。因此，在将整数存储进socket地址结构之前则需要将这些值转换成网络字节序，可以使用下面四个函数完成这一操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> host_uint16)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unit32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> host_uint32)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> net_uint16)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> net_uint32)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="其它用法"><a class="markdownIt-Anchor" href="#其它用法"></a> 其它用法</h3>
<p><code>recv()</code>和<code>send()</code>这一组系统调用可以在已连接的套接字上执行I/O操作，它们提供了专属于套接字的功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buffer, <span class="keyword">size_t</span> length, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>* buffer, <span class="keyword">size_t</span> length, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，前3个参数于<code>read()</code>和<code>write()</code>一样，最后一个参数为位掩码，用于修改I/O操作的行为。</p>
<p>对于<code>recv</code>函数，<code>flags</code>可以取下面的值：</p>
<ul>
<li>MSG_DONTWAIT：让<code>recv</code>以非阻塞方式执行，如果没有数据可用则立即返回并生成错误码EAGAIN</li>
<li>MSG_OOB：在套接字上接收带外数据，带外数据指的是允许发送端将传输的数据标记为高优先级。任意时刻最多只有1字节数据可以被标记为带外数据。</li>
<li>MSG_PEEK：从套接字缓冲区中获取一份请求字节的副本，但不会将请求的字节从缓冲区中实际移除</li>
<li>MSG_WAITALL：如果无法接收<code>length</code>字节则会阻塞，直到可以从缓冲区接收<code>length</code>字节的数据</li>
</ul>
<p>而对于<code>send</code>函数，<code>flags</code>可以取下面的值：</p>
<ul>
<li>MSG_DONTWAIT：以非阻塞方式执行，如果没有数据可用则立即返回并生成错误码EAGAIN</li>
<li>MSG_MORE：在Linux系统下，如果指定了MSG_MORE 标记，那么数据会打包成一个单独的数据报。仅当下一次调用中没有指定该标记时，数据才会传输出去</li>
<li>MSG_NOSIGNAL：当在已连接的流式套接字上发送数据时，如果连接的另一端已经关闭了，指定该标记后将不会产生SIGPIPE信号。相反，<code>send()</code>调用会失败，伴随的错误码为EPIPE。</li>
<li>MSG_OOB：在流式套接字上发送带外数据</li>
</ul>
<p>如果要将磁盘上的文件内容不做修改地传出去，则可以使用<code>sendfile()</code>系统调用。此时，文件内容会被直接传送到套接字上，而不会经过用户空间，因此传输效率更高：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span>* offset, <span class="keyword">size_t</span> count)</span></span>; <span class="comment">//调用成功返回实际传输字节数，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>in_fd</code>代表输入文件描述符，<code>out_fd</code>代表输出文件描述符。要求<code>out_fd</code>必须指向一个套接字，而<code>in_fd</code>指向的文件可以进行<code>mmap()</code>操作。参数<code>offset</code>可以指向一个<code>off_t</code>类型的值，指定输入文件的偏移量，代表<code>in_fd</code>指向的文件从这一位置开始可以传输字节，此时数据传输不会修改<code>in_fd</code>的文件偏移量；也可以设置为NULL，此时会从当前的文件偏移量处开始传输，且传输时会更新文件偏移量。<code>count</code>参数指定了请求传输的字节数。</p>
<p>套接字选项能影响到套接字操作的多个功能。下面两个系统调用可以设定和获取套接字选项：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsocket</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span>* optval, <span class="keyword">socklen_t</span>* optlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsocket</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span>* optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>sockfd</code>代表指向套接字的文件描述符，<code>level</code>代表套接字选项适用的协议，<code>optname</code>标识了希望设定或者取出的套接字选项，<code>optval</code>是一个指向缓冲区的指针，用于指定或者返回选项的值，<code>optlen</code>指定了缓冲区的空间大小。</p>
<h1 id="其它io模型"><a class="markdownIt-Anchor" href="#其它io模型"></a> 其它I/O模型</h1>
<h2 id="概述-14"><a class="markdownIt-Anchor" href="#概述-14"></a> 概述</h2>
<p>由于非阻塞式I/O以及多进程/多线程有各自的局限性，因此一些使用场景下我们需要考虑下面的备选方案：</p>
<ul>
<li>I/O多路复用允许进程同时检查多个文件描述符以找出它们中的任何一个是否可执行I/O操作。系统调用<code>select()</code>和<code>poll()</code>用来执行I/O多路复用。</li>
<li>信号驱动I/O是指当有输入或者数据可以写到指定的文件描述符上时，内核向请求数据的进程发送一个信号。进程可以处理其他的任务，当I/O操作可执行时通过接收信号来获得通知。当同时检查大量的文件描述符时，信号驱动I/O相比<code>select()</code>和<code>poll()</code>有显著的性能提升。</li>
<li>epoll API是Linux专有的特性，同I/O多路复用API一样，epoll API允许进程同时检查多个文件描述符，看其中任意一个是否能执行I/O 操作。同信号驱动I/O一样，当同时检查大量文件描述符时，epoll能提供更好的性能。</li>
</ul>
<p>实际上，I/O多路复用、信号驱动I/O以及epoll都是用来实现同一个目标的技术—同时检查多个文件描述符，看它们是否准备好了执行I/O 操作。但是它们不会执行实际的I/O操作，仍需要使用其它的系统调用来完成I/O操作。</p>
<p>有两种文件描述符准备就绪的通知模式：</p>
<ul>
<li>水平触发通知：如果文件描述符上可以非阻塞地执行 I/O系统调用，此时认为它已经就绪。</li>
<li>边缘触发通知：如果文件描述符自上次状态检查以来有了新的I/O 活动（比如新的输入），此时需要触发通知。</li>
</ul>
<p>epoll API同时支持上述两种通知，信号驱动I/O仅支持边缘触发，多路复用技术仅支持水平触发。</p>
<h2 id="io多路复用"><a class="markdownIt-Anchor" href="#io多路复用"></a> I/O多路复用</h2>
<h3 id="简介-6"><a class="markdownIt-Anchor" href="#简介-6"></a> 简介</h3>
<p>I/O多路复用允许我们同时检查多个文件描述符，看其中任意一个是否可执行I/O操作。我们可以在普通文件、终端、伪终端、管道、FIFO、套接字以及一些其他类型的字符型设备上使用<code>select()</code>和<code>poll()</code>来检查文件描述符。这两个系统调用都允许进程要么一直等待文件描述符成为就绪态，要么在调用中指定一个超时时间。</p>
<h3 id="系统调用-3"><a class="markdownIt-Anchor" href="#系统调用-3"></a> 系统调用</h3>
<p><code>select()</code>系统调用会一直阻塞，直到一个或者多个文件描述符集合成为就绪态：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>; <span class="comment">//成功则返回就绪态的文件描述符个数，超时返回0，失败则返回-1</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>timeout</code>参数设定<code>select</code>阻塞的时间上限，如果设置为NULL则代表一直阻塞；参数<code>nfds</code>通常设为比3个文件描述符集合中所包含的最大文件描述符号还要大1，这个参数让<code>select()</code>变得更有效率；<code>readfds</code>，<code>writefds</code>和<code>exceptfds</code>分别代表检测输入是否就绪，输出是否就绪以及异常情况是否发生的文件描述符集合，它们在<code>select()</code>调用之后会被修改，其中包含处于就绪态的文件描述符集合。</p>
<p>数据类型<code>fd_set</code>通常以位掩码的形式来实现，但是我们无需知道细节，关于文件描述符集合的操作通过如下四个宏来完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set* fdset)</span></span>; <span class="comment">//将fdset指向的集合初始化为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fdset)</span></span>; <span class="comment">//将文件描述符fd添加到fdset指向的集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fdset)</span></span>; <span class="comment">//将文件描述符fd从fdset指向的集合中移除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fdset)</span></span>; <span class="comment">//如果fd是fdset的元素，则返回1；否则返回0</span></span><br></pre></td></tr></table></figure>
<p>如果<code>select()</code>返回一个正数，则代表至少一个文件描述符到达就绪态，此时需要使用<code>FD_ISSET</code>对三个文件描述符集合进行检查。</p>
<p>系统调用<code>poll()</code>执行的任务同<code>select()</code>很相似。两者间主要的区别在于我们要如何指定待检查的文件描述符，<code>poll()</code>系统调用提供一列文件描述符，并在每个文件描述符上标明我们感兴趣的事件。它的用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd fds[], <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;<span class="comment">//成功则返回就绪态的文件描述符个数，超时返回0，失败则返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">//文件描述符</span></span><br><span class="line">    <span class="keyword">short</span> event; <span class="comment">//位掩码，指定为描述符fd做检查的事件</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">//位掩码，函数返回时，它被设定为文件描述符上实际发生的事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>timeout</code>参数决定了<code>poll</code>的阻塞行为，如果它的值为-1则会一直阻塞直到<code>fds</code>中列出的描述符有一个达到就绪态；如果为0则不会阻塞，仅仅是检查是否有处于就绪态的文件描述符；如果大于0则代表阻塞的时间上限（毫秒）。<code>events</code>和<code>fevents</code>参数能够使用的位掩码如下：</p>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808152058.png" alt="image-20210720164004044" style="zoom:67%;" />
<p>随着待检查的文件描述符数量的增加，<code>select()</code>和<code>poll()</code>所占用的CPU时间也会随之增加。对于需要检查大量文件描述符的程序来说，这就产生了问题。而且内核并不会在每次调用成功之后记录下检查的文件描述符，当重复检查相同的文件描述符时会带来糟糕的性能延展性。</p>
<h2 id="信号驱动io"><a class="markdownIt-Anchor" href="#信号驱动io"></a> 信号驱动I/O</h2>
<p>在信号驱动I/O中，当文件描述符上可执行I/O操作时，进程请求内核为自己发送一个信号。之后进程就可以执行任何其他的任务，直到I/O 就绪为止，此时内核会发送信号给进程。要使用信号驱动I/O，程序需要按照如下步骤来执行。</p>
<ol>
<li>为内核发送的通知信号安装一个信号处理例程。默认情况下，这个通知信号为SIGIO。</li>
<li>设定文件描述符的属主，也就是当文件描述符上可执行I/O时会接收到通知信号的进程或进程组。通常我们让调用进程成为属主。设定属主可通过<code>fcntl()</code>的F_SETOWN操作来完成</li>
<li>通过设定O_NONBLOCK标志使能非阻塞I/O。</li>
<li>通过打开O_ASYNC标志使能信号驱动I/O。这可以和上一步合并为一个操作，因为它们都需要用到<code>fcntl()</code>的F_SETFL 操作。</li>
<li>调用进程现在可以执行其他的任务。当I/O操作就绪时，内核为进程发送一个信号，然后调用在第1步中安装好的信号处理例程。</li>
<li>信号驱动I/O提供的是边缘触发通知。这表示一旦进程被通知I/O就绪，它就应该尽可能多地执行I/O（例如尽可能多地读取字节）。假设文件描述符是非阻塞式的，这表示需要在循环中执行I/O系统调用直到失败为止，此时错误码为EAGAIN或EWOULDBLOCK。</li>
</ol>
<p>对于不同的文件类型，发送I/O就绪的时刻也不同：</p>
<ul>
<li>对于终端和伪终端，当产生新的输入时会生成一个输入就绪信号；对于终端则没有输出就绪信号</li>
<li>对于管道和FIFO，读端在数据写入管道或者写端关闭会产生信号；而写端会在读端关闭或者对管道的读操作增加管道的空余空间大小时发送信号</li>
<li>对于数据包套接字，当输入数据报到达或者发生异步错误时会产生信号；对于流式套接字，在监听套接字接收新连接、TCP的<code>connect()</code>请求完成、套接字上接收到了新的输入、输出就绪、异步错误、对端关闭写连接或者完全关闭时会产生信号</li>
<li>由inotify文件描述符监视的其中一个文件上有事件发生时会产生信号</li>
</ul>
<p>在需要同时检查大量文件描述符（比如数千个）的应用程序中，信号驱动I/O可以提供显著的性能优势。</p>
<h2 id="epoll"><a class="markdownIt-Anchor" href="#epoll"></a> epoll</h2>
<p>Linux特有的epoll（event poll）API可以检查多个文件描述符上的I/O 就绪状态。epoll API 的主要优点如下。</p>
<ul>
<li>当检查大量的文件描述符时，epoll的性能延展性比<code>select()</code>和<code>poll()</code>高很多。</li>
<li>epoll API既支持水平触发也支持边缘触发</li>
<li>性能表现上，epoll同信号驱动I/O相似。但是，epoll可以避免复杂的信号处理流程（比如信号队列溢出时的处理），同时灵活性高，可以指定我们希望检查的事件类型</li>
</ul>
<p>epoll API主要包含下面三个系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>; <span class="comment">//成功返回文件描述符，-1表示失败</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event* ev)</span></span>; <span class="comment">//成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* evlist, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>; <span class="comment">//成功则返回就绪态的文件描述符个数，超时返回0，失败则返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>epoll_create</code>用于创建一个新的epoll实例，其中参数<code>size</code>指定了想要通过epoll实例检查的文件描述符个数。如果执行成功，则返回一个代表新创建epoll实例的文件描述符。当这个epoll实例不需要使用时，则可以使用<code>close()</code>将其关闭。当所有与epoll 实例相关的文件描述符都被关闭时，实例被销毁，相关的资源都返还给系统。</p>
<p><code>epoll_ctl</code>能够修改<code>epfd</code>所代表的epoll实例中的兴趣列表。参数<code>fd</code>表示要修改兴趣列表中的哪一个文件描述符的设定，该参数可以是代表管道、FIFO、套接字、POSIX消息队列、inotify实例、终端、设备，甚至是另一个epoll实例的文件描述符，但是不能为普通文件或者目录的文件描述符。参数<code>op</code>用来指定需要执行的操作，可以是EPOLL_CTL_ADD、EPOLL_CTL_MOD或EPOLL_CTL_DEL，分别代表添加、修改和删除。参数<code>ev</code>的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> events; <span class="comment">//位掩码，代表为待检查的文件描述符指定感兴趣的事件集合</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data; <span class="comment">//指定传回给调用进程的信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data&#123;</span><br><span class="line">    <span class="keyword">void</span>* ptr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>
<p><code>epoll_wait</code>返回epoll实例中处于就绪态的文件描述符信息，单次调用就可以返回多个就绪态文件描述符的信息。参数<code>evlist</code>指向的结构体数组中返回的是有关就绪态文件描述符的信息，它的空间需要由调用者负责申请，所包含的元素个数在参数<code>maxevents</code>中指定。在数组<code>evlist</code>中，每个元素返回的都是单个就绪态文件描述符的信息，<code>events</code>字段返回了在该描述符上已经发生的事件掩码，<code>data</code>字段返回的是在描述符上使用<code>epoll_ctl()</code>注册感兴趣的事件时，在<code>ev.data</code>中设置的值，它是唯一可以获知与这个事件相关文件描述符号的途径，因此通常将<code>ev.data.fd</code>置为文件描述符，或者是将<code>ev.data.ptr</code>设为指向包含文件描述符的结构体。<code>timeout</code>参数决定了<code>epoll</code>的阻塞行为，如果它的值为-1则会一直阻塞直到兴趣列表的描述符有一个达到就绪态；如果为0则不会阻塞，仅仅是检查是否有处于就绪态的文件描述符；如果大于0则代表阻塞的时间上限（毫秒）。</p>
<p>在<code>epoll_event</code>结构体中，<code>events</code>字段上的可以使用的位掩码值如下：</p>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210808152106.png" alt="image-20210720171448762" style="zoom:67%;" />
<p>随着被监视的文件描述符数量的上升，<code>poll()</code>和<code>select()</code>的性能表现越来越差。与之相反，epoll的性能表现几乎不会降低。这是因为当通过<code>epoll_ctl()</code>指定了需要监视的文件描述符时，内核会在与打开的文件描述上下文相关联的列表中记录该描述符。之后每当执行I/O操作使得文件描述符成为就绪态时，内核就在epoll描述符的就绪列表中添加一个元素。之后的<code>epoll_wait()</code>调用从就绪列表中简单地取出这些元素。同时，在 epoll中我们使用<code>epoll_ctl()</code>在内核空间中建立一个数据结构，该数据结构会将待监视的文件描述符都记录下来。一旦这个数据结构建立完成，稍后每次调用<code>epoll_wait()</code>时就不需要再传递任何与文件描述符有关的信息给内核了，而调用返回的信息中只包含那些已经处于就绪态的描述符。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Yufei Luo
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://lyf35.github.io/2021/02/25/Linux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%EF%BC%88%E6%91%98%E5%BD%95%EF%BC%89/" title="Linux-系统编程接口（摘录）">http://lyf35.github.io/2021/02/25/Linux-系统编程接口（摘录）/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"><i class="fa fa-tag"></i> Linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A0%B8%E6%96%B9%E6%B3%95/" rel="prev" title="机器学习-核方法">
      <i class="fa fa-chevron-left"></i> 机器学习-核方法
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%8F%90%E5%8D%87%E6%A0%91/" rel="next" title="机器学习-提升树">
      机器学习-提升树 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yufei Luo</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.6m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">23:47</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动
  </div>

        






<script data-pjax>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"ypNNXSdcGIIoldC5BBmViS2g-gzGzoHsz","app_key":"0TDwohU7eO4yHTn4tley8PtE","server_url":"https://leancloud.cn/dashboard/data.html?appid=ypNNXSdcGIIoldC5BBmViS2g-gzGzoHsz#/","security":false};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/next-theme/pjax@0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  
  <script data-pjax>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>









<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>


    <div class="pjax">
  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">
  <script src="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css">


  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4dcdc02d24075b0e9d3a',
      clientSecret: '53cf2cb8b89b9d4bba922bb19bda1290f0d0bf95',
      repo        : 'lyf35.github.io',
      owner       : 'lyf35',
      admin       : ['lyf35'],
      id          : 'b084c73c53cb77dfd3c1ad6d7cef6c19',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
