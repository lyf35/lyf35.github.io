<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">
  <link rel="manifest" href="/images/site.webmanifest">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Helvetica:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-flat-top.min.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lyf35.github.io","root":"/","scheme":"Pisces","version":"8.0.0-rc.5","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="简介 Pandas是一个用来处理表格类型数据的函数库。Pandas的官方文档：http:&#x2F;&#x2F;pandas.pydata.org&#x2F;pandas-docs&#x2F;stable&#x2F; 12import numpy as npimport pandas as pd  数据结构  主要数据结构  Series 一个Series由一个index和与之对应的一系列value组成，相当于是一个单列的表格。它的构造方式有：">
<meta property="og:type" content="article">
<meta property="og:title" content="数据分析-Pandas">
<meta property="og:url" content="http://lyf35.github.io/2021/01/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-Pandas/index.html">
<meta property="og:site_name" content="Yufei Luo&#39;s Blog">
<meta property="og:description" content="简介 Pandas是一个用来处理表格类型数据的函数库。Pandas的官方文档：http:&#x2F;&#x2F;pandas.pydata.org&#x2F;pandas-docs&#x2F;stable&#x2F; 12import numpy as npimport pandas as pd  数据结构  主要数据结构  Series 一个Series由一个index和与之对应的一系列value组成，相当于是一个单列的表格。它的构造方式有：">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-01-09T16:22:20.253Z">
<meta property="article:modified_time" content="2021-01-09T16:22:20.253Z">
<meta property="article:author" content="Yufei Luo">
<meta property="article:tag" content="数据分析">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://lyf35.github.io/2021/01/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-Pandas/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据分析-Pandas | Yufei Luo's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
 <!--   <div class="headband"></div>-->

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Yufei Luo's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">But I was so much older then, I am younger than that now.</p>
      <img class="custom-logo-image" src="/images/logo.png" alt="Yufei Luo's Blog">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text"> 简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text"> 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text"> 主要数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#series"><span class="nav-number">2.1.1.</span> <span class="nav-text"> Series</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dataframe"><span class="nav-number">2.1.2.</span> <span class="nav-text"> DataFrame</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#panel"><span class="nav-number">2.1.3.</span> <span class="nav-text"> Panel</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#index%E5%B1%9E%E6%80%A7"><span class="nav-number">2.2.</span> <span class="nav-text"> index属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B7%E6%9C%89%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E7%9A%84index"><span class="nav-number">2.3.</span> <span class="nav-text"> 具有重复数据的index</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#io%E6%93%8D%E4%BD%9C"><span class="nav-number">3.</span> <span class="nav-text"> IO操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="nav-number">3.1.</span> <span class="nav-text"> 读取文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="nav-number">3.2.</span> <span class="nav-text"> 写入文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%BF%90%E7%AE%97"><span class="nav-number">4.</span> <span class="nav-text"> 基本操作与运算</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#reindex"><span class="nav-number">4.1.</span> <span class="nav-text"> reindex</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">4.2.</span> <span class="nav-text"> 删除操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E7%89%87%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C"><span class="nav-number">4.3.</span> <span class="nav-text"> 切片与索引操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="nav-number">4.4.</span> <span class="nav-text"> 数学运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%B8%8E%E6%98%A0%E5%B0%84"><span class="nav-number">4.5.</span> <span class="nav-text"> 函数与映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">4.6.</span> <span class="nav-text"> 排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E5%87%BD%E6%95%B0"><span class="nav-number">5.</span> <span class="nav-text"> 统计函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97"><span class="nav-number">6.</span> <span class="nav-text"> 数据清洗</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E4%B8%A2%E5%A4%B1%E6%95%B0%E6%8D%AE"><span class="nav-number">6.1.</span> <span class="nav-text"> 处理丢失数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%A4%E5%8E%BB%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE"><span class="nav-number">6.2.</span> <span class="nav-text"> 除去重复数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%B8%8E%E6%98%A0%E5%B0%84-2"><span class="nav-number">6.3.</span> <span class="nav-text"> 函数与映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%9B%BF%E6%8D%A2"><span class="nav-number">6.4.</span> <span class="nav-text"> 数据替换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%91%E6%95%B0%E7%BB%9F%E8%AE%A1"><span class="nav-number">6.5.</span> <span class="nav-text"> 频数统计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dummy%E5%8F%98%E9%87%8F"><span class="nav-number">6.6.</span> <span class="nav-text"> Dummy变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">6.7.</span> <span class="nav-text"> 字符串的处理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E5%B1%82index"><span class="nav-number">7.</span> <span class="nav-text"> 多层index</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E9%87%8D%E6%9E%84%E4%B8%8E%E7%BB%84%E5%90%88"><span class="nav-number">8.</span> <span class="nav-text"> 数据的重构与组合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%89%E5%88%97%E5%90%88%E5%B9%B6"><span class="nav-number">8.1.</span> <span class="nav-text"> 按列合并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%BC%E6%8E%A5"><span class="nav-number">8.2.</span> <span class="nav-text"> 拼接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A1%AB%E5%85%85%E5%BC%8F%E5%90%88%E5%B9%B6"><span class="nav-number">8.3.</span> <span class="nav-text"> 填充式合并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%8E%92%E4%B8%8E%E6%97%8B%E8%BD%AC"><span class="nav-number">8.4.</span> <span class="nav-text"> 重排与旋转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E7%BB%84"><span class="nav-number">9.</span> <span class="nav-text"> 数据的分组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E6%88%90groupby%E5%8F%98%E9%87%8F"><span class="nav-number">9.1.</span> <span class="nav-text"> 生成GroupBy变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#groupby%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">9.2.</span> <span class="nav-text"> GroupBy变量的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AE%B9"><span class="nav-number">9.2.1.</span> <span class="nav-text"> 查看内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">9.2.2.</span> <span class="nav-text"> 索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">9.2.3.</span> <span class="nav-text"> 使用函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%80%8F%E8%A7%86%E8%A1%A8"><span class="nav-number">10.</span> <span class="nav-text"> 数据透视表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">11.</span> <span class="nav-text"> 参考</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yufei Luo"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Yufei Luo</p>
  <div class="site-description" itemprop="description">一个材料专业毕业的野生程序员的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x5ZjM1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lyf35"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmx5ZjEyMzQwMDAwMDBAMTYzLmNvbQ==" title="E-Mail → mailto:lyf1234000000@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



      </section>
        <div class="back-to-top animated">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x5ZjM1" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lyf35.github.io/2021/01/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-Pandas/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Yufei Luo">
      <meta itemprop="description" content="一个材料专业毕业的野生程序员的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yufei Luo's Blog">
    </span>

    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据分析-Pandas
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-10 00:22:20" itemprop="dateCreated datePublished" datetime="2021-01-10T00:22:20+08:00">2021-01-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">数据分析</span></a>
                </span>
            </span>

          
            <span id="/2021/01/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-Pandas/" class="post-meta-item leancloud_visitors" data-flag-title="数据分析-Pandas" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>62k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>56 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<p>Pandas是一个用来处理表格类型数据的函数库。Pandas的官方文档：<span class="exturl" data-url="aHR0cDovL3BhbmRhcy5weWRhdGEub3JnL3BhbmRhcy1kb2NzL3N0YWJsZS8=">http://pandas.pydata.org/pandas-docs/stable/<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<h1 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h1>
<h2 id="主要数据结构"><a class="markdownIt-Anchor" href="#主要数据结构"></a> 主要数据结构</h2>
<h3 id="series"><a class="markdownIt-Anchor" href="#series"></a> Series</h3>
<p>一个Series由一个index和与之对应的一系列value组成，相当于是一个单列的表格。它的构造方式有：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series1=pd.Series(np.array((<span class="number">4</span>,<span class="number">7</span>,<span class="number">-5</span>,<span class="number">3</span>))) <span class="comment">#传入一个list、tuple、或是numpy的一维数组，此时会默认为这些元素添加一个从0到n-1的RangeIndex</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series1</span><br></pre></td></tr></table></figure>
<pre><code>0    4
1    7
2   -5
3    3
dtype: int32
</code></pre>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.Series([<span class="number">2</span>,<span class="number">3</span>,<span class="number">-3</span>,<span class="number">1</span>],index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]) <span class="comment">#Series的构造函数支持传入一个自定义的index</span></span><br></pre></td></tr></table></figure>
<pre><code>a    2
c    3
b   -3
d    1
dtype: int64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict1=&#123;<span class="string">&#x27;Ohio&#x27;</span>: <span class="number">35000</span>, <span class="string">&#x27;Texas&#x27;</span>: <span class="number">71000</span>, <span class="string">&#x27;Oregon&#x27;</span>: <span class="number">16000</span>, <span class="string">&#x27;Utah&#x27;</span>: <span class="number">5000</span>&#125;</span><br><span class="line">states = [<span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.Series(dict1) <span class="comment">#可以传入一个dict来构造Series，map中每个元素的key作为index，并与每个元素的value相对应</span></span><br></pre></td></tr></table></figure>
<pre><code>Ohio      35000
Texas     71000
Oregon    16000
Utah       5000
dtype: int64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.Series(dict1,index=states) <span class="comment">#使用dict构造Series时，同样可以传入index参数，Series中的index便使用传入的index参数。此时，每个index对应的value会从dict中获取，如果某个index在dict没有对应的key-value，那么Series中这个index对应的值为NaN</span></span><br></pre></td></tr></table></figure>
<pre><code>California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
dtype: float64
</code></pre>
<p>一个Series具有以下的属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series1.values <span class="comment">#Series的values属性保存了Series中的数据，value属性为一个numpy的一维数组</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 4,  7, -5,  3])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series1.index <span class="comment">#Series的index属性保存了这些value对应的index</span></span><br></pre></td></tr></table></figure>
<pre><code>RangeIndex(start=0, stop=4, step=1)
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series1.index.name=<span class="string">&#x27;test_series&#x27;</span> <span class="comment">#一个Series的index可以有自己的名字，默认为空。如果加上名字之后，在print这个Series时便可以看到为这个index加上的名字</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series1</span><br></pre></td></tr></table></figure>
<pre><code>test_series
0    4
1    7
2   -5
3    3
dtype: int32
</code></pre>
<h3 id="dataframe"><a class="markdownIt-Anchor" href="#dataframe"></a> DataFrame</h3>
<p>DataFrame数据结构相当于一个表格。也可以理解为一个DataFrame由多个Series拼在一起，其中这些Series具有共同的index。</p>
<p>许多种数据类型都可以被用来构造DataFrame，包括但不限于：</p>
<ul>
<li>二维的array</li>
<li>一个value为array、list或者tuple的dict</li>
<li>一个value为Series的dict</li>
<li>一个value为dict的dict</li>
<li>一个元素为dict或者Series的list</li>
<li>一个元素为list或者tuple的list</li>
<li>另一个DataFrame</li>
</ul>
<p>下面为创建DataFrame的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">&#x27;state&#x27;</span>: [<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>],</span><br><span class="line"><span class="string">&#x27;year&#x27;</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>],</span><br><span class="line"><span class="string">&#x27;pop&#x27;</span>: [<span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">3.6</span>, <span class="number">2.4</span>, <span class="number">2.9</span>]&#125;</span><br><span class="line">dataframe1=pd.DataFrame(data) <span class="comment">#可以传入一个dict，其中每个dict的value为等长的list或tuple，或是numpy的一维数组。在DataFrame中，dict中的key会被作为是column的名称，value则为每列的值，同时自动为这些数据添加一个index。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe1</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>state</th>
      <th>year</th>
      <th>pop</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Ohio</td>
      <td>2000</td>
      <td>1.5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Ohio</td>
      <td>2001</td>
      <td>1.7</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Ohio</td>
      <td>2002</td>
      <td>3.6</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Nevada</td>
      <td>2001</td>
      <td>2.4</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Nevada</td>
      <td>2002</td>
      <td>2.9</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(data, columns=[<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;debt&#x27;</span>],index=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>]) <span class="comment">#在使用dict构造DataFrame时，支持传入columns和index两个可选属性。此时，DataFrame的columns则会设置为传入的columns参数，每个column对应的值会从dict中获得，如果dict中不存在对应的key，则该列的所有值都为空</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>year</th>
      <th>state</th>
      <th>debt</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>one</th>
      <td>2000</td>
      <td>Ohio</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>two</th>
      <td>2001</td>
      <td>Ohio</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>three</th>
      <td>2002</td>
      <td>Ohio</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>four</th>
      <td>2001</td>
      <td>Nevada</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>five</th>
      <td>2002</td>
      <td>Nevada</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data2=&#123;<span class="string">&#x27;Nevada&#x27;</span>: &#123;<span class="number">2001</span>: <span class="number">2.4</span>, <span class="number">2002</span>: <span class="number">2.9</span>&#125;, <span class="string">&#x27;Ohio&#x27;</span>: &#123;<span class="number">2000</span>: <span class="number">1.5</span>, <span class="number">2001</span>: <span class="number">1.7</span>, <span class="number">2003</span>: <span class="number">3.6</span>&#125;&#125;</span><br><span class="line">pd.DataFrame(data2) <span class="comment">#另一种构造DataFrame的方法，同样是传入一个dict，但是这个dict中的value也是一个dict，相当于一个两层嵌套的dict。外层dict中的key会被作为columns的名称，而内层dict的key则被作为index的名称。在最终得到的DataFrame中，index为所有内层dict中的key取并集。如果某个内层dict中，某些index对应的key-value不存在，那么在构造DataFrame时，对应的位置会被设为NaN。</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Nevada</th>
      <th>Ohio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2001</th>
      <td>2.4</td>
      <td>1.7</td>
    </tr>
    <tr>
      <th>2002</th>
      <td>2.9</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2000</th>
      <td>NaN</td>
      <td>1.5</td>
    </tr>
    <tr>
      <th>2003</th>
      <td>NaN</td>
      <td>3.6</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(data2,index=[<span class="number">2000</span>,<span class="number">2001</span>,<span class="number">2002</span>,<span class="number">2004</span>]) <span class="comment">#使用两层嵌套dict构造DataFrame时，支持传入一个index属性，此时DataFrame中使用传入的index。每个index对应的值会在相应的内层dict中索引，如果不存在则为NaN。</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Nevada</th>
      <th>Ohio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2000</th>
      <td>NaN</td>
      <td>1.5</td>
    </tr>
    <tr>
      <th>2001</th>
      <td>2.4</td>
      <td>1.7</td>
    </tr>
    <tr>
      <th>2002</th>
      <td>2.9</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2004</th>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(np.random.rand(<span class="number">5</span>,<span class="number">3</span>)) <span class="comment">#可以传入一个numpy的二维array进行构造</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.860528</td>
      <td>0.190016</td>
      <td>0.355405</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.707203</td>
      <td>0.021066</td>
      <td>0.883826</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.672148</td>
      <td>0.091125</td>
      <td>0.984936</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.816604</td>
      <td>0.672571</td>
      <td>0.421406</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.327092</td>
      <td>0.616550</td>
      <td>0.054370</td>
    </tr>
  </tbody>
</table>
</div>
<p>一个DataFrame具有下面的属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe1.values <span class="comment">#DataFrame也有values属性，它是一个二维的array</span></span><br></pre></td></tr></table></figure>
<pre><code>array([['Ohio', 2000, 1.5],
       ['Ohio', 2001, 1.7],
       ['Ohio', 2002, 3.6],
       ['Nevada', 2001, 2.4],
       ['Nevada', 2002, 2.9]], dtype=object)
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe1.index <span class="comment">#与Series一样，具有index属性</span></span><br></pre></td></tr></table></figure>
<pre><code>RangeIndex(start=0, stop=5, step=1)
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe1.columns <span class="comment">#相比于Series，多了一个columns属性</span></span><br></pre></td></tr></table></figure>
<pre><code>Index(['state', 'year', 'pop'], dtype='object')
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataframe1.index.name=<span class="string">&#x27;test_index&#x27;</span></span><br><span class="line">dataframe1.columns.name=<span class="string">&#x27;test_columns&#x27;</span> <span class="comment">#与Series类似，DataFrame的index和columns也可以有自己的名字</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe1</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>test_columns</th>
      <th>state</th>
      <th>year</th>
      <th>pop</th>
    </tr>
    <tr>
      <th>test_index</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Ohio</td>
      <td>2000</td>
      <td>1.5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Ohio</td>
      <td>2001</td>
      <td>1.7</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Ohio</td>
      <td>2002</td>
      <td>3.6</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Nevada</td>
      <td>2001</td>
      <td>2.4</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Nevada</td>
      <td>2002</td>
      <td>2.9</td>
    </tr>
  </tbody>
</table>
</div>
<h3 id="panel"><a class="markdownIt-Anchor" href="#panel"></a> Panel</h3>
<p>Panel是多个DataFrame的组合，相当于Excel中的一个.xlsx文件（其中包括多张表）。但是在目前的Pandas中已经被废弃，可能在一些旧的Pandas版本中才会有，此处不再赘述。</p>
<h2 id="index属性"><a class="markdownIt-Anchor" href="#index属性"></a> index属性</h2>
<p>在上面的代码中，我们使用了index属性提取出一个series或dataframe的index，或使用columns属性提取出一个dataframe的column。这些操作得到的都是一个index类型的<strong>常量</strong>，也就是说index的数据无法修改！</p>
<p>index常量可以直接用于修改其它series或dataframe的index。同时，这个index可以像python自带的set一样使用。</p>
<p>Pandas中，index的类型包括但不限于：</p>
<ul>
<li>Index：最基本的也是最通用的index类型</li>
<li>Int64Index：整数类型的index</li>
<li>MultiIndex：多重index</li>
<li>DatetimeIndex：使用NumPy的<code>datetime64</code>类型，保存的是毫秒形式的时间戳</li>
<li>PeriodIndex：周期性数据构成的index</li>
<li>RangeIndex：index为一组等差数列组成的range，具有开始值、结束值和步长。</li>
</ul>
<p>同时index支持下面这些方法，来构造新的index。其中，一些方法对于某些特定的index类型不适用：</p>
<ul>
<li>append：将一个新的index附加到已有的index后面</li>
<li>diff：取两个index中不重复的元素</li>
<li>intersection：取两个index的交集</li>
<li>union：取两个index的并集</li>
<li>delete：传入一个整数，删除对应位置的元素</li>
<li>drop：传入一个元素的值，删除掉这个元素</li>
<li>insert：传入一个整数与一个值，将这个值插入到整数对应的位置</li>
<li>unique：输出index中不重复的元素</li>
</ul>
<p>index也支持下面的这些运算操作：</p>
<ul>
<li>isin：传入一个list，输出一个布尔类型的数组，表示list中的元素是否在index中</li>
<li>is_monotonic：如果每个元素都大于等于它的前一个，则返回True</li>
<li>is_unique：如果index中没有重复元素则返回True</li>
</ul>
<p>下面为一些用法示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe1.index.union(dataframe1.columns)</span><br></pre></td></tr></table></figure>
<pre><code>Index([0, 1, 2, 3, 4, 'pop', 'state', 'year'], dtype='object')
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe1.columns.is_unique</span><br></pre></td></tr></table></figure>
<pre><code>True
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe1.columns.drop(<span class="string">&#x27;pop&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Index(['state', 'year'], dtype='object', name='test_columns')
</code></pre>
<h2 id="具有重复数据的index"><a class="markdownIt-Anchor" href="#具有重复数据的index"></a> 具有重复数据的index</h2>
<p>在Series和DataFrame的index中，可以出现重复的元素，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe2=pd.DataFrame(np.random.randn(<span class="number">5</span>,<span class="number">3</span>),index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe2.index.is_unique <span class="comment">#此时调用index的is_unique属性，返回值为False</span></span><br></pre></td></tr></table></figure>
<pre><code>False
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe2.loc[<span class="string">&#x27;b&#x27;</span>] <span class="comment">#此时对重复的index做索引时得到的是一个DataFrame而不是一个Series</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>b</th>
      <td>1.589025</td>
      <td>-0.504598</td>
      <td>0.021645</td>
    </tr>
    <tr>
      <th>b</th>
      <td>0.629079</td>
      <td>-0.703262</td>
      <td>-0.759489</td>
    </tr>
  </tbody>
</table>
</div>
<h1 id="io操作"><a class="markdownIt-Anchor" href="#io操作"></a> IO操作</h1>
<h2 id="读取文件"><a class="markdownIt-Anchor" href="#读取文件"></a> 读取文件</h2>
<p>Pandas常用的从文件中读取表格数据的函数有：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pd.read_csv(<span class="string">&#x27;filename&#x27;</span>) <span class="comment">#读取.csv格式的文件，可以是本地文件路径，也可以是一个URL。默认的分隔符为逗号</span></span><br><span class="line">pd.read_table(<span class="string">&#x27;filename&#x27;</span>) <span class="comment">#从文件中读取表格数据，可以是本地文件路径，也可以是URL。默认分割符为&#x27;\t&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在这两个函数中，常用的参数包括：</p>
<ul>
<li>path：文件路径，可以为本地文件路径或者URL</li>
<li>sep/delimiter：表格数据的分割符，可以使用正则表达式</li>
<li>header：文件中哪一行作为结果中的columns（列名称），默认为0。如果不使用任意一行作为columns，则这一参数应该设置为None</li>
<li>index_col：在最终结果中，哪些列被作为index，可以传入数字序号或者列名称</li>
<li>names：传入一个list，作为columns（列名称），此时header参数应该为None</li>
<li>skiprows：传入一个数字，代表跳过前若干行不读取，然后从接下来的行作为文件的开头进行读取；或是传入一个列表，代表跳过列表中的行</li>
<li>na_values：传入一个list，其中包含的元素作为NaN处理；或是传入一个dict，其中每个元素的key对应于列名，value为一个list，代表作为NaN处理的元素。默认情况下，文件中的空格或者一些特殊值都会被看作是NaN</li>
<li>comment：传入一个或一些字符，用于在一行的结尾将注释部分与表格内容分隔开</li>
<li>converters：传入一个dict，其中的元素为列名称和函数的映射，代表对某一列使用某个函数进行数据转换</li>
<li>nrows：代表从文件开始位置读取多少行</li>
<li>chunksize：传入一个整数，表示一个DataFrame中的行上限，如果原始数据中的行数大于这一上限，则最终得到的是多个DataFrame</li>
<li>skip_footer：代表忽略文件最后的若干行</li>
<li>parse_dates：是否试图将原始数据中的时间数据转换为datetime类型，默认为False。如果为True，则读取数据时会对所有的列尝试进行类型转换操作</li>
<li>encoding：原始数据的编码方式</li>
</ul>
<p>此外，还有一些从其他数据来源中读取数据的函数，包括（此处不再详细赘述每个函数的具体用法）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pd.read_excel(<span class="string">&#x27;filename&#x27;</span>,<span class="string">&#x27;sheetname&#x27;</span>) <span class="comment">#从.xls或.xlsx文件中读取表格数据</span></span><br><span class="line">pd.read_html(<span class="string">&#x27;filename&#x27;</span>) <span class="comment">#从html文件中读取其中所有的表格</span></span><br><span class="line">pd.read_json(<span class="string">&#x27;filename&#x27;</span>) <span class="comment">#从JSON格式文件中读取表格</span></span><br><span class="line">pd.read_pickle(<span class="string">&#x27;filename&#x27;</span>) <span class="comment">#从Python pickle格式的二进制文件中读取表格数据。相应地，保存数据的时候用to_pickle()函数。</span></span><br><span class="line">pd.read_sql(<span class="string">&#x27;SQL command&#x27;</span>, database) <span class="comment">#从SQL数据库中读取数据</span></span><br></pre></td></tr></table></figure>
<h2 id="写入文件"><a class="markdownIt-Anchor" href="#写入文件"></a> 写入文件</h2>
<p>Pandas提供了将Series或者DataFrame转换为csv文件的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.to_csv(<span class="string">&#x27;filename&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这一函数可以传入的参数包括：</p>
<ul>
<li>sep：指定分隔符，默认为逗号</li>
<li>na_rep：指定缺失数据的输出值，默认输出为空字符串</li>
<li>index：代表是否将index写入到文件中，默认为True</li>
<li>header：代表是否将columns（列名称）写入到文件中，默认为True</li>
<li>cols：指定写入到文件中去的列名称</li>
</ul>
<p>如果要将文件写入Excel格式，可以使用函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame.to_excel(<span class="string">&#x27;filename&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="基本操作与运算"><a class="markdownIt-Anchor" href="#基本操作与运算"></a> 基本操作与运算</h1>
<h2 id="reindex"><a class="markdownIt-Anchor" href="#reindex"></a> reindex</h2>
<p>reindex函数传入一个list、tuple或者index，将其作为新的index，并将原来的数据按照新index对应起来。如果新的index中有新的元素，则它对应的值默认为NaN，也可以传入参数对其进行赋值。如果旧的index中某些元素不包含在新的index中，则新数据不包含相应的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series([<span class="number">4.5</span>, <span class="number">7.2</span>, <span class="number">-5.3</span>, <span class="number">3.6</span>], index=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj</span><br></pre></td></tr></table></figure>
<pre><code>d    4.5
b    7.2
a   -5.3
c    3.6
dtype: float64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.reindex([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>]) <span class="comment">#原来的Series中没有&#x27;e&#x27;这个index，因此相应位置默认为NaN</span></span><br></pre></td></tr></table></figure>
<pre><code>a   -5.3
b    7.2
c    3.6
d    4.5
e    NaN
dtype: float64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.reindex([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;e&#x27;</span>],fill_value=<span class="number">0</span>) <span class="comment">#原Series中有的index，如果传入的index中没有则不包含相应的值，传入fill_value可以对新index对应的值进行填充</span></span><br></pre></td></tr></table></figure>
<pre><code>a   -5.3
b    7.2
e    0.0
dtype: float64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj2 = pd.Series([<span class="number">4.5</span>, <span class="number">7.2</span>, <span class="number">-5.3</span>, <span class="number">3.6</span>], index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">obj2.reindex([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],method=<span class="string">&#x27;ffill&#x27;</span>) <span class="comment">#如果原始的index为单调递增或者单调递减的情况下，可以传入method参数设置填充方法。其中ffill或者pad代表空位置使用从它向上追溯与它最近的非空元素。</span></span><br></pre></td></tr></table></figure>
<pre><code>2    7.2
3   -5.3
4    3.6
5    3.6
dtype: float64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj2.reindex([<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],method=<span class="string">&#x27;bfill&#x27;</span>) <span class="comment">#bfill或者backfill代表空位置使用从它向下追溯与它最近的非空元素。注意，ffill和bfill在填充的时候，是在原Series的index中进行查找（如本例的0）。如果要做ffill操作的index最小，或者做bfill操作的index最大，则仍然会被填充为NaN。</span></span><br></pre></td></tr></table></figure>
<pre><code>0    4.5
2    7.2
3   -5.3
4    3.6
5    NaN
dtype: float64
</code></pre>
<p>对于DataFrame来说，则可以同时改变它的index或者columns：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj3=pd.DataFrame(np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>, <span class="number">3</span>)), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],columns=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;California&#x27;</span>])</span><br><span class="line">obj3.reindex([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]) <span class="comment">#默认情况下，使用传入的list、tuple或者index去修改DataFrame的index。如果只修改columns则需要将传入参数设置为columns=……。</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    } 
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Ohio</th>
      <th>Texas</th>
      <th>California</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0.0</td>
      <td>1.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>b</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>c</th>
      <td>3.0</td>
      <td>4.0</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>d</th>
      <td>6.0</td>
      <td>7.0</td>
      <td>8.0</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj3.reindex(index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>],columns=[<span class="string">&#x27;Texas&#x27;</span>,<span class="string">&#x27;Utah&#x27;</span>,<span class="string">&#x27;California&#x27;</span>])</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Texas</th>
      <th>Utah</th>
      <th>California</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1.0</td>
      <td>NaN</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>b</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>c</th>
      <td>4.0</td>
      <td>NaN</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>d</th>
      <td>7.0</td>
      <td>NaN</td>
      <td>8.0</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj3.index=obj3.index.map(str.upper) <span class="comment">#可以传入一个dict或者一个函数对index进行修改</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj3</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Ohio</th>
      <th>Texas</th>
      <th>California</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>C</th>
      <td>3</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th>D</th>
      <td>6</td>
      <td>7</td>
      <td>8</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj3.rename(index=str.title,columns=str.upper) <span class="comment">#使用rename函数也可以实现同样的功能。默认情况下这一函数会生成一个副本，如果要直接修改原变量则需要加上inplace=True参数。</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>OHIO</th>
      <th>TEXAS</th>
      <th>CALIFORNIA</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>C</th>
      <td>3</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th>D</th>
      <td>6</td>
      <td>7</td>
      <td>8</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj3.rename(columns=&#123;<span class="string">&#x27;Ohio&#x27;</span>: <span class="string">&#x27;INDIANA&#x27;</span>&#125;,index=&#123;<span class="string">&#x27;C&#x27;</span>: <span class="string">&#x27;peekaboo&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>INDIANA</th>
      <th>Texas</th>
      <th>California</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>peekaboo</th>
      <td>3</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th>D</th>
      <td>6</td>
      <td>7</td>
      <td>8</td>
    </tr>
  </tbody>
</table>
</div>
<h2 id="删除操作"><a class="markdownIt-Anchor" href="#删除操作"></a> 删除操作</h2>
<p>drop函数可以从Series或者DataFrame中删除某个index对应的行，或者DataFrame中某个column对应的列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj3.drop([<span class="string">&#x27;A&#x27;</span>]) <span class="comment">#默认查找index并删除行</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Ohio</th>
      <th>Texas</th>
      <th>California</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>C</th>
      <td>3</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th>D</th>
      <td>6</td>
      <td>7</td>
      <td>8</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj3.drop(<span class="string">&#x27;Texas&#x27;</span>,axis=<span class="number">1</span>) <span class="comment">#要删除column则需要指定axis参数等于1</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Ohio</th>
      <th>California</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>0</td>
      <td>2</td>
    </tr>
    <tr>
      <th>C</th>
      <td>3</td>
      <td>5</td>
    </tr>
    <tr>
      <th>D</th>
      <td>6</td>
      <td>8</td>
    </tr>
  </tbody>
</table>
</div>
<h2 id="切片与索引操作"><a class="markdownIt-Anchor" href="#切片与索引操作"></a> 切片与索引操作</h2>
<p>Series和DataFrame都支持索引和切片操作，同时支持使用布尔运算进行索引。</p>
<p>下面为Series的一些使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_index=pd.Series(np.arange(<span class="number">4.</span>),index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_index[<span class="number">1</span>] <span class="comment">#可以像索引list或者ndarray一样使用序号进行索引，但是这种索引方式要求index中的元素不是int类型，否则会使用int索引index中的元素</span></span><br></pre></td></tr></table></figure>
<pre><code>1.0
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_index[<span class="string">&#x27;b&#x27;</span>] <span class="comment">#可以按照index的值来索引</span></span><br></pre></td></tr></table></figure>
<pre><code>1.0
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_index[<span class="number">2</span>:<span class="number">4</span>] <span class="comment">#使用序号进行切片操作，按照左闭右开区间取数据</span></span><br></pre></td></tr></table></figure>
<pre><code>c    2.0
d    3.0
dtype: float64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_index[<span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;c&#x27;</span>] <span class="comment">#使用index的值进行切片操作，此时取数据按照闭区间来操作</span></span><br></pre></td></tr></table></figure>
<pre><code>a    0.0
b    1.0
c    2.0
dtype: float64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_index[[<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>]] <span class="comment">#按照传入的list进行索引</span></span><br></pre></td></tr></table></figure>
<pre><code>b    1.0
a    0.0
dtype: float64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_index[[<span class="number">2</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<pre><code>c    2.0
b    1.0
dtype: float64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_index[series_index&lt;<span class="number">2</span>] <span class="comment">#使用布尔表达式进行索引，相当于传入布尔数组来索引</span></span><br></pre></td></tr></table></figure>
<pre><code>a    0.0
b    1.0
dtype: float64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_index[<span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;c&#x27;</span>]=<span class="number">4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_index <span class="comment">#索引操作获得的是原始数据的副本，如果对索引得到的数据进行修改操作，相当于修改原始数据</span></span><br></pre></td></tr></table></figure>
<pre><code>a    0.0
b    4.0
c    4.0
d    3.0
dtype: float64
</code></pre>
<p>对于DataFrame来说，它的索引与切片操作比Series要复杂一些。一些使用示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_index=pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)),index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>], columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataframe_index[<span class="string">&#x27;two&#x27;</span>] <span class="comment">#传入columns中的元素，按列做索引，得到一个Series。</span></span><br><span class="line"><span class="comment">#注意DataFrame不支持使用index的元素进行索引！例如dataframe_index[&#x27;Ohio&#x27;]操作是错误的。</span></span><br></pre></td></tr></table></figure>
<pre><code>Ohio         1
Colorado     5
Utah         9
New York    13
Name: two, dtype: int32
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataframe_index[[<span class="string">&#x27;three&#x27;</span>,<span class="string">&#x27;one&#x27;</span>]] <span class="comment">#传入一个list进行索引，索引结果按照list中的元素顺序排列。</span></span><br><span class="line"><span class="comment">#需要注意的是，不能使用columns中的元素来做切片操作！例如dataframe_index[&#x27;one&#x27;:&#x27;three&#x27;]为非法操作。</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>three</th>
      <th>one</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Ohio</th>
      <td>2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>6</td>
      <td>4</td>
    </tr>
    <tr>
      <th>Utah</th>
      <td>10</td>
      <td>8</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>14</td>
      <td>12</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataframe_index[:<span class="number">2</span>] <span class="comment">#DataFrame也可以使用数字来做切片操作，这一方法是对行进行切片操作</span></span><br><span class="line"><span class="comment">#注意：DataFrame不支持像Series一样直接传入数字进行索引！例如dataframe_index[2]，dataframe_index[[0,1]],dataframe_index[[0,1],[1,2]]都为错误操作。要使用数字索引，需要使用iloc运算。</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
      <th>four</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Ohio</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_index.take([<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>]) <span class="comment">#如果要按行取数据，可以使用take函数。函数接收一个元素为整数的list，然后按照这些整数选出对应的行。list中的元素可以有重复。如果要对数据进行随机打乱，则可以借助NumPy的random.permutation函数</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
      <th>four</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Utah</th>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_index[dataframe_index&lt;<span class="number">5</span>] <span class="comment">#可以在索引时使用布尔表达式，相当于传入布尔数组</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
      <th>four</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Ohio</th>
      <td>0.0</td>
      <td>1.0</td>
      <td>2.0</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>4.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>Utah</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_index[dataframe_index[<span class="string">&#x27;three&#x27;</span>]&gt;<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
      <th>four</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Colorado</th>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
    </tr>
    <tr>
      <th>Utah</th>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_index[<span class="string">&#x27;five&#x27;</span>]=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>] <span class="comment">#可以使用这种方式向DataFrame中插入一个新列（当然Series也支持这种操作），要求索引使用的关键词在columns中不存在，并且赋值使用的list的大小要求与DataFrame的行数一致。注意这样的操作会直接在原始数据上做就地的修改</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_index </span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
      <th>four</th>
      <th>five</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Ohio</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>3</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>4</td>
    </tr>
    <tr>
      <th>Utah</th>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
      <td>5</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
      <td>6</td>
    </tr>
  </tbody>
</table>
</div>
<p>除了上述这些操作，pandas还提供了<code>loc</code>和<code>iloc</code>两种运算符进行索引操作，<code>loc</code>是使用index和columns中的内容进行索引，而<code>iloc</code>则是使用整数。同样，也可以使用<code>at</code>和<code>iat</code>两个运算符，索引某行和某列对应的那个元素。这种索引方式的含义清晰，不会让人混淆，因此在索引操作时最好使用这种办法。</p>
<p>下面是一些使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_index.loc[<span class="string">&#x27;Ohio&#x27;</span>:<span class="string">&#x27;Utah&#x27;</span>,[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>]] <span class="comment">#先索引index，再索引columns，支持切片操作以及传入list的索引方式</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Ohio</th>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th>Utah</th>
      <td>8</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_index.loc[:,[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>]] <span class="comment">#如果只索引columns，则index部分必须加上:代表索引所有的index。</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Ohio</th>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th>Utah</th>
      <td>8</td>
      <td>9</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>12</td>
      <td>13</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_index.loc[[<span class="string">&#x27;New York&#x27;</span>,<span class="string">&#x27;Utah&#x27;</span>]] <span class="comment">#如果只索引index，则columns部分的索引可以省略。</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
      <th>four</th>
      <th>five</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>New York</th>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
      <td>6</td>
    </tr>
    <tr>
      <th>Utah</th>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_index.iloc[<span class="number">2</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">3</span>] <span class="comment">#与NumPy切片的方式类似</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>two</th>
      <th>three</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Utah</th>
      <td>9</td>
      <td>10</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>13</td>
      <td>14</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_index.iloc[[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">1</span>]] <span class="comment">#如果传入两个list进行索引，则分别对应于索引的行与列，类似于NumPy.ix_()函数。</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Utah</th>
      <td>8</td>
      <td>9</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>12</td>
      <td>13</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_index.at[<span class="string">&#x27;Utah&#x27;</span>,<span class="string">&#x27;one&#x27;</span>] <span class="comment">#只能索引某个元素，不支持切片以及传入list</span></span><br></pre></td></tr></table></figure>
<pre><code>8
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_index.iat[<span class="number">1</span>,<span class="number">1</span>] <span class="comment">#使用整数坐标来索引某个元素</span></span><br></pre></td></tr></table></figure>
<pre><code>5
</code></pre>
<h2 id="数学运算"><a class="markdownIt-Anchor" href="#数学运算"></a> 数学运算</h2>
<p>Series和DataFrame支持一些数学运算，包括:</p>
<ul>
<li><code>add()</code>，或使用运算符+</li>
<li><code>sub()</code>，或使用运算符-</li>
<li><code>mul()</code>，或使用运算符*</li>
<li><code>div()</code>，或使用运算符/</li>
</ul>
<p>以加法为例，对两个index不相同的Series相加时，最后得到的index是两个index的并集。默认情况下，运算结果满足以下规律：如果是两个index里面都有的key，则它对应的结果是这个key在两个Series里对应的value之和；如果某些key只出现在其中一个index里面，则相加后对应的value值为空。</p>
<p>DataFrame也满足上述的规则，并且在考虑index的基础上，也要考虑columns。</p>
<p>下面是一些使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataframe_math1=pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">3</span>, <span class="number">4</span>)), columns=list(<span class="string">&#x27;abcd&#x27;</span>))</span><br><span class="line">dataframe_math2=pd.DataFrame(np.arange(<span class="number">20.</span>).reshape((<span class="number">4</span>, <span class="number">5</span>)), columns=list(<span class="string">&#x27;abcde&#x27;</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_math1+dataframe_math2</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.0</td>
      <td>2.0</td>
      <td>4.0</td>
      <td>6.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>9.0</td>
      <td>11.0</td>
      <td>13.0</td>
      <td>15.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>18.0</td>
      <td>20.0</td>
      <td>22.0</td>
      <td>24.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_math1.add(dataframe_math2,fill_value=<span class="number">0</span>) <span class="comment">#与上面一条语句的作用相同。但是add函数支持传入fill_value参数，此时如果某些key只在一个DataFrame中出现，那么另一个DataFrame中相应的位置会被补上传入的值来参与运算。</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.0</td>
      <td>2.0</td>
      <td>4.0</td>
      <td>6.0</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>9.0</td>
      <td>11.0</td>
      <td>13.0</td>
      <td>15.0</td>
      <td>9.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>18.0</td>
      <td>20.0</td>
      <td>22.0</td>
      <td>24.0</td>
      <td>14.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>15.0</td>
      <td>16.0</td>
      <td>17.0</td>
      <td>18.0</td>
      <td>19.0</td>
    </tr>
  </tbody>
</table>
</div>
<p>如果是一个DataFrame和Series进行运算，那么默认会把Series的元素按行复制进行扩展，然后参与运算。如果Series的index和DataFrame的columns不是完全相同，也可以进行运算，运算规则与两个DataFrame的运算规则类似。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">series_math1=dataframe_math1.iloc[<span class="number">0</span>]</span><br><span class="line">dataframe_math1-series_math1</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.0</td>
      <td>4.0</td>
      <td>4.0</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>8.0</td>
      <td>8.0</td>
      <td>8.0</td>
      <td>8.0</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">series_math2=series_math1.reindex([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">dataframe_math1-series_math2</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.0</td>
      <td>4.0</td>
      <td>4.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>8.0</td>
      <td>8.0</td>
      <td>8.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">series_math3=dataframe_math1[<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">dataframe_math1.subtract(series_math3,axis=<span class="number">0</span>) <span class="comment">#要想按列进行扩展，需要调用函数，并且传入axis=0这一可选参数。</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>-3.0</td>
      <td>-2.0</td>
      <td>-1.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-3.0</td>
      <td>-2.0</td>
      <td>-1.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-3.0</td>
      <td>-2.0</td>
      <td>-1.0</td>
      <td>0.0</td>
    </tr>
  </tbody>
</table>
</div>
<h2 id="函数与映射"><a class="markdownIt-Anchor" href="#函数与映射"></a> 函数与映射</h2>
<p>Numpy中的ufunc（即一元函数）也可以使用pandas中的series和dataframe类型的变量作为输入参数。下面为一些使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataframe_func = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>), columns=list(<span class="string">&#x27;bde&#x27;</span>),index=[<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>])</span><br><span class="line">dataframe_func</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Utah</th>
      <td>0.452034</td>
      <td>-1.067267</td>
      <td>2.235212</td>
    </tr>
    <tr>
      <th>Ohio</th>
      <td>-1.205085</td>
      <td>0.899914</td>
      <td>-1.097603</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>-1.553192</td>
      <td>-0.820639</td>
      <td>0.025214</td>
    </tr>
    <tr>
      <th>Oregon</th>
      <td>-0.047253</td>
      <td>1.092414</td>
      <td>-0.302945</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.exp(dataframe_func)</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Utah</th>
      <td>1.571506</td>
      <td>0.343947</td>
      <td>9.348460</td>
    </tr>
    <tr>
      <th>Ohio</th>
      <td>0.299666</td>
      <td>2.459391</td>
      <td>0.333670</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>0.211572</td>
      <td>0.440151</td>
      <td>1.025534</td>
    </tr>
    <tr>
      <th>Oregon</th>
      <td>0.953846</td>
      <td>2.981464</td>
      <td>0.738640</td>
    </tr>
  </tbody>
</table>
</div>
<p>同时也可以自己定义函数，然后使用<code>apply</code>函数作用于每一行或者每一列。如果函数返回一个数值，那么最后生成一个Series；如果函数返回一个矢量值，最后生成一个DataFrame。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1=<span class="keyword">lambda</span> x:x.max()-x.min()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_func.apply(f1) <span class="comment">#默认作用于行</span></span><br></pre></td></tr></table></figure>
<pre><code>b    2.005226
d    2.159681
e    3.332815
dtype: float64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_func.apply(f1,axis=<span class="number">1</span>) <span class="comment">#如果要让函数作用于列，则可以传入axis参数指定方向</span></span><br></pre></td></tr></table></figure>
<pre><code>Utah      3.302478
Ohio      2.104999
Texas     1.578405
Oregon    1.395360
dtype: float64
</code></pre>
<blockquote>
<p>备注：在Pandas的一些函数中，如果传入<code>axis=……</code>参数，则代表这一函数操作在这个传入的维度上面进行。假设有一个DataFrame，它的元素可以用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>来表示，当我们在使用<code>sum()</code>函数时传入<code>axis=1</code>，那么最终得到的结果便可以用数学公式表示为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\sum_{j=1}^{n}a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.24011em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，也就是说这个操作是在维度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>上进行的，也就是水平方向。</p>
</blockquote>
<p><code>applymap</code>方法可以让函数作用于每一个元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f2=<span class="keyword">lambda</span> x: <span class="string">&#x27;%.2f&#x27;</span>%x</span><br><span class="line">dataframe_func.applymap(f2)</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Utah</th>
      <td>0.45</td>
      <td>-1.07</td>
      <td>2.24</td>
    </tr>
    <tr>
      <th>Ohio</th>
      <td>-1.21</td>
      <td>0.90</td>
      <td>-1.10</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>-1.55</td>
      <td>-0.82</td>
      <td>0.03</td>
    </tr>
    <tr>
      <th>Oregon</th>
      <td>-0.05</td>
      <td>1.09</td>
      <td>-0.30</td>
    </tr>
  </tbody>
</table>
</div>
<h2 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h2>
<p>Series或DataFrame的index和columns可以使用<code>sort_index()</code>函数对其进行排序，使得行或列按照index排序后的顺序进行排列。<code>sort_index()</code>函数生成的是原始数据的一个副本。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">series_sort=pd.Series(range(<span class="number">4</span>), index=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">series_sort.sort_index()</span><br></pre></td></tr></table></figure>
<pre><code>a    1
b    2
c    3
d    0
dtype: int64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_sort=pd.DataFrame(np.arange(<span class="number">8</span>).reshape((<span class="number">2</span>, <span class="number">4</span>)), index=[<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;one&#x27;</span>], columns=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_sort.sort_index() <span class="comment">#DataFrame默认对index进行排序</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>d</th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>one</th>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
    </tr>
    <tr>
      <th>three</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_sort.sort_index(axis=<span class="number">1</span>) <span class="comment">#可以传入axis参数来对columns进行排序</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>three</th>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>0</td>
    </tr>
    <tr>
      <th>one</th>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_sort.sort_index(axis=<span class="number">1</span>,ascending=<span class="literal">False</span>) <span class="comment">#默认按照升序排列，如果要降序排列则需要设置ascending=False</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>d</th>
      <th>c</th>
      <th>b</th>
      <th>a</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>three</th>
      <td>0</td>
      <td>3</td>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <th>one</th>
      <td>4</td>
      <td>7</td>
      <td>6</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div>
<p>如果想对Series或者DataFrame按照元素的大小顺序进行排序，可以用<code>sort_values()</code>方法，其中NaN值会自动排在最后：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_sort2=pd.DataFrame(&#123;<span class="string">&#x27;b&#x27;</span>: [<span class="number">4</span>, <span class="number">7</span>, <span class="number">-3</span>, <span class="number">2</span>], <span class="string">&#x27;a&#x27;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_sort2.sort_values(by=<span class="string">&#x27;b&#x27;</span>) <span class="comment">#DataFrame需要传入一个by参数，指定按照某一列的元素大小排序。注意：不能按某一行进行排序！</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>a</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2</th>
      <td>-3</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <th>0</th>
      <td>4</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>7</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_sort2.sort_values(by=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>]) <span class="comment">#by参数可以传入一个list选择多列，代表先按照list中第一个元素对应的列进行排序，如果出现相同值则使用第二个元素对应的列来排序这些相同值，以此类推</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>a</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2</th>
      <td>-3</td>
      <td>0</td>
    </tr>
    <tr>
      <th>0</th>
      <td>4</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>7</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>
<p>使用<code>rank()</code>方法，可以生成Series或DataFrame中的元素的排列次序，类似于NumPy的argsort()函数。</p>
<p><code>rank()</code>在处理重复值的时候，有如下几种方法：</p>
<ul>
<li>average：生成重复值对应顺序的平均值。例如两个重复值分别排1和2，则它们的rank都为1.5</li>
<li>min：重复值使用最小的那个rank</li>
<li>max：重复值使用最大的那个rank</li>
<li>first：使用重复值中第一个出现的那个对应的rank</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_sort2.rank() <span class="comment">#默认按列做rank操作，使用average方法处理重复值</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>a</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>3.0</td>
      <td>1.5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.0</td>
      <td>3.5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1.0</td>
      <td>1.5</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2.0</td>
      <td>3.5</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_sort2.rank(axis=<span class="number">1</span>) <span class="comment">#可以传入axis参数来指定rank操作的方向</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>a</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2.0</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_sort2.rank(method=<span class="string">&#x27;max&#x27;</span>,ascending=<span class="literal">False</span>) <span class="comment">#要改变对重复值的处理方式可以传入method参数，使用降序可以传入ascending=False参数</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>a</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2.0</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.0</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3.0</td>
      <td>2.0</td>
    </tr>
  </tbody>
</table>
</div>
<h1 id="统计函数"><a class="markdownIt-Anchor" href="#统计函数"></a> 统计函数</h1>
<p>Pandas支持对Series和DataFrame中的数据做一些数学统计，常用的统计函数包括：</p>
<ul>
<li>count：统计非NaN元素的数目</li>
<li>describe：自动统计dataframe中每一列的数据数目，平均值，标准差，最小值，25%，50%，75%，100%分位数，可以用于分析数据的大致统计规律</li>
<li>min、max：统计最小或最大值</li>
<li>argmin、argmax：统计最小或最大值出现的位置，返回对应的序号</li>
<li>idxmin、idxmax：统计最小或最大值出现的位置，返回对应的index值</li>
<li>quantile：统计某个百分位数（需要传入一个0到1中间的数字）</li>
<li>sum：统计所有元素的和</li>
<li>mean：统计所有元素的平均数</li>
<li>median：统计所有元素的中位数</li>
<li>mad：统计相较于平均值的绝对偏差的平均值</li>
<li>var：统计方差</li>
<li>std：统计标准差</li>
<li>skew：统计偏度，表示随机变量与中心分布的不对称程度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">（</mi><msup><mi>μ</mi><mn>3</mn></msup><mi mathvariant="normal">/</mi><msup><mi>σ</mi><mn>3</mn></msup><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">（μ^3/σ^3）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">（</span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">）</span></span></span></span>，右偏为正，左偏为负</li>
<li>kurt：统计峰度，表征概率密度分布曲线在平均值处峰值高低的特征数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">（</mi><msup><mi>μ</mi><mn>4</mn></msup><mi mathvariant="normal">/</mi><msup><mi>σ</mi><mn>4</mn></msup><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">（μ^4/σ^4）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">（</span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">）</span></span></span></span>。以正态分布为界，如果比正态分布陡，峰度大于0，否则小于0</li>
<li>cumsum：计算累积和（即保留计算总和时中间每一步的结果）</li>
<li>cummin、cummax：计算累积最小值或最大值</li>
<li>cumprod：计算累积乘积</li>
<li>diff：计算一阶算数偏差（即拿第二个值减第一个，第三个值减第二个，以此类推）</li>
<li>pct_change：计算百分数改变</li>
</ul>
<p>在统计函数中，可以使用的一些参数包括：</p>
<ul>
<li>axis：指定统计函数在哪个维度上计算，0为行，1为列（即0是按照竖直方向，1是按照水平方向）</li>
<li>skipna：是否跳过NaN，默认为True</li>
<li>level：如果使用多重index，则对每一个层级的结果进行分组</li>
</ul>
<p>下面为一些使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataframe_stat=pd.DataFrame(np.random.rand(<span class="number">5</span>,<span class="number">5</span>),columns=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">dataframe_stat</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.925587</td>
      <td>0.285093</td>
      <td>0.016950</td>
      <td>0.140965</td>
      <td>0.179401</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.213783</td>
      <td>0.146496</td>
      <td>0.816971</td>
      <td>0.065923</td>
      <td>0.067685</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.615921</td>
      <td>0.717184</td>
      <td>0.375118</td>
      <td>0.233150</td>
      <td>0.188625</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.469468</td>
      <td>0.960874</td>
      <td>0.769445</td>
      <td>0.503390</td>
      <td>0.928483</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.480754</td>
      <td>0.340058</td>
      <td>0.424418</td>
      <td>0.566608</td>
      <td>0.810999</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_stat.pct_change() <span class="comment">#如果不指定axis则默认是按行做计算</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-0.769030</td>
      <td>-0.486148</td>
      <td>47.199252</td>
      <td>-0.532347</td>
      <td>-0.622717</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1.881058</td>
      <td>3.895602</td>
      <td>-0.540843</td>
      <td>2.536707</td>
      <td>1.786814</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-0.237778</td>
      <td>0.339787</td>
      <td>1.051211</td>
      <td>1.159082</td>
      <td>3.922365</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.024039</td>
      <td>-0.646095</td>
      <td>-0.448410</td>
      <td>0.125585</td>
      <td>-0.126533</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_stat.describe()</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>5.000000</td>
      <td>5.000000</td>
      <td>5.000000</td>
      <td>5.000000</td>
      <td>5.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>0.541102</td>
      <td>0.489941</td>
      <td>0.480580</td>
      <td>0.302007</td>
      <td>0.435039</td>
    </tr>
    <tr>
      <th>std</th>
      <td>0.259489</td>
      <td>0.337565</td>
      <td>0.326279</td>
      <td>0.221912</td>
      <td>0.401825</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.213783</td>
      <td>0.146496</td>
      <td>0.016950</td>
      <td>0.065923</td>
      <td>0.067685</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>0.469468</td>
      <td>0.285093</td>
      <td>0.375118</td>
      <td>0.140965</td>
      <td>0.179401</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>0.480754</td>
      <td>0.340058</td>
      <td>0.424418</td>
      <td>0.233150</td>
      <td>0.188625</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>0.615921</td>
      <td>0.717184</td>
      <td>0.769445</td>
      <td>0.503390</td>
      <td>0.810999</td>
    </tr>
    <tr>
      <th>max</th>
      <td>0.925587</td>
      <td>0.960874</td>
      <td>0.816971</td>
      <td>0.566608</td>
      <td>0.928483</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_stat.min(axis=<span class="number">1</span>) <span class="comment">#可以通过传入axis来指定计算方向</span></span><br></pre></td></tr></table></figure>
<pre><code>0    0.016950
1    0.065923
2    0.188625
3    0.469468
4    0.340058
dtype: float64
</code></pre>
<p>Pandas也提供了协方差和相关系数的计算，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_stat.corr() <span class="comment">#对于一个DataFrame，计算所有列与列之间的相关系数</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1.000000</td>
      <td>0.074114</td>
      <td>-0.925876</td>
      <td>-0.087650</td>
      <td>-0.130717</td>
    </tr>
    <tr>
      <th>b</th>
      <td>0.074114</td>
      <td>1.000000</td>
      <td>0.226825</td>
      <td>0.512625</td>
      <td>0.550285</td>
    </tr>
    <tr>
      <th>c</th>
      <td>-0.925876</td>
      <td>0.226825</td>
      <td>1.000000</td>
      <td>0.158210</td>
      <td>0.271455</td>
    </tr>
    <tr>
      <th>d</th>
      <td>-0.087650</td>
      <td>0.512625</td>
      <td>0.158210</td>
      <td>1.000000</td>
      <td>0.963646</td>
    </tr>
    <tr>
      <th>e</th>
      <td>-0.130717</td>
      <td>0.550285</td>
      <td>0.271455</td>
      <td>0.963646</td>
      <td>1.000000</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_stat.cov() <span class="comment">#计算所有列与列之间两两的协方差</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0.067334</td>
      <td>0.006492</td>
      <td>-0.078390</td>
      <td>-0.005047</td>
      <td>-0.013630</td>
    </tr>
    <tr>
      <th>b</th>
      <td>0.006492</td>
      <td>0.113950</td>
      <td>0.024983</td>
      <td>0.038401</td>
      <td>0.074642</td>
    </tr>
    <tr>
      <th>c</th>
      <td>-0.078390</td>
      <td>0.024983</td>
      <td>0.106458</td>
      <td>0.011455</td>
      <td>0.035590</td>
    </tr>
    <tr>
      <th>d</th>
      <td>-0.005047</td>
      <td>0.038401</td>
      <td>0.011455</td>
      <td>0.049245</td>
      <td>0.085928</td>
    </tr>
    <tr>
      <th>e</th>
      <td>-0.013630</td>
      <td>0.074642</td>
      <td>0.035590</td>
      <td>0.085928</td>
      <td>0.161463</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_stat[<span class="string">&#x27;a&#x27;</span>].cov(dataframe_stat[<span class="string">&#x27;c&#x27;</span>]) <span class="comment">#对于一个Series来说，需要传入另一个规模相同的Series来进行计算</span></span><br></pre></td></tr></table></figure>
<pre><code>-0.07838993925634331
</code></pre>
<p>此外，还有一些用于统计Series中数据数目以及查找数据的函数，下面为一些使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">series_stat=pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>])</span><br><span class="line">series_stat</span><br></pre></td></tr></table></figure>
<pre><code>0     1
1     2
2     3
3     1
4     1
5     1
6     1
7     2
8     4
9     5
10    5
dtype: int64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_stat.value_counts() <span class="comment">#统计Series中每个元素出现的次数</span></span><br></pre></td></tr></table></figure>
<pre><code>1    5
5    2
2    2
4    1
3    1
dtype: int64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_stat.unique() <span class="comment">#对Series中的所有元素去重，元素的排列顺序按照它们第一次出现的顺序</span></span><br></pre></td></tr></table></figure>
<pre><code>array([1, 2, 3, 4, 5], dtype=int64)
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_stat.isin([<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>]) <span class="comment">#传入一个list，输出一个布尔类型的Series，对应于Series中的元素是否包含在传入的list当中</span></span><br></pre></td></tr></table></figure>
<pre><code>0     False
1     False
2      True
3     False
4     False
5     False
6     False
7     False
8      True
9     False
10    False
dtype: bool
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame([series_stat,series_stat,series_stat]).apply(pd.value_counts) <span class="comment">#如果要对DataFrame使用上述三个函数，可以借助apply函数</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
      <th>8</th>
      <th>9</th>
      <th>10</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>3.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>3.0</td>
      <td>3.0</td>
      <td>3.0</td>
      <td>3.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>NaN</td>
      <td>3.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>3.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>3.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>3.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>5</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>3.0</td>
      <td>3.0</td>
    </tr>
  </tbody>
</table>
</div>
<h1 id="数据清洗"><a class="markdownIt-Anchor" href="#数据清洗"></a> 数据清洗</h1>
<h2 id="处理丢失数据"><a class="markdownIt-Anchor" href="#处理丢失数据"></a> 处理丢失数据</h2>
<p>在Pandas中，可能会遇到Series或者DataFrame中存在丢失数据的情况。对于如何处理丢失数据，Pandas提供了一些相关的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dataframe_nan=pd.DataFrame(</span><br><span class="line">    &#123;<span class="string">&#x27;Nevada&#x27;</span>: &#123;<span class="number">2001</span>:<span class="number">2.4</span>, <span class="number">2002</span>:<span class="number">2.9</span>, <span class="number">2003</span>:<span class="number">3.3</span>&#125;, </span><br><span class="line">    <span class="string">&#x27;Ohio&#x27;</span>: &#123;<span class="number">2000</span>:<span class="number">1.5</span>, <span class="number">2001</span>:<span class="number">1.7</span>, <span class="number">2003</span>:<span class="number">3.6</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;New York&#x27;</span>:&#123;<span class="number">2003</span>:<span class="number">3.5</span>, <span class="number">2004</span>:<span class="number">5.7</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;Denver&#x27;</span>:&#123;<span class="number">2000</span>:<span class="number">0.5</span>, <span class="number">2001</span>:<span class="number">1.1</span>, <span class="number">2002</span>:<span class="number">2.1</span>, <span class="number">2003</span>:<span class="number">1.5</span>, <span class="number">2004</span>:<span class="number">0.9</span>&#125;&#125;,</span><br><span class="line">    index=[<span class="number">2000</span>,<span class="number">2001</span>,<span class="number">2002</span>,<span class="number">2003</span>,<span class="number">2004</span>,<span class="number">2005</span>])</span><br><span class="line">dataframe_nan</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Nevada</th>
      <th>Ohio</th>
      <th>New York</th>
      <th>Denver</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2000</th>
      <td>NaN</td>
      <td>1.5</td>
      <td>NaN</td>
      <td>0.5</td>
    </tr>
    <tr>
      <th>2001</th>
      <td>2.4</td>
      <td>1.7</td>
      <td>NaN</td>
      <td>1.1</td>
    </tr>
    <tr>
      <th>2002</th>
      <td>2.9</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>2.1</td>
    </tr>
    <tr>
      <th>2003</th>
      <td>3.3</td>
      <td>3.6</td>
      <td>3.5</td>
      <td>1.5</td>
    </tr>
    <tr>
      <th>2004</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>5.7</td>
      <td>0.9</td>
    </tr>
    <tr>
      <th>2005</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>
<p><code>dropna()</code>函数可以将丢失的数据删除掉。对于Series来说，丢失的数据会被直接删除掉；而对于DataFrame来说，默认操作是只要一行内有一个NaN就把这一行全部删除。下面是一些程序示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_nan.dropna() <span class="comment">#默认为按行删除，且只要一行内有一个NaN就把该行全部删除</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Nevada</th>
      <th>Ohio</th>
      <th>New York</th>
      <th>Denver</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2003</th>
      <td>3.3</td>
      <td>3.6</td>
      <td>3.5</td>
      <td>1.5</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_nan.dropna(how=<span class="string">&#x27;all&#x27;</span>) <span class="comment">#可以传入how=&#x27;all&#x27;参数，这样只有一行全部为NaN时才会删除该行</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Nevada</th>
      <th>Ohio</th>
      <th>New York</th>
      <th>Denver</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2000</th>
      <td>NaN</td>
      <td>1.5</td>
      <td>NaN</td>
      <td>0.5</td>
    </tr>
    <tr>
      <th>2001</th>
      <td>2.4</td>
      <td>1.7</td>
      <td>NaN</td>
      <td>1.1</td>
    </tr>
    <tr>
      <th>2002</th>
      <td>2.9</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>2.1</td>
    </tr>
    <tr>
      <th>2003</th>
      <td>3.3</td>
      <td>3.6</td>
      <td>3.5</td>
      <td>1.5</td>
    </tr>
    <tr>
      <th>2004</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>5.7</td>
      <td>0.9</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_nan.dropna(axis=<span class="number">1</span>, thresh=<span class="number">3</span>) <span class="comment">#可以通过设置axis参数，设定删除操作是对行还是对列进行。thresh参数可以用来指定当某一行或者某一列的非空元素大于等于多少时保留</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Nevada</th>
      <th>Ohio</th>
      <th>Denver</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2000</th>
      <td>NaN</td>
      <td>1.5</td>
      <td>0.5</td>
    </tr>
    <tr>
      <th>2001</th>
      <td>2.4</td>
      <td>1.7</td>
      <td>1.1</td>
    </tr>
    <tr>
      <th>2002</th>
      <td>2.9</td>
      <td>NaN</td>
      <td>2.1</td>
    </tr>
    <tr>
      <th>2003</th>
      <td>3.3</td>
      <td>3.6</td>
      <td>1.5</td>
    </tr>
    <tr>
      <th>2004</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>0.9</td>
    </tr>
    <tr>
      <th>2005</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>
<p>要对缺失的数据进行填补，可以使用<code>fillna</code>函数。这一函数支持传入不同类型的参数，从而进行不同方法的填补。函数的返回值是一个新的变量，不改变原变量，如果要对原变量直接修改可以传入<code>inplace=True</code>参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_nan.fillna(dataframe_nan.mean()) <span class="comment">#传入一个Series，每列中的缺失值会根据Series中对应的值来进行填补，如果在Series中找不到对应的值则仍为NaN。如果传入一个dict，也按照类似的策略进行填补。需要注意，这种方法不支持按行索引的填补方式。此处的示例为使用每列数据的平均值来进行填补。</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Nevada</th>
      <th>Ohio</th>
      <th>New York</th>
      <th>Denver</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2000</th>
      <td>2.866667</td>
      <td>1.500000</td>
      <td>4.6</td>
      <td>0.50</td>
    </tr>
    <tr>
      <th>2001</th>
      <td>2.400000</td>
      <td>1.700000</td>
      <td>4.6</td>
      <td>1.10</td>
    </tr>
    <tr>
      <th>2002</th>
      <td>2.900000</td>
      <td>2.266667</td>
      <td>4.6</td>
      <td>2.10</td>
    </tr>
    <tr>
      <th>2003</th>
      <td>3.300000</td>
      <td>3.600000</td>
      <td>3.5</td>
      <td>1.50</td>
    </tr>
    <tr>
      <th>2004</th>
      <td>2.866667</td>
      <td>2.266667</td>
      <td>5.7</td>
      <td>0.90</td>
    </tr>
    <tr>
      <th>2005</th>
      <td>2.866667</td>
      <td>2.266667</td>
      <td>4.6</td>
      <td>1.22</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_nan.fillna(<span class="number">0</span>) <span class="comment">#将每个缺失值填补为传入的数值</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Nevada</th>
      <th>Ohio</th>
      <th>New York</th>
      <th>Denver</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2000</th>
      <td>0.0</td>
      <td>1.5</td>
      <td>0.0</td>
      <td>0.5</td>
    </tr>
    <tr>
      <th>2001</th>
      <td>2.4</td>
      <td>1.7</td>
      <td>0.0</td>
      <td>1.1</td>
    </tr>
    <tr>
      <th>2002</th>
      <td>2.9</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>2.1</td>
    </tr>
    <tr>
      <th>2003</th>
      <td>3.3</td>
      <td>3.6</td>
      <td>3.5</td>
      <td>1.5</td>
    </tr>
    <tr>
      <th>2004</th>
      <td>0.0</td>
      <td>0.0</td>
      <td>5.7</td>
      <td>0.9</td>
    </tr>
    <tr>
      <th>2005</th>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_nan.fillna(method=<span class="string">&#x27;ffill&#x27;</span>,limit=<span class="number">1</span>) <span class="comment">#使用向上或向下复制的方式进行填补，limit参数规定了向上或向下复制的最大次数</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Nevada</th>
      <th>Ohio</th>
      <th>New York</th>
      <th>Denver</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2000</th>
      <td>NaN</td>
      <td>1.5</td>
      <td>NaN</td>
      <td>0.5</td>
    </tr>
    <tr>
      <th>2001</th>
      <td>2.4</td>
      <td>1.7</td>
      <td>NaN</td>
      <td>1.1</td>
    </tr>
    <tr>
      <th>2002</th>
      <td>2.9</td>
      <td>1.7</td>
      <td>NaN</td>
      <td>2.1</td>
    </tr>
    <tr>
      <th>2003</th>
      <td>3.3</td>
      <td>3.6</td>
      <td>3.5</td>
      <td>1.5</td>
    </tr>
    <tr>
      <th>2004</th>
      <td>3.3</td>
      <td>3.6</td>
      <td>5.7</td>
      <td>0.9</td>
    </tr>
    <tr>
      <th>2005</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>5.7</td>
      <td>0.9</td>
    </tr>
  </tbody>
</table>
</div>
<h2 id="除去重复数据"><a class="markdownIt-Anchor" href="#除去重复数据"></a> 除去重复数据</h2>
<p><code>drop_duplicates()</code>函数可以删除掉一个series或dataframe中的重复行。默认条件下，<code>drop_duplicates()</code>函数只会删除一行的所有元素都相同的多余行。如果想基于某些特定的行作为判断标准，需要传入一个以列名称构成的list作为参数。同时，默认条件下函数会保留第一个发现的行，如果想取最后一个发现的行，需要传入<code>keep='last'</code>参数。</p>
<p>下面是一些使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_duplicate=pd.DataFrame(&#123;<span class="string">&#x27;k1&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>] * <span class="number">3</span> + [<span class="string">&#x27;two&#x27;</span>] * <span class="number">4</span>, <span class="string">&#x27;k2&#x27;</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_duplicate</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>k1</th>
      <th>k2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>one</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>one</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>one</td>
      <td>2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>two</td>
      <td>3</td>
    </tr>
    <tr>
      <th>4</th>
      <td>two</td>
      <td>3</td>
    </tr>
    <tr>
      <th>5</th>
      <td>two</td>
      <td>4</td>
    </tr>
    <tr>
      <th>6</th>
      <td>two</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_duplicate.duplicated() <span class="comment">#生成一个布尔类型的Series，表示每行是否为重复行</span></span><br></pre></td></tr></table></figure>
<pre><code>0    False
1     True
2    False
3    False
4     True
5    False
6     True
dtype: bool
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_duplicate.drop_duplicates() <span class="comment">#丢掉重复数据，默认保留第一个发现的行</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>k1</th>
      <th>k2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>one</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>one</td>
      <td>2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>two</td>
      <td>3</td>
    </tr>
    <tr>
      <th>5</th>
      <td>two</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_duplicate.drop_duplicates([<span class="string">&#x27;k1&#x27;</span>]) <span class="comment">#以名为&#x27;k1&#x27;的列作为判断标准，只要k1这一列的数据重复便视作是重复行</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>k1</th>
      <th>k2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>one</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>two</td>
      <td>3</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_duplicate.drop_duplicates([<span class="string">&#x27;k1&#x27;</span>],keep=<span class="string">&#x27;last&#x27;</span>) <span class="comment">#保留重复数据的最后一个</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>k1</th>
      <th>k2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2</th>
      <td>one</td>
      <td>2</td>
    </tr>
    <tr>
      <th>6</th>
      <td>two</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>
<h2 id="函数与映射-2"><a class="markdownIt-Anchor" href="#函数与映射-2"></a> 函数与映射</h2>
<p><code>map()</code>函数支持传入一个函数或者dict变量，从而对一个Series中的所有数据做映射，得到转换后的数据。注意这一操作不能对DataFrame进行。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataframe_map = pd.DataFrame(&#123;<span class="string">&#x27;food&#x27;</span>: [<span class="string">&#x27;bacon&#x27;</span>, <span class="string">&#x27;pulled pork&#x27;</span>, <span class="string">&#x27;bacon&#x27;</span>, <span class="string">&#x27;Pastrami&#x27;</span>,<span class="string">&#x27;corned beef&#x27;</span>, <span class="string">&#x27;Bacon&#x27;</span>, <span class="string">&#x27;pastrami&#x27;</span>, <span class="string">&#x27;honey ham&#x27;</span>, <span class="string">&#x27;nova lox&#x27;</span>],<span class="string">&#x27;ounces&#x27;</span>: [<span class="number">4</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line">meat_to_animal = &#123;<span class="string">&#x27;bacon&#x27;</span>: <span class="string">&#x27;pig&#x27;</span>,<span class="string">&#x27;pulled pork&#x27;</span>: <span class="string">&#x27;pig&#x27;</span>,<span class="string">&#x27;pastrami&#x27;</span>: <span class="string">&#x27;cow&#x27;</span>,<span class="string">&#x27;corned beef&#x27;</span>: <span class="string">&#x27;cow&#x27;</span>,<span class="string">&#x27;honey ham&#x27;</span>: <span class="string">&#x27;pig&#x27;</span>,<span class="string">&#x27;nova lox&#x27;</span>: <span class="string">&#x27;salmon&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_map</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>food</th>
      <th>ounces</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>bacon</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>pulled pork</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>bacon</td>
      <td>12.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Pastrami</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>corned beef</td>
      <td>7.5</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Bacon</td>
      <td>8.0</td>
    </tr>
    <tr>
      <th>6</th>
      <td>pastrami</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>7</th>
      <td>honey ham</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>8</th>
      <td>nova lox</td>
      <td>6.0</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_map[<span class="string">&#x27;animal&#x27;</span>]=dataframe_map[<span class="string">&#x27;food&#x27;</span>].map(str.lower).map(meat_to_animal) <span class="comment">#先使用函数进行映射，再使用dict进行映射</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_map</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>food</th>
      <th>ounces</th>
      <th>animal</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>bacon</td>
      <td>4.0</td>
      <td>pig</td>
    </tr>
    <tr>
      <th>1</th>
      <td>pulled pork</td>
      <td>3.0</td>
      <td>pig</td>
    </tr>
    <tr>
      <th>2</th>
      <td>bacon</td>
      <td>12.0</td>
      <td>pig</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Pastrami</td>
      <td>6.0</td>
      <td>cow</td>
    </tr>
    <tr>
      <th>4</th>
      <td>corned beef</td>
      <td>7.5</td>
      <td>cow</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Bacon</td>
      <td>8.0</td>
      <td>pig</td>
    </tr>
    <tr>
      <th>6</th>
      <td>pastrami</td>
      <td>3.0</td>
      <td>cow</td>
    </tr>
    <tr>
      <th>7</th>
      <td>honey ham</td>
      <td>5.0</td>
      <td>pig</td>
    </tr>
    <tr>
      <th>8</th>
      <td>nova lox</td>
      <td>6.0</td>
      <td>salmon</td>
    </tr>
  </tbody>
</table>
</div>
<h2 id="数据替换"><a class="markdownIt-Anchor" href="#数据替换"></a> 数据替换</h2>
<p>使用<code>replace</code>函数，可以对Series或者DataFrame中的某些值进行替换。<code>replace</code>函数可以传入两个参数，第一个代表需要替换的值，可以是一个值，也可以是一个list；第二个代表要替换成的值，可以是一个值，也可以是一个与第一个参数大小相同的list。也或者是只传入一个dict作为参数。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_replace=dataframe_map</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_replace</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>food</th>
      <th>ounces</th>
      <th>animal</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>bacon</td>
      <td>4.0</td>
      <td>pig</td>
    </tr>
    <tr>
      <th>1</th>
      <td>pulled pork</td>
      <td>3.0</td>
      <td>pig</td>
    </tr>
    <tr>
      <th>2</th>
      <td>bacon</td>
      <td>12.0</td>
      <td>pig</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Pastrami</td>
      <td>6.0</td>
      <td>cow</td>
    </tr>
    <tr>
      <th>4</th>
      <td>corned beef</td>
      <td>7.5</td>
      <td>cow</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Bacon</td>
      <td>8.0</td>
      <td>pig</td>
    </tr>
    <tr>
      <th>6</th>
      <td>pastrami</td>
      <td>3.0</td>
      <td>cow</td>
    </tr>
    <tr>
      <th>7</th>
      <td>honey ham</td>
      <td>5.0</td>
      <td>pig</td>
    </tr>
    <tr>
      <th>8</th>
      <td>nova lox</td>
      <td>6.0</td>
      <td>salmon</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_replace.replace(<span class="string">&#x27;pig&#x27;</span>,<span class="string">&#x27;PIG&#x27;</span>) <span class="comment">#传入两个值，一个代表要替换的元素，另一个代表替换后的元素</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>food</th>
      <th>ounces</th>
      <th>animal</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>bacon</td>
      <td>4.0</td>
      <td>PIG</td>
    </tr>
    <tr>
      <th>1</th>
      <td>pulled pork</td>
      <td>3.0</td>
      <td>PIG</td>
    </tr>
    <tr>
      <th>2</th>
      <td>bacon</td>
      <td>12.0</td>
      <td>PIG</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Pastrami</td>
      <td>6.0</td>
      <td>cow</td>
    </tr>
    <tr>
      <th>4</th>
      <td>corned beef</td>
      <td>7.5</td>
      <td>cow</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Bacon</td>
      <td>8.0</td>
      <td>PIG</td>
    </tr>
    <tr>
      <th>6</th>
      <td>pastrami</td>
      <td>3.0</td>
      <td>cow</td>
    </tr>
    <tr>
      <th>7</th>
      <td>honey ham</td>
      <td>5.0</td>
      <td>PIG</td>
    </tr>
    <tr>
      <th>8</th>
      <td>nova lox</td>
      <td>6.0</td>
      <td>salmon</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_replace.replace([<span class="string">&#x27;pig&#x27;</span>,<span class="string">&#x27;bacon&#x27;</span>],[np.nan,<span class="string">&#x27;Bacon&#x27;</span>]) <span class="comment">#传入两个list，按照list中的顺序对应起来进行替换。注意NaN可以参与到替换操作中去</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>food</th>
      <th>ounces</th>
      <th>animal</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Bacon</td>
      <td>4.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>pulled pork</td>
      <td>3.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Bacon</td>
      <td>12.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Pastrami</td>
      <td>6.0</td>
      <td>cow</td>
    </tr>
    <tr>
      <th>4</th>
      <td>corned beef</td>
      <td>7.5</td>
      <td>cow</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Bacon</td>
      <td>8.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>6</th>
      <td>pastrami</td>
      <td>3.0</td>
      <td>cow</td>
    </tr>
    <tr>
      <th>7</th>
      <td>honey ham</td>
      <td>5.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>8</th>
      <td>nova lox</td>
      <td>6.0</td>
      <td>salmon</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_replace.replace(&#123;<span class="number">4.0</span>:<span class="number">-4.0</span>,<span class="number">7.5</span>:<span class="number">-7.5</span>&#125;) <span class="comment">#传入一个dict进行替换，key作为要替换的值，用对应的value作为替换后的值</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>food</th>
      <th>ounces</th>
      <th>animal</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>bacon</td>
      <td>-4.0</td>
      <td>pig</td>
    </tr>
    <tr>
      <th>1</th>
      <td>pulled pork</td>
      <td>3.0</td>
      <td>pig</td>
    </tr>
    <tr>
      <th>2</th>
      <td>bacon</td>
      <td>12.0</td>
      <td>pig</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Pastrami</td>
      <td>6.0</td>
      <td>cow</td>
    </tr>
    <tr>
      <th>4</th>
      <td>corned beef</td>
      <td>-7.5</td>
      <td>cow</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Bacon</td>
      <td>8.0</td>
      <td>pig</td>
    </tr>
    <tr>
      <th>6</th>
      <td>pastrami</td>
      <td>3.0</td>
      <td>cow</td>
    </tr>
    <tr>
      <th>7</th>
      <td>honey ham</td>
      <td>5.0</td>
      <td>pig</td>
    </tr>
    <tr>
      <th>8</th>
      <td>nova lox</td>
      <td>6.0</td>
      <td>salmon</td>
    </tr>
  </tbody>
</table>
</div>
<h2 id="频数统计"><a class="markdownIt-Anchor" href="#频数统计"></a> 频数统计</h2>
<p>Pandas中的<code>cut()</code>函数可以对一个list中的数据按照给定的区间进行分类，从而进一步统计它们的频数。下面为一些使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ages=[<span class="number">20</span>, <span class="number">22</span>, <span class="number">25</span>, <span class="number">27</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">37</span>, <span class="number">31</span>, <span class="number">61</span>, <span class="number">45</span>, <span class="number">41</span>, <span class="number">32</span>] </span><br><span class="line">bins=[<span class="number">18</span>,<span class="number">25</span>,<span class="number">35</span>,<span class="number">60</span>,<span class="number">100</span>]</span><br><span class="line">cats=pd.cut(ages,bins)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cats <span class="comment">#cut操作得到的变量类型为categorical，包含两个属性。其中一个是labels，为一个list，内容为元素对应的区间编号；另一个是levels，它是一个list，内容为区间。默认条件下形成的区间为左开右闭区间。</span></span><br></pre></td></tr></table></figure>
<pre><code>[(18, 25], (18, 25], (18, 25], (25, 35], (18, 25], ..., (25, 35], (60, 100], (35, 60], (35, 60], (25, 35]]
Length: 12
Categories (4, interval[int64]): [(18, 25] &lt; (25, 35] &lt; (35, 60] &lt; (60, 100]]
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.value_counts(cats) <span class="comment">#借助value_counts函数，可以将categorical类型的变量转化为一个series，series的内容是区间与频数的对应关系</span></span><br></pre></td></tr></table></figure>
<pre><code>(18, 25]     5
(35, 60]     3
(25, 35]     3
(60, 100]    1
dtype: int64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.cut(ages,bins,right=<span class="literal">False</span>) <span class="comment">#可以传入right=False参数，得到左闭右开区间</span></span><br></pre></td></tr></table></figure>
<pre><code>[[18, 25), [18, 25), [25, 35), [25, 35), [18, 25), ..., [25, 35), [60, 100), [35, 60), [35, 60), [25, 35)]
Length: 12
Categories (4, interval[int64]): [[18, 25) &lt; [25, 35) &lt; [35, 60) &lt; [60, 100)]
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">group_names = [<span class="string">&#x27;Youth&#x27;</span>, <span class="string">&#x27;YoungAdult&#x27;</span>, <span class="string">&#x27;MiddleAged&#x27;</span>, <span class="string">&#x27;Senior&#x27;</span>]</span><br><span class="line">pd.cut(ages,bins,labels=group_names) <span class="comment">#可以使用labels参数，这个参数接收一个list，list的大小与区间数相等，其中的内容为区间的名称。这样在输出时，区间会被自动替换为对应的名称</span></span><br></pre></td></tr></table></figure>
<pre><code>[Youth, Youth, Youth, YoungAdult, Youth, ..., YoungAdult, Senior, MiddleAged, MiddleAged, YoungAdult]
Length: 12
Categories (4, object): [Youth &lt; YoungAdult &lt; MiddleAged &lt; Senior]
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.cut(ages,<span class="number">4</span>,precision=<span class="number">2</span>) <span class="comment">#可以传入一个数字，来表示将区间均匀地分成若干等份。函数会自动根据最大和最小值算出区间大小。同时可以传入precision参数表示计算区间大小时的小数点位数。</span></span><br></pre></td></tr></table></figure>
<pre><code>[(19.96, 30.25], (19.96, 30.25], (19.96, 30.25], (19.96, 30.25], (19.96, 30.25], ..., (30.25, 40.5], (50.75, 61.0], (40.5, 50.75], (40.5, 50.75], (30.25, 40.5]]
Length: 12
Categories (4, interval[float64]): [(19.96, 30.25] &lt; (30.25, 40.5] &lt; (40.5, 50.75] &lt; (50.75, 61.0]]
</code></pre>
<p>另一个功能相近的函数为<code>qcut()</code>。这个函数的用法有两种：第一种是传入一个整数，代表将所有元素均分为若干份，然后根据均分结果得到区间范围；第二种是传入一个list，list中的元素为0到1递增的数字，每个数字代表在该分位数处作为一个区间的起点/终点。用法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_qcut=np.random.randn(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.qcut(data_qcut,<span class="number">5</span>) <span class="comment">#传入一个数字，表示将所有元素均分成若干个区间</span></span><br></pre></td></tr></table></figure>
<pre><code>[(0.787, 2.964], (-3.3779999999999997, -0.802], (-0.802, -0.226], (-0.802, -0.226], (-3.3779999999999997, -0.802], ..., (-0.802, -0.226], (-0.226, 0.236], (-0.226, 0.236], (0.236, 0.787], (-0.802, -0.226]]
Length: 1000
Categories (5, interval[float64]): [(-3.3779999999999997, -0.802] &lt; (-0.802, -0.226] &lt; (-0.226, 0.236] &lt; (0.236, 0.787] &lt; (0.787, 2.964]]
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.value_counts(pd.qcut(data_qcut,<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<pre><code>(0.787, 2.964]                   200
(0.236, 0.787]                   200
(-0.226, 0.236]                  200
(-0.802, -0.226]                 200
(-3.3779999999999997, -0.802]    200
dtype: int64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.qcut(data_qcut,[<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">0.5</span>,<span class="number">0.9</span>,<span class="number">1</span>]) <span class="comment">#传入list，使用list中的值作为分位数来划分区间</span></span><br></pre></td></tr></table></figure>
<pre><code>[(1.267, 2.964], (-1.179, -0.0053], (-1.179, -0.0053], (-1.179, -0.0053], (-1.179, -0.0053], ..., (-1.179, -0.0053], (-1.179, -0.0053], (-0.0053, 1.267], (-0.0053, 1.267], (-1.179, -0.0053]]
Length: 1000
Categories (4, interval[float64]): [(-3.3779999999999997, -1.179] &lt; (-1.179, -0.0053] &lt; (-0.0053, 1.267] &lt; (1.267, 2.964]]
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.value_counts(pd.qcut(data_qcut,[<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">0.5</span>,<span class="number">0.9</span>,<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<pre><code>(-0.0053, 1.267]                 400
(-1.179, -0.0053]                400
(1.267, 2.964]                   100
(-3.3779999999999997, -1.179]    100
dtype: int64
</code></pre>
<h2 id="dummy变量"><a class="markdownIt-Anchor" href="#dummy变量"></a> Dummy变量</h2>
<p>在Series或DataFrame中，某些列可能为类别型的变量。而在机器学习等任务中，类别型的变量可能无法被识别，因此需要将其转换为数字。Pandas的<code>get_dummies()</code>函数便可以完成这一功能。</p>
<p><code>get_dummies</code>需要将一个Series或者DataFrame作为输入。假设某一列中的数据含有k个类别，在这一操作之后会生成出k列。其中每一列都代表k种类别中的某一个，全部用0或1填充，某一列为1则代表这个类别是原始列中这一行的数据。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_dummy=pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],<span class="string">&#x27;data1&#x27;</span>: range(<span class="number">6</span>),<span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_dummy</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>data1</th>
      <th>key2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>b</td>
      <td>0</td>
      <td>b</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>1</td>
      <td>b</td>
    </tr>
    <tr>
      <th>2</th>
      <td>a</td>
      <td>2</td>
      <td>a</td>
    </tr>
    <tr>
      <th>3</th>
      <td>c</td>
      <td>3</td>
      <td>c</td>
    </tr>
    <tr>
      <th>4</th>
      <td>a</td>
      <td>4</td>
      <td>a</td>
    </tr>
    <tr>
      <th>5</th>
      <td>b</td>
      <td>5</td>
      <td>d</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.get_dummies(dataframe_dummy) <span class="comment">#传入DataFrame时，这一函数会自动将类别型的列全部转换为dummy变量，同时自动为这些列构造列名。</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>data1</th>
      <th>key_a</th>
      <th>key_b</th>
      <th>key_c</th>
      <th>key2_a</th>
      <th>key2_b</th>
      <th>key2_c</th>
      <th>key2_d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>5</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.get_dummies(dataframe_dummy[<span class="string">&#x27;key&#x27;</span>]) <span class="comment">#如果传入的是一个Series，由于Series本身没有列名，因此默认会使用类别型变量自身的名称作为列名。</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.get_dummies(dataframe_dummy[<span class="string">&#x27;key&#x27;</span>],prefix=<span class="string">&#x27;Key&#x27;</span>)<span class="comment">#可以手动传入prefix参数，作为列名的前缀。</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Key_a</th>
      <th>Key_b</th>
      <th>Key_c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>
<h2 id="字符串的处理"><a class="markdownIt-Anchor" href="#字符串的处理"></a> 字符串的处理</h2>
<p>Pandas中提供了一些矢量化的字符串函数，可以用来批量处理Series或者DataFrame中的字符串。包括：</p>
<ul>
<li>cat：将字符串拼接起来，并可以使用分隔符</li>
<li>contains：判断字符串是否含有特定的子串</li>
<li>count：判断特定的子串出现的次数</li>
<li>endswith/startswith：是否以某个特定的子串作为开头/结尾</li>
<li>findall：找到子串或者正则表达式出现过的所有地方</li>
<li>get：对字符串做索引</li>
<li>join：使用分隔符将字符串拼接起来</li>
<li>len：计算字符串长度</li>
<li>lower/upper：转换为大写/小写</li>
<li>match：使用正则表达式进行匹配，找到匹配的部分</li>
<li>pad：在字符串的左侧/右侧/双侧(等价于center函数)添加空格</li>
<li>repeat：将字符串重复若干次</li>
<li>replace：将某个子串或者正则表达式匹配到的部分替换为其他字符串</li>
<li>slice：将字符串进行分割</li>
<li>split：根据某个分隔符或者正则表达式对字符串进行分割</li>
<li>strip/rstrip/lstrip：切掉空格，然后替换成换行</li>
</ul>
<p>这些用法与Python自带的字符串处理函数或是正则表达式处理函数类似，此处不再赘述。</p>
<h1 id="多层index"><a class="markdownIt-Anchor" href="#多层index"></a> 多层index</h1>
<p>Pandas中实现了一种叫做MultiIndex的类，允许Series和DataFrame有多层的index。</p>
<p>下面是Series中使用多层index的一些相关操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_multiIndex=pd.Series(np.random.randn(<span class="number">10</span>),index=[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]]) <span class="comment">#创建一个具有多重index的Series</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_multiIndex</span><br></pre></td></tr></table></figure>
<pre><code>a  1    2.862886
   2    1.973711
   3    1.367350
b  1    1.245817
   2    1.270334
   3    0.872359
c  1    0.651468
   2   -0.454727
d  2    1.249058
   3    0.591254
dtype: float64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_multiIndex.index <span class="comment">#此时，访问其index属性，则会得到一个MultiIndex</span></span><br></pre></td></tr></table></figure>
<pre><code>MultiIndex([('a', 1),
            ('a', 2),
            ('a', 3),
            ('b', 1),
            ('b', 2),
            ('b', 3),
            ('c', 1),
            ('c', 2),
            ('d', 2),
            ('d', 3)],
           )
</code></pre>
<p>MultiIndex可以通过传入嵌套数组来创建：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.MultiIndex.from_arrays([[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>], [<span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Red&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>]],names=[<span class="string">&#x27;state&#x27;</span>,<span class="string">&#x27;color&#x27;</span>]) <span class="comment">#多层index中的每一层都可以有一个名字</span></span><br></pre></td></tr></table></figure>
<pre><code>MultiIndex([(    'Ohio', 'Green'),
            (    'Ohio',   'Red'),
            ('Colorado', 'Green')],
           names=['state', 'color'])
</code></pre>
<p>对具有多重index的Series或者DataFrame，在做索引操作时需要同时传入内外层的索引元素。因此，这与单层index的索引操作有些不同，下面以例子进行说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_multiIndex[<span class="string">&#x27;b&#x27;</span>] <span class="comment">#如果仅使用外层的index进行索引，则可以省略掉内层的index</span></span><br></pre></td></tr></table></figure>
<pre><code>1    1.245817
2    1.270334
3    0.872359
dtype: float64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_multiIndex[(<span class="string">&#x27;b&#x27;</span>,<span class="number">1</span>)] <span class="comment">#同时使用两层index进行索引，等同于语句series_multiIndex[&#x27;b&#x27;,1]</span></span><br></pre></td></tr></table></figure>
<pre><code>1.2458169817277376
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_multiIndex[[<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]] <span class="comment">#在传入list进行索引时，就不能再使用内层的索引。如series_multiIndex[[&#x27;b&#x27;,&#x27;d&#x27;],[2,3]]便为错误操作</span></span><br></pre></td></tr></table></figure>
<pre><code>b  1    1.245817
   2    1.270334
   3    0.872359
d  2    1.249058
   3    0.591254
dtype: float64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_multiIndex[:,<span class="number">1</span>] <span class="comment">#仅使用内层进行索引，需要用:来指明使用外层的全部索引。如果不指定外层，直接用内层的index进行索引就会报错。但是需要注意此时内层的索引不能使用list，例如series_multiIndex[:,[1,2]]的操作便是错误的。</span></span><br></pre></td></tr></table></figure>
<pre><code>a    2.862886
b    1.245817
c    0.651468
dtype: float64
</code></pre>
<p>注意：在MultiIndex中使用整数序号进行索引时会比较容易混淆。其基本规则可以大致描述为，多重index在使用整数索引时，会优先匹配index中是否包含这个整数，如果没有则将其作为序号进行索引。下面进行详细的说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_multiIndex[<span class="number">1</span>] <span class="comment">#在本例中，这一索引语句是按照元素的排列顺序来索引。</span></span><br></pre></td></tr></table></figure>
<pre><code>1.973710915404737
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">series_multiIndex2=pd.Series(np.random.randn(<span class="number">10</span>),index=[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>],[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]]) </span><br><span class="line">series_multiIndex2[<span class="number">1</span>] <span class="comment">#此时最外层的index为整数，因此在索引时是使用外层index进行索引的</span></span><br></pre></td></tr></table></figure>
<pre><code>a   -0.041453
b   -0.329131
c   -0.776732
dtype: float64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_multiIndex2[<span class="number">4</span>] <span class="comment">#由于外层index中不包含4，因此按照元素的排列顺序，索引第5个元素。但是在单层的index中，如果使用不包含在index中的整数进行索引则会报错。</span></span><br></pre></td></tr></table></figure>
<pre><code>0.7369307651244501
</code></pre>
<p>对于使用两层index的Series来说，如果要解除多层index，可以使用<code>unstack()</code>函数；它相应的反操作为<code>stack()</code>。<code>stack</code>操作的实质是将某个columns“旋转”至index，而<code>unstack</code>操作则是将某个index“旋转”至columns。</p>
<p>此处有一些简单的示例，在下面的内容中还会对这一操作进行进一步的分析。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_multiIndex.unstack() <span class="comment">#对一个Series做unstack操作，会得到一个DataFrame。默认对最里层做unstack操作。</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>2.862886</td>
      <td>1.973711</td>
      <td>1.367350</td>
    </tr>
    <tr>
      <th>b</th>
      <td>1.245817</td>
      <td>1.270334</td>
      <td>0.872359</td>
    </tr>
    <tr>
      <th>c</th>
      <td>0.651468</td>
      <td>-0.454727</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>d</th>
      <td>NaN</td>
      <td>1.249058</td>
      <td>0.591254</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_multiIndex.unstack(level=<span class="number">0</span>) <span class="comment">#如果想改变unstack操作使用的index，可以传入level参数指定使用哪一层的index</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>2.862886</td>
      <td>1.245817</td>
      <td>0.651468</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1.973711</td>
      <td>1.270334</td>
      <td>-0.454727</td>
      <td>1.249058</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1.367350</td>
      <td>0.872359</td>
      <td>NaN</td>
      <td>0.591254</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_multiIndex.unstack(level=<span class="number">0</span>).stack() <span class="comment">#与上面的结果对比，可以看出stack()操作默认是将columns“旋转”到index的最里层。unstack()操作也是类似的规则，此处不再用程序展示。如果有多层的index，也可以传入level参数设置传入到哪一层的下面。</span></span><br></pre></td></tr></table></figure>
<pre><code>1  a    2.862886
   b    1.245817
   c    0.651468
2  a    1.973711
   b    1.270334
   c   -0.454727
   d    1.249058
3  a    1.367350
   b    0.872359
   d    0.591254
dtype: float64
</code></pre>
<p>如果要改变层级顺序，可以使用swaplevel函数，在交换前后，Series中的元素顺序保持不变：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_multiIndex.swaplevel(<span class="number">0</span>,<span class="number">1</span>) <span class="comment">#需要传入两个整数指定要交换的两层。如果每一层有自己的名字，也可以传入名字来指定要交换的层</span></span><br></pre></td></tr></table></figure>
<pre><code>1  a    2.862886
2  a    1.973711
3  a    1.367350
1  b    1.245817
2  b    1.270334
3  b    0.872359
1  c    0.651468
2  c   -0.454727
   d    1.249058
3  d    0.591254
dtype: float64
</code></pre>
<p>在部分统计函数中，可以添加level参数，这样便可以根据指定的level做统计：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">series_multiIndex.sum(level=<span class="number">1</span>) </span><br></pre></td></tr></table></figure>
<pre><code>1    4.760171
2    4.038376
3    2.830964
dtype: float64
</code></pre>
<p>对于DataFrame来说，index和columns都可以使用MultiIndex。下面为一些使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_multiIndex= pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)),index=[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]],columns=[[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>],[<span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Red&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>]])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_multiIndex</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th colspan="2" halign="left">Ohio</th>
      <th>Colorado</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Green</th>
      <th>Red</th>
      <th>Green</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">a</th>
      <th>1</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>1</th>
      <td>6</td>
      <td>7</td>
      <td>8</td>
    </tr>
    <tr>
      <th>2</th>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
</div>
<p>在DataFrame中，可以使用<code>set_index</code>函数指定某个或某些列来作为index；它的反操作是<code>reset_index</code>，可以将某个或某些index转化为列插入进DataFrame中去。下面是一些实例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_multiIndex2=pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: range(<span class="number">7</span>), <span class="string">&#x27;b&#x27;</span>: range(<span class="number">7</span>, <span class="number">0</span>, <span class="number">-1</span>),<span class="string">&#x27;c&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>],<span class="string">&#x27;d&#x27;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;,index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_multiIndex2</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0</td>
      <td>7</td>
      <td>one</td>
      <td>0</td>
    </tr>
    <tr>
      <th>b</th>
      <td>1</td>
      <td>6</td>
      <td>one</td>
      <td>1</td>
    </tr>
    <tr>
      <th>c</th>
      <td>2</td>
      <td>5</td>
      <td>one</td>
      <td>2</td>
    </tr>
    <tr>
      <th>d</th>
      <td>3</td>
      <td>4</td>
      <td>two</td>
      <td>0</td>
    </tr>
    <tr>
      <th>e</th>
      <td>4</td>
      <td>3</td>
      <td>two</td>
      <td>1</td>
    </tr>
    <tr>
      <th>f</th>
      <td>5</td>
      <td>2</td>
      <td>two</td>
      <td>2</td>
    </tr>
    <tr>
      <th>g</th>
      <td>6</td>
      <td>1</td>
      <td>two</td>
      <td>3</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_multiIndex2.set_index([<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]) <span class="comment">#默认情况下，选作index的列在生成的新DataFrame中不会显示。如果传入一个list，那么多层index的层级顺序是按照list中的元素顺序从外到里。同时，这些列之前的列名也会自动被转化为index对应的名称。注意：这一操作会覆盖掉之前的index。</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>a</th>
      <th>b</th>
    </tr>
    <tr>
      <th>c</th>
      <th>d</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3" valign="top">one</th>
      <th>0</th>
      <td>0</td>
      <td>7</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>6</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>5</td>
    </tr>
    <tr>
      <th rowspan="4" valign="top">two</th>
      <th>0</th>
      <td>3</td>
      <td>4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4</td>
      <td>3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>5</td>
      <td>2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>6</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_multiIndex2.set_index([<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;c&#x27;</span>],drop=<span class="literal">False</span>) <span class="comment">#传入drop=False，变为index的两列便不会被删除。</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
    <tr>
      <th>d</th>
      <th>c</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <th>one</th>
      <td>0</td>
      <td>7</td>
      <td>one</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <th>one</th>
      <td>1</td>
      <td>6</td>
      <td>one</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <th>one</th>
      <td>2</td>
      <td>5</td>
      <td>one</td>
      <td>2</td>
    </tr>
    <tr>
      <th>0</th>
      <th>two</th>
      <td>3</td>
      <td>4</td>
      <td>two</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <th>two</th>
      <td>4</td>
      <td>3</td>
      <td>two</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <th>two</th>
      <td>5</td>
      <td>2</td>
      <td>two</td>
      <td>2</td>
    </tr>
    <tr>
      <th>3</th>
      <th>two</th>
      <td>6</td>
      <td>1</td>
      <td>two</td>
      <td>3</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_multiIndex.reset_index([<span class="number">0</span>,<span class="number">1</span>]) <span class="comment">#将index变为列插入到DataFrame中去。如果之前的index有名字，那么这个名字会变为列名，否则会为生成的列自动生成一个名字。需要注意的是，如果原来的columns具有多层，那么新转换得到的列名位于最外层，且它的内层为空。</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>level_0</th>
      <th>level_1</th>
      <th colspan="2" halign="left">Ohio</th>
      <th>Colorado</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th></th>
      <th>Green</th>
      <th>Red</th>
      <th>Green</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>a</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>1</th>
      <td>a</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>b</td>
      <td>1</td>
      <td>6</td>
      <td>7</td>
      <td>8</td>
    </tr>
    <tr>
      <th>3</th>
      <td>b</td>
      <td>2</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
</div>
<h1 id="数据的重构与组合"><a class="markdownIt-Anchor" href="#数据的重构与组合"></a> 数据的重构与组合</h1>
<h2 id="按列合并"><a class="markdownIt-Anchor" href="#按列合并"></a> 按列合并</h2>
<p>merge函数可以将两个DataFrame按列合并起来，这一函数要求在两个DataFrame中各自选择一列，然后按照这一列中元素的对应关系，将两个DataFrame合并为一个。默认情况下，函数会自己选择名称相同的列。</p>
<p>默认情况下，只有当某个元素在两个DataFrame里面选中的列内都出现时（即交集），最终合并得到的DataFrame中才会包含有相应元素；只出现在其中一个DataFrame中的元素会被舍去。</p>
<p><code>merge()</code>函数支持传入下面的可选参数：</p>
<ul>
<li>left：以左侧的DataFrame为基准进行合并</li>
<li>right：以右侧的DataFrame为基准进行合并</li>
<li>how：可以选择’inner’，‘outer’，'left’和’right’四种模式。四种模式的意义如下：
<ul>
<li>inner：左右两侧元素保留交集部分（默认操作）</li>
<li>outer：左右两侧元素全部保留</li>
<li>left：保留仅出现在左边的元素，舍去仅出现在右边的元素</li>
<li>right：保留仅出现在右边的元素，舍去仅出现在左边的元素</li>
</ul>
</li>
<li>on：指定参与合并操作的列名</li>
<li>left_on：指定左侧DataFrame中参与合并操作的列名</li>
<li>right_on：指定右侧DataFrame中参与合并操作的列名</li>
<li>left_index：是否使用左侧DataFrame的index参与合并，默认为False</li>
<li>right_index：是否使用右侧DataFrame的index参与合并，默认为False</li>
<li>sort：是否按照参与合并的元素对DataFrame进行排序，默认为True。如果要处理大表格时可以使用False来加快速度</li>
<li>suffixes：传入一个二元的tuple用于区分数据来自于哪一个DataFrame，当出现重名的columns时则会自动在这些columns后面加上后缀。默认值为<code>('_x'和'_y')</code></li>
<li>copy：是否生成原始数据的副本，默认为True</li>
</ul>
<p>下面为一些使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataframe_merge1=pd.DataFrame(&#123;<span class="string">&#x27;value&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],<span class="string">&#x27;data1&#x27;</span>: range(<span class="number">7</span>)&#125;)</span><br><span class="line">dataframe_merge2=pd.DataFrame(&#123;<span class="string">&#x27;value&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],<span class="string">&#x27;data2&#x27;</span>: range(<span class="number">3</span>)&#125;)</span><br><span class="line">pd.merge(dataframe_merge1,dataframe_merge2) <span class="comment">#默认自动选取名称相同的column</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>value</th>
      <th>data1</th>
      <th>data2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>b</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>b</td>
      <td>6</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>a</td>
      <td>2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>a</td>
      <td>4</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>a</td>
      <td>5</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(dataframe_merge1,dataframe_merge2,on=<span class="string">&#x27;value&#x27;</span>) <span class="comment">#可以传入on参数手动指定merge操作所参考的列，这一操作当两个DataFrame中存在多个名称相同的列时可以避免非期望的结果。</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>value</th>
      <th>data1</th>
      <th>data2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>b</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>b</td>
      <td>6</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>a</td>
      <td>2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>a</td>
      <td>4</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>a</td>
      <td>5</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(dataframe_merge1,dataframe_merge2,left_on=<span class="string">&#x27;data1&#x27;</span>,right_on=<span class="string">&#x27;data2&#x27;</span>) <span class="comment">#也可以手动指定两个名称不同的列进行合并操作。如果合并之前存在相同列名，会在合并之后将它们区分开</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>value_x</th>
      <th>data1</th>
      <th>value_y</th>
      <th>data2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>b</td>
      <td>0</td>
      <td>a</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>1</td>
      <td>b</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>a</td>
      <td>2</td>
      <td>d</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataframe_merge3=pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>], <span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>], <span class="string">&#x27;lval&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line">dataframe_merge4=pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],<span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>], <span class="string">&#x27;rval&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(dataframe_merge3,dataframe_merge4,on=[<span class="string">&#x27;key1&#x27;</span>,<span class="string">&#x27;key2&#x27;</span>],how=<span class="string">&#x27;outer&#x27;</span>) <span class="comment">#on参数可以传入多个列名，代表按照多列进行合并</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key1</th>
      <th>key2</th>
      <th>lval</th>
      <th>rval</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>foo</td>
      <td>one</td>
      <td>1.0</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>foo</td>
      <td>one</td>
      <td>1.0</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>foo</td>
      <td>two</td>
      <td>2.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>bar</td>
      <td>one</td>
      <td>3.0</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>bar</td>
      <td>two</td>
      <td>NaN</td>
      <td>7.0</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataframe_merge5=pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>], <span class="string">&#x27;key2&#x27;</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>],<span class="string">&#x27;data&#x27;</span>: np.arange(<span class="number">5.</span>)&#125;)</span><br><span class="line">dataframe_merge6=pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">6</span>, <span class="number">2</span>)), index=[[<span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>], [<span class="number">2001</span>, <span class="number">2000</span>, <span class="number">2000</span>, <span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>]],columns=[<span class="string">&#x27;event1&#x27;</span>, <span class="string">&#x27;event2&#x27;</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(dataframe_merge5,dataframe_merge6,left_on=[<span class="string">&#x27;key1&#x27;</span>,<span class="string">&#x27;key2&#x27;</span>],right_index=<span class="literal">True</span>,how=<span class="string">&#x27;outer&#x27;</span>) <span class="comment">#如果是与多层index进行合并，则需要同时传入多个列名，合并完成之后这些index会变为DataFrame中的列</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key1</th>
      <th>key2</th>
      <th>data</th>
      <th>event1</th>
      <th>event2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Ohio</td>
      <td>2000</td>
      <td>0.0</td>
      <td>4.0</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>0</th>
      <td>Ohio</td>
      <td>2000</td>
      <td>0.0</td>
      <td>6.0</td>
      <td>7.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Ohio</td>
      <td>2001</td>
      <td>1.0</td>
      <td>8.0</td>
      <td>9.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Ohio</td>
      <td>2002</td>
      <td>2.0</td>
      <td>10.0</td>
      <td>11.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Nevada</td>
      <td>2001</td>
      <td>3.0</td>
      <td>0.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Nevada</td>
      <td>2002</td>
      <td>4.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Nevada</td>
      <td>2000</td>
      <td>NaN</td>
      <td>2.0</td>
      <td>3.0</td>
    </tr>
  </tbody>
</table>
</div>
<p>与<code>merge()</code>函数功能类似的还有<code>join()</code>函数，用法为：<code>DataFrame1.join(DataFrame2)</code>。<code>join()</code>函数支持传入一个list，代表同时对三个及以上的DataFrame进行合并。<code>join()</code>函数可以使用的参数与<code>merge()</code>函数类似。</p>
<p>由于这两个函数的作用相同，此处不再赘述。</p>
<h2 id="拼接"><a class="markdownIt-Anchor" href="#拼接"></a> 拼接</h2>
<p>Pandas中的<code>concat</code>函数类似于NumPy中的<code>concatenate</code>函数，传入一个由series或dataframe组成的list，将它们拼接在一起。</p>
<p><code>concat</code>函数支持的参数包括：</p>
<ul>
<li>objs：一个包含了Pandas数据类型的list或者dict（必须传入的参数）</li>
<li>axis：进行拼接的方向，默认为行方向（即0）</li>
<li>join：‘inner’或者’outer’其中的一个，默认为’outer’。inner代表只留下index或者columns中的交集部分进行拼接，而outer则代表拼接操作按照并集的方式进行，没有对应元素的使用NaN填充</li>
<li>keys：指明一系列拼接时使用的关键字，它们用于在拼接之后形成多层index，从而区分出数据的来源</li>
<li>levels：如果传入keys参数，levels参数用于指明被用作层级index的哪一层</li>
<li>names：如果使用key或者level参数，设定它们在index中对应的名字</li>
<li>verify_integrity：检查数据是否有重复并报错，默认为False，即允许数据重复</li>
<li>ignore_index：在合并的维度上丢掉原来所有的index，将其重新编号为0至n-1</li>
</ul>
<p>下面是一些使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">series_concat1=pd.Series([<span class="number">0</span>,<span class="number">1</span>],index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">series_concat2=pd.Series([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],index=[<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">series_concat3=pd.Series([<span class="number">5</span>,<span class="number">6</span>],index=[<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>])</span><br><span class="line">dataframe_concat1=pd.DataFrame(np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>, <span class="number">2</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>])</span><br><span class="line">dataframe_concat2=pd.DataFrame(<span class="number">5</span> + np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>, <span class="number">2</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], columns=[<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.concat([series_concat1,series_concat2,series_concat3]) <span class="comment">#默认按照竖直方向合并</span></span><br></pre></td></tr></table></figure>
<pre><code>a    0
b    1
c    2
d    3
e    4
f    5
g    6
dtype: int64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.concat([series_concat1,series_concat2,series_concat3],axis=<span class="number">1</span>) <span class="comment">#按照水平方向合并，默认采用outer合并方式</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>b</th>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>c</th>
      <td>NaN</td>
      <td>2.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>d</th>
      <td>NaN</td>
      <td>3.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>e</th>
      <td>NaN</td>
      <td>4.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>f</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>g</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>6.0</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.concat([series_concat1,series_concat2,series_concat3],keys=[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>],names=[<span class="string">&#x27;upper&#x27;</span>,<span class="string">&#x27;lower&#x27;</span>]) <span class="comment">#在拼接完成之后将key作为额外的一层index来表示数据来源，并可以传入names为新的index中的每一层进行命名</span></span><br></pre></td></tr></table></figure>
<pre><code>upper  lower
one    a        0
       b        1
two    c        2
       d        3
       e        4
three  f        5
       g        6
dtype: int64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.concat([dataframe_concat1,dataframe_concat2],axis=<span class="number">1</span>,ignore_index=<span class="literal">True</span>) <span class="comment">#合并时忽略掉原有的index，为合并后的DataFrame赋予一个Range类型的index</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0</td>
      <td>1</td>
      <td>5.0</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>b</th>
      <td>2</td>
      <td>3</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>c</th>
      <td>4</td>
      <td>5</td>
      <td>7.0</td>
      <td>8.0</td>
    </tr>
  </tbody>
</table>
</div>
<h2 id="填充式合并"><a class="markdownIt-Anchor" href="#填充式合并"></a> 填充式合并</h2>
<p>Pandas中含有一个<code>x.combine_first(y)</code>函数，可以将y中有而x中没有的数据加入到x中，同时x中原有的数据不做任何修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataframe_combine1=pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">1.</span>, np.nan, <span class="number">5.</span>, np.nan],<span class="string">&#x27;b&#x27;</span>: [np.nan, <span class="number">2.</span>, np.nan, <span class="number">6.</span>],<span class="string">&#x27;c&#x27;</span>: range(<span class="number">2</span>, <span class="number">18</span>, <span class="number">4</span>)&#125;)</span><br><span class="line">dataframe_combine2=pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">5.</span>, <span class="number">4.</span>, np.nan, <span class="number">3.</span>, <span class="number">7.</span>],<span class="string">&#x27;b&#x27;</span>: [np.nan, <span class="number">3.</span>, <span class="number">4.</span>, <span class="number">6.</span>, <span class="number">8.</span>]&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_combine1.combine_first(dataframe_combine2) <span class="comment">#自动按照DataFrame中的列名进行列的匹配，并且只填充NaN，其余部分不变</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1.0</td>
      <td>NaN</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.0</td>
      <td>2.0</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>5.0</td>
      <td>4.0</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3.0</td>
      <td>6.0</td>
      <td>14.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>7.0</td>
      <td>8.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_combine2.combine_first(dataframe_combine1) <span class="comment">#注意这一操作的顺序是不可交换的</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5.0</td>
      <td>NaN</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.0</td>
      <td>3.0</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>5.0</td>
      <td>4.0</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3.0</td>
      <td>6.0</td>
      <td>14.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>7.0</td>
      <td>8.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>
<h2 id="重排与旋转"><a class="markdownIt-Anchor" href="#重排与旋转"></a> 重排与旋转</h2>
<p>Pandas中的<code>stack()</code>操作可以将某个columns“旋转”至index，与之对应的<code>unstack()</code>操作则是将某个index“旋转”至columns。这两个操作都会把选择的那层index或者column插入到最内层。</p>
<p>使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataframe_stack=pd.DataFrame(np.arange(<span class="number">6</span>).reshape((<span class="number">2</span>, <span class="number">3</span>)),index=pd.Index([<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>], name=<span class="string">&#x27;state&#x27;</span>),columns=pd.MultiIndex.from_arrays([[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>],[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]]))</span><br><span class="line">dataframe_stack</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead tr th {
        text-align: left;
    }
    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="2" halign="left">a</th>
      <th>b</th>
    </tr>
    <tr>
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
    </tr>
    <tr>
      <th>state</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Ohio</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>3</td>
      <td>4</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_stack.stack() <span class="comment">#stack默认选择最里层的columns，与之类似的是unstack默认选择的是最里层的index。需要注意stack和unstack操作都可能会产生NaN数据</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>a</th>
      <th>b</th>
    </tr>
    <tr>
      <th>state</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3" valign="top">Ohio</th>
      <th>one</th>
      <td>0.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>three</th>
      <td>NaN</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>two</th>
      <td>1.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">Colorado</th>
      <th>one</th>
      <td>3.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>three</th>
      <td>NaN</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>two</th>
      <td>4.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_stack.stack(level=<span class="number">0</span>) <span class="comment">#可以通过传入level参数来指定stack操作对哪一层columns进行操作。从外向里对应的level值由0开始递增，当然也可以传入负数做逆序索引。unstack也可以做类似操作</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>one</th>
      <th>three</th>
      <th>two</th>
    </tr>
    <tr>
      <th>state</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">Ohio</th>
      <th>a</th>
      <td>0.0</td>
      <td>NaN</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>b</th>
      <td>NaN</td>
      <td>2.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Colorado</th>
      <th>a</th>
      <td>3.0</td>
      <td>NaN</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>b</th>
      <td>NaN</td>
      <td>5.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_stack.unstack(<span class="string">&#x27;state&#x27;</span>) <span class="comment">#可以传入某一层对应的名称来进行操作</span></span><br></pre></td></tr></table></figure>
<pre><code>          state   
a  one    Ohio        0
          Colorado    3
   two    Ohio        1
          Colorado    4
b  three  Ohio        2
          Colorado    5
dtype: int32
</code></pre>
<p>pivot函数可以对一个DataFrame进行重排，要求这个DataFrame中的index为默认值。函数返回一个新的DataFrame。</p>
<p>如果传入三个及以上的列名称作为参数，第一个列中的内容会被转化为行的index，第二个列所包含的内容会被转化为column，之后，所有列中的内容会与index和column做对应，从而填充整个DataFrame；如果只传入两个列作为参数，那么第一列仍然作为index，原表格中的其它所有列都被保留下来，并与第二个列的内容共同构成一个多层的columns。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_pivot=pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>], <span class="string">&#x27;A&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&#x27;B&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="string">&#x27;C&#x27;</span>: [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_pivot</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>foo</td>
      <td>1</td>
      <td>4</td>
      <td>7</td>
    </tr>
    <tr>
      <th>1</th>
      <td>bar</td>
      <td>2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th>2</th>
      <td>baz</td>
      <td>3</td>
      <td>6</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_pivot.pivot(<span class="string">&#x27;key&#x27;</span>,<span class="string">&#x27;B&#x27;</span>) <span class="comment">#当只传入两个参数时，除了将选中的两列变为index和columns之外，其余数据全部保留。本例中将key这一列作为index，同时也将B这一列变为columns的其中一层</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead tr th {
        text-align: left;
    }
    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="3" halign="left">A</th>
      <th colspan="3" halign="left">C</th>
    </tr>
    <tr>
      <th>B</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
    </tr>
    <tr>
      <th>key</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>bar</th>
      <td>NaN</td>
      <td>2.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>8.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>baz</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>3.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>9.0</td>
    </tr>
    <tr>
      <th>foo</th>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>7.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_pivot.pivot(<span class="string">&#x27;key&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;A&#x27;</span>) <span class="comment">#如果传入三个或以上的参数，那么最终的数据只保留第三个及以后的参数所对应列中的数据</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>B</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
    </tr>
    <tr>
      <th>key</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>bar</th>
      <td>NaN</td>
      <td>2.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>baz</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>foo</th>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>
<p>相对应地，<code>pivot</code>的反操作为<code>melt</code>。这一操作会将DataFrame变为两列或三列。</p>
<p>如果只传入value_vars参数，那么生成的DataFrame有两列，分别为variable和value，variable对应的是value_vars所包含的列名，value对应的是value_vars中的列名所指向的列里面的所有元素。</p>
<p>如果除了value_vars参数，还传入了id_vars参数，那么最终形成的DataFrame中会额外多出id_vars所对应的若干列。这些列中的内容为id_vars所对应列中的元素。</p>
<p>下面为一些示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_pivot.melt(id_vars=[<span class="string">&#x27;key&#x27;</span>]) <span class="comment">#只传入id_vars参数的话，默认会选取其他所有的列为value_vars</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>variable</th>
      <th>value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>foo</td>
      <td>A</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>bar</td>
      <td>A</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>baz</td>
      <td>A</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>foo</td>
      <td>B</td>
      <td>4</td>
    </tr>
    <tr>
      <th>4</th>
      <td>bar</td>
      <td>B</td>
      <td>5</td>
    </tr>
    <tr>
      <th>5</th>
      <td>baz</td>
      <td>B</td>
      <td>6</td>
    </tr>
    <tr>
      <th>6</th>
      <td>foo</td>
      <td>C</td>
      <td>7</td>
    </tr>
    <tr>
      <th>7</th>
      <td>bar</td>
      <td>C</td>
      <td>8</td>
    </tr>
    <tr>
      <th>8</th>
      <td>baz</td>
      <td>C</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_pivot.melt(value_vars=[<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>])</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>variable</th>
      <th>value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>B</td>
      <td>4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>B</td>
      <td>5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>B</td>
      <td>6</td>
    </tr>
    <tr>
      <th>3</th>
      <td>C</td>
      <td>7</td>
    </tr>
    <tr>
      <th>4</th>
      <td>C</td>
      <td>8</td>
    </tr>
    <tr>
      <th>5</th>
      <td>C</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_pivot.melt(id_vars=[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>],value_vars=[<span class="string">&#x27;key&#x27;</span>,<span class="string">&#x27;C&#x27;</span>])</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>variable</th>
      <th>value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>4</td>
      <td>key</td>
      <td>foo</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>5</td>
      <td>key</td>
      <td>bar</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>6</td>
      <td>key</td>
      <td>baz</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1</td>
      <td>4</td>
      <td>C</td>
      <td>7</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2</td>
      <td>5</td>
      <td>C</td>
      <td>8</td>
    </tr>
    <tr>
      <th>5</th>
      <td>3</td>
      <td>6</td>
      <td>C</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>
<h1 id="数据的分组"><a class="markdownIt-Anchor" href="#数据的分组"></a> 数据的分组</h1>
<h2 id="生成groupby变量"><a class="markdownIt-Anchor" href="#生成groupby变量"></a> 生成GroupBy变量</h2>
<p>Series和DataFrame可以基于提供的一组关键字，按照行或列对其进行分组。</p>
<p>分组的方法有以下几类：</p>
<ol>
<li>一个list或array，其中的元素作为分组的依据，要求大小与待分组轴向的大小相等</li>
<li>一个dict或Series，将待分组的数据以及这些数据所在的分组对应起来</li>
<li>一个列名，该列中的元素作为分组的依据，等同于传入一个Series</li>
<li>一个函数，可以作用于index或者是元素</li>
<li>一个index，适用于多层index的情况</li>
</ol>
<p>使用<code>groupby</code>函数，并传入上述三种参数中的其中一个，便可得到一个类型为<code>SeriesGroupBy</code>或者<code>DataFrameGroupBy</code>的变量。</p>
<p>下面为一些使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_groupby=pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span> : [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>],<span class="string">&#x27;key2&#x27;</span> : [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>], <span class="string">&#x27;data1&#x27;</span> : np.random.randn(<span class="number">5</span>), <span class="string">&#x27;data2&#x27;</span> : np.random.randn(<span class="number">5</span>)&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_groupby</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key1</th>
      <th>key2</th>
      <th>data1</th>
      <th>data2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>a</td>
      <td>one</td>
      <td>0.773597</td>
      <td>-0.769454</td>
    </tr>
    <tr>
      <th>1</th>
      <td>a</td>
      <td>two</td>
      <td>0.552522</td>
      <td>-0.123829</td>
    </tr>
    <tr>
      <th>2</th>
      <td>b</td>
      <td>one</td>
      <td>-0.264872</td>
      <td>-0.145577</td>
    </tr>
    <tr>
      <th>3</th>
      <td>b</td>
      <td>two</td>
      <td>-0.222394</td>
      <td>-0.357799</td>
    </tr>
    <tr>
      <th>4</th>
      <td>a</td>
      <td>one</td>
      <td>-1.691627</td>
      <td>0.530238</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped_series=dataframe_groupby[<span class="string">&#x27;data1&#x27;</span>].groupby(dataframe_groupby[<span class="string">&#x27;key1&#x27;</span>]) <span class="comment">#使用Series作为分组的依据</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped_series <span class="comment">#得到一个GroupBy类型的变量</span></span><br></pre></td></tr></table></figure>
<pre><code>&lt;pandas.core.groupby.generic.SeriesGroupBy object at 0x000001B04A2A2688&gt;
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped_series2=dataframe_groupby[<span class="string">&#x27;data1&#x27;</span>].groupby([dataframe_groupby[<span class="string">&#x27;key1&#x27;</span>],dataframe_groupby[<span class="string">&#x27;key2&#x27;</span>]]) <span class="comment">#可以传入多个Series进行分组，最终得到的Series具有多重index</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">states = np.array([<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line">years = np.array([<span class="number">2005</span>, <span class="number">2005</span>, <span class="number">2006</span>, <span class="number">2005</span>, <span class="number">2006</span>])</span><br><span class="line">grouped_arr=dataframe_groupby[<span class="string">&#x27;data1&#x27;</span>].groupby([states,years]) <span class="comment">#传入array来进行分组，array中的元素作为分组的依据</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped_colname=dataframe_groupby.groupby([<span class="string">&#x27;key1&#x27;</span>,<span class="string">&#x27;key2&#x27;</span>]) <span class="comment">#可以传入多个列名进行分组</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped_col=dataframe_groupby.groupby(dataframe_groupby.dtypes,axis=<span class="number">1</span>) <span class="comment">#默认情况下按照行进行分组，可以传入axis=1来按列进行分组</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapping=&#123;<span class="number">0</span>:<span class="string">&#x27;red&#x27;</span>,<span class="number">1</span>:<span class="string">&#x27;green&#x27;</span>,<span class="number">2</span>:<span class="string">&#x27;blue&#x27;</span>,<span class="number">3</span>:<span class="string">&#x27;red&#x27;</span>,<span class="number">4</span>:<span class="string">&#x27;blue&#x27;</span>&#125;</span><br><span class="line">grouped_mapping=dataframe_groupby.groupby(mapping) <span class="comment">#使用dict来进行分组，与传入一个Series的作用类似</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func=<span class="keyword">lambda</span> x: x&gt;<span class="number">0</span></span><br><span class="line">grouped_func=dataframe_groupby[<span class="string">&#x27;data1&#x27;</span>].groupby(func) <span class="comment">#使用函数来进行分组</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">columns = pd.MultiIndex.from_arrays([[<span class="string">&#x27;US&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>],[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>]], names=[<span class="string">&#x27;cty&#x27;</span>, <span class="string">&#x27;tenor&#x27;</span>])</span><br><span class="line">dataframe_groupby2=pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">5</span>), columns=columns)</span><br><span class="line">grouped_hier=dataframe_groupby2.groupby(level=<span class="string">&#x27;cty&#x27;</span>, axis=<span class="number">1</span>) <span class="comment">#使用多层index中的某一层进行分组</span></span><br></pre></td></tr></table></figure>
<h2 id="groupby变量的使用"><a class="markdownIt-Anchor" href="#groupby变量的使用"></a> GroupBy变量的使用</h2>
<h3 id="查看内容"><a class="markdownIt-Anchor" href="#查看内容"></a> 查看内容</h3>
<p>groupby<code>函数得到的</code>GroupBy`变量可以按照下面的两种方法查看或是使用每个分组的内容：</p>
<ol>
<li>用于循环遍历，每个循环输出一个分组名称和内容</li>
<li>转换为list类型，list中的每个元素都是一个tuple，包含每个分组的名称和内容</li>
</ol>
<h3 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h3>
<p>如果<code>GroupBy</code>变量是从一个DataFrame分组而来的，可以使用DataFrame的列名对其进行索引，得到一个<code>SeriesGroupBy</code>变量。</p>
<h3 id="使用函数"><a class="markdownIt-Anchor" href="#使用函数"></a> 使用函数</h3>
<p><code>GroupBy</code>变量也支持一些统计函数，包括：</p>
<ul>
<li>count：统计分组中非NaN的数目</li>
<li>sum：统计所有非NaN元素的和</li>
<li>mean：计算所有非NaN元素的平均值</li>
<li>median：计算所有非NaN元素的中位数</li>
<li>std、var：统计非偏（即分母为n-1）标准差或方差</li>
<li>min、max：统计非NaN元素的最大与最小值</li>
<li>prod：统计所有非NaN元素的乘积</li>
<li>first、last：第一个或者最后一个非NaN元素</li>
<li>describe：对每个分组的数据进行统计，输出一些统计量</li>
</ul>
<p>另外，还有几个比较特殊的函数用法：</p>
<ul>
<li>agg：这一函数的用法有下面几种
<ol>
<li>可以自己定义函数，然后作为参数传入到<code>agg</code>方法中，从而作用于每一个分组。传入的函数要求是聚合函数（即输出像统计函数一样会降维）</li>
<li>支持传入一个元素为统计函数名称的list</li>
<li>或是传入一个以二维tuple为元素的list，tuple的第一个元素为统计结果列的名称，第二个元素为统计函数的名称或是一个函数变量。</li>
</ol>
</li>
<li>apply：传入一个函数作为输入参数，对每个分组调用这一函数，然后用concat方法将计算结果合起来，得到一个多重index的DataFrame。因此，每个分组的计算结果要满足concat操作的要求。</li>
<li>transform：对每个分组使用一个函数，要求函数的输出结果必须为一个标量，或是大小相同的array。这一操作完成之后，会生成一个与分组前规模相同的Series或者DataFrame，其中元素的值便是使用原始数据所在分组的函数输出来填充进去的。</li>
</ul>
<p>下面为一些使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name,group <span class="keyword">in</span> grouped_func:</span><br><span class="line">    print(name) <span class="comment">#name对应于分组的名称</span></span><br><span class="line">    print(group) <span class="comment">#group对应于每个分组的内容，可以是一个Series或者DataFrame</span></span><br></pre></td></tr></table></figure>
<pre><code>False
0    0.773597
Name: data1, dtype: float64
True
1    0.552522
2   -0.264872
3   -0.222394
4   -1.691627
Name: data1, dtype: float64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(grouped_col) <span class="comment">#将GroupBy转化为一个list</span></span><br></pre></td></tr></table></figure>
<pre><code>[(dtype('float64'),
        data1     data2
  0  0.773597 -0.769454
  1  0.552522 -0.123829
  2 -0.264872 -0.145577
  3 -0.222394 -0.357799
  4 -1.691627  0.530238),
 (dtype('O'),
    key1 key2
  0    a  one
  1    a  two
  2    b  one
  3    b  two
  4    a  one)]
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped_hier[<span class="string">&#x27;US&#x27;</span>] <span class="comment">#从DataFrameGroupBy中索引得到SeriesGroupBy</span></span><br></pre></td></tr></table></figure>
<pre><code>&lt;pandas.core.groupby.generic.SeriesGroupBy object at 0x000001B04A2ACFC8&gt;
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped_colname.sum() <span class="comment">#对GroupBy变量使用统计函数</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>data1</th>
      <th>data2</th>
    </tr>
    <tr>
      <th>key1</th>
      <th>key2</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">a</th>
      <th>one</th>
      <td>-0.918030</td>
      <td>-0.239216</td>
    </tr>
    <tr>
      <th>two</th>
      <td>0.552522</td>
      <td>-0.123829</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>one</th>
      <td>-0.264872</td>
      <td>-0.145577</td>
    </tr>
    <tr>
      <th>two</th>
      <td>-0.222394</td>
      <td>-0.357799</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grouped_hier.describe()</span><br><span class="line"><span class="comment">#这一函数相当于是下面两条命令的简化版：</span></span><br><span class="line"><span class="comment">#f=lambda x:x.describe()</span></span><br><span class="line"><span class="comment">#grouped.apply(f)</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th></th>
      <th>count</th>
      <th>mean</th>
      <th>std</th>
      <th>min</th>
      <th>25%</th>
      <th>50%</th>
      <th>75%</th>
      <th>max</th>
    </tr>
    <tr>
      <th>cty</th>
      <th>cty</th>
      <th>tenor</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">JP</th>
      <th rowspan="2" valign="top">JP</th>
      <th>1</th>
      <td>4.0</td>
      <td>-0.469233</td>
      <td>1.009621</td>
      <td>-1.229898</td>
      <td>-0.940842</td>
      <td>-0.832966</td>
      <td>-0.361357</td>
      <td>1.018895</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4.0</td>
      <td>0.167405</td>
      <td>0.584559</td>
      <td>-0.516235</td>
      <td>-0.212018</td>
      <td>0.221274</td>
      <td>0.600696</td>
      <td>0.743307</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">US</th>
      <th rowspan="3" valign="top">US</th>
      <th>1</th>
      <td>4.0</td>
      <td>-0.356559</td>
      <td>1.681193</td>
      <td>-1.717014</td>
      <td>-1.399371</td>
      <td>-0.874332</td>
      <td>0.168480</td>
      <td>2.039443</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4.0</td>
      <td>-0.080853</td>
      <td>0.551140</td>
      <td>-0.674817</td>
      <td>-0.479963</td>
      <td>-0.060771</td>
      <td>0.338339</td>
      <td>0.472946</td>
    </tr>
    <tr>
      <th>5</th>
      <td>4.0</td>
      <td>0.227364</td>
      <td>1.239056</td>
      <td>-1.354026</td>
      <td>-0.461604</td>
      <td>0.498428</td>
      <td>1.187396</td>
      <td>1.266626</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diff</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">return</span> arr.max()-arr.min()</span><br><span class="line">grouped_arr.agg(diff)</span><br></pre></td></tr></table></figure>
<pre><code>California  2005    0.00000
            2006    0.00000
Ohio        2005    0.99599
            2006    0.00000
Name: data1, dtype: float64
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped_series.agg([<span class="string">&#x27;count&#x27;</span>,<span class="string">&#x27;max&#x27;</span>,<span class="string">&#x27;min&#x27;</span>]) <span class="comment">#传入一个元素为统计函数名称的list</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>count</th>
      <th>max</th>
      <th>min</th>
    </tr>
    <tr>
      <th>key1</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>3</td>
      <td>0.773597</td>
      <td>-1.691627</td>
    </tr>
    <tr>
      <th>b</th>
      <td>2</td>
      <td>-0.222394</td>
      <td>-0.264872</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped_mapping.agg([(<span class="string">&#x27;sum_val&#x27;</span>,<span class="string">&#x27;sum&#x27;</span>),(<span class="string">&#x27;bar&#x27;</span>,np.std)]) <span class="comment">#传入一个元素为tuple的list</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="2" halign="left">data1</th>
      <th colspan="2" halign="left">data2</th>
    </tr>
    <tr>
      <th></th>
      <th>sum_val</th>
      <th>bar</th>
      <th>sum_val</th>
      <th>bar</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>blue</th>
      <td>-1.956499</td>
      <td>1.008868</td>
      <td>0.384661</td>
      <td>0.477873</td>
    </tr>
    <tr>
      <th>green</th>
      <td>0.552522</td>
      <td>NaN</td>
      <td>-0.123829</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>red</th>
      <td>0.551203</td>
      <td>0.704271</td>
      <td>-1.127252</td>
      <td>0.291084</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped_hier.transform(np.mean) <span class="comment">#transform函数的使用示例，输出与原始的DataFrame具有相同规模，其中的元素来源于数据所在分组计算出的函数输出</span></span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th>cty</th>
      <th colspan="3" halign="left">US</th>
      <th colspan="2" halign="left">JP</th>
    </tr>
    <tr>
      <th>tenor</th>
      <th>1</th>
      <th>3</th>
      <th>5</th>
      <th>1</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.392919</td>
      <td>0.392919</td>
      <td>0.392919</td>
      <td>0.786027</td>
      <td>0.786027</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-1.020843</td>
      <td>-1.020843</td>
      <td>-1.020843</td>
      <td>-0.243295</td>
      <td>-0.243295</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-0.529225</td>
      <td>-0.529225</td>
      <td>-0.529225</td>
      <td>-0.668838</td>
      <td>-0.668838</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.877084</td>
      <td>0.877084</td>
      <td>0.877084</td>
      <td>-0.477551</td>
      <td>-0.477551</td>
    </tr>
  </tbody>
</table>
</div>
<h1 id="数据透视表"><a class="markdownIt-Anchor" href="#数据透视表"></a> 数据透视表</h1>
<p>Pandas提供的<code>pivot_table</code>函数可以用来构造数据透视表。这一函数支持的参数如下：</p>
<ul>
<li>values：用于做数据透视表的数据列，默认使用全部的数据列</li>
<li>index：传入一个列名或者是其它用于分组的关键词，用作数据透视表的行</li>
<li>columns：传入一个列名或者是其它用于分组的关键词，用作数据透视表的列</li>
<li>aggfunc：传入一个聚合函数或者是聚合函数列表，默认为<code>mean</code></li>
<li>fill_value：对数据透视表中NaN的数据的填充值</li>
<li>margins：是否加入每行/每列的总计以及总体的总计，默认为False</li>
<li>dropna：如果为True，则不包含全部为NaN的列</li>
</ul>
<p>如果要做交叉表，即表中元素为数据频数的特殊数据透视表，可以用<code>crosstab</code>函数。</p>
<p>下面为一些示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data=[[<span class="number">16.99</span>, <span class="number">1.01</span>, <span class="string">&#x27;No&#x27;</span>, <span class="string">&#x27;Sun&#x27;</span>, <span class="string">&#x27;Dinner&#x27;</span>, <span class="number">2</span>, <span class="number">0.059447</span>],</span><br><span class="line">[<span class="number">10.34</span>, <span class="number">1.66</span>, <span class="string">&#x27;No&#x27;</span>, <span class="string">&#x27;Sun&#x27;</span>, <span class="string">&#x27;Dinner&#x27;</span>, <span class="number">3</span>, <span class="number">0.160542</span>],</span><br><span class="line">[<span class="number">21.01</span>, <span class="number">3.50</span>, <span class="string">&#x27;No&#x27;</span>, <span class="string">&#x27;Sat&#x27;</span>, <span class="string">&#x27;Lunch&#x27;</span>, <span class="number">3</span>, <span class="number">0.166587</span>],</span><br><span class="line">[<span class="number">23.68</span>, <span class="number">3.31</span>, <span class="string">&#x27;Yes&#x27;</span>, <span class="string">&#x27;Sat&#x27;</span>, <span class="string">&#x27;Breakfast&#x27;</span>, <span class="number">2</span>, <span class="number">0.139780</span>],</span><br><span class="line">[<span class="number">24.59</span>, <span class="number">3.61</span>, <span class="string">&#x27;No&#x27;</span>, <span class="string">&#x27;Sun&#x27;</span>, <span class="string">&#x27;Dinner&#x27;</span>, <span class="number">4</span>, <span class="number">0.146808</span>],</span><br><span class="line">[<span class="number">25.29</span>, <span class="number">4.71</span>, <span class="string">&#x27;Yes&#x27;</span>, <span class="string">&#x27;Sat&#x27;</span>, <span class="string">&#x27;Lunch&#x27;</span>, <span class="number">4</span>, <span class="number">0.186240</span>]]</span><br><span class="line">dataframe_pivottable=pd.DataFrame(data,columns=[<span class="string">&#x27;total_bill&#x27;</span>,<span class="string">&#x27;tip&#x27;</span>,<span class="string">&#x27;smoker&#x27;</span>,<span class="string">&#x27;day&#x27;</span>,<span class="string">&#x27;time&#x27;</span>,<span class="string">&#x27;size&#x27;</span>,<span class="string">&#x27;tip_pct&#x27;</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataframe_pivottable.pivot_table(index=[<span class="string">&#x27;smoker&#x27;</span>,<span class="string">&#x27;day&#x27;</span>],columns=<span class="string">&#x27;time&#x27;</span>,margins=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead tr th {
        text-align: left;
    }
    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th colspan="4" halign="left">size</th>
      <th colspan="4" halign="left">tip</th>
      <th colspan="4" halign="left">tip_pct</th>
      <th colspan="4" halign="left">total_bill</th>
    </tr>
    <tr>
      <th></th>
      <th>time</th>
      <th>Breakfast</th>
      <th>Dinner</th>
      <th>Lunch</th>
      <th>All</th>
      <th>Breakfast</th>
      <th>Dinner</th>
      <th>Lunch</th>
      <th>All</th>
      <th>Breakfast</th>
      <th>Dinner</th>
      <th>Lunch</th>
      <th>All</th>
      <th>Breakfast</th>
      <th>Dinner</th>
      <th>Lunch</th>
      <th>All</th>
    </tr>
    <tr>
      <th>smoker</th>
      <th>day</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">No</th>
      <th>Sat</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>3.0</td>
      <td>3</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>3.500</td>
      <td>3.500000</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>0.166587</td>
      <td>0.166587</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>21.01</td>
      <td>21.010000</td>
    </tr>
    <tr>
      <th>Sun</th>
      <td>NaN</td>
      <td>3.0</td>
      <td>NaN</td>
      <td>3</td>
      <td>NaN</td>
      <td>2.093333</td>
      <td>NaN</td>
      <td>2.093333</td>
      <td>NaN</td>
      <td>0.122266</td>
      <td>NaN</td>
      <td>0.122266</td>
      <td>NaN</td>
      <td>17.306667</td>
      <td>NaN</td>
      <td>17.306667</td>
    </tr>
    <tr>
      <th>Yes</th>
      <th>Sat</th>
      <td>2.0</td>
      <td>NaN</td>
      <td>4.0</td>
      <td>3</td>
      <td>3.31</td>
      <td>NaN</td>
      <td>4.710</td>
      <td>4.010000</td>
      <td>0.13978</td>
      <td>NaN</td>
      <td>0.186240</td>
      <td>0.163010</td>
      <td>23.68</td>
      <td>NaN</td>
      <td>25.29</td>
      <td>24.485000</td>
    </tr>
    <tr>
      <th>All</th>
      <th></th>
      <td>2.0</td>
      <td>3.0</td>
      <td>3.5</td>
      <td>3</td>
      <td>3.31</td>
      <td>2.093333</td>
      <td>4.105</td>
      <td>2.966667</td>
      <td>0.13978</td>
      <td>0.122266</td>
      <td>0.176414</td>
      <td>0.143234</td>
      <td>23.68</td>
      <td>17.306667</td>
      <td>23.15</td>
      <td>20.316667</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.crosstab([dataframe_pivottable[<span class="string">&#x27;smoker&#x27;</span>],dataframe_pivottable[<span class="string">&#x27;time&#x27;</span>]],dataframe_pivottable[<span class="string">&#x27;day&#x27;</span>],margins=<span class="literal">True</span>) </span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>day</th>
      <th>Sat</th>
      <th>Sun</th>
      <th>All</th>
    </tr>
    <tr>
      <th>smoker</th>
      <th>time</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">No</th>
      <th>Dinner</th>
      <td>0</td>
      <td>3</td>
      <td>3</td>
    </tr>
    <tr>
      <th>Lunch</th>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Yes</th>
      <th>Breakfast</th>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>Lunch</th>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>All</th>
      <th></th>
      <td>3</td>
      <td>3</td>
      <td>6</td>
    </tr>
  </tbody>
</table>
</div>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ol>
<li>Python for Data Analysis, 2nd Edition.</li>
</ol>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Yufei Luo
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://lyf35.github.io/2021/01/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-Pandas/" title="数据分析-Pandas">http://lyf35.github.io/2021/01/09/数据分析-Pandas/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" rel="tag"><i class="fa fa-tag"></i> 数据分析</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/09/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8D%9A%E5%A3%AB%E5%BA%94%E8%AF%A5%E6%8E%8C%E6%8F%A1%E7%9A%8452%E4%B8%AA%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/" rel="prev" title="信息安全与密码学博士应该掌握的52个知识点（转载）">
      <i class="fa fa-chevron-left"></i> 信息安全与密码学博士应该掌握的52个知识点（转载）
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90/" rel="next" title="计算机组成原理-计算机的硬件组成">
      计算机组成原理-计算机的硬件组成 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yufei Luo</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">546k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">8:16</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动
  </div>

        






<script data-pjax>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"ypNNXSdcGIIoldC5BBmViS2g-gzGzoHsz","app_key":"0TDwohU7eO4yHTn4tley8PtE","server_url":"https://leancloud.cn/dashboard/data.html?appid=ypNNXSdcGIIoldC5BBmViS2g-gzGzoHsz#/","security":false};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="//cdn.jsdelivr.net/npm/ribbon.js@1/dist/ribbon.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/next-theme/pjax@0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  
  <script data-pjax>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>









<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>


    <div class="pjax">
  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">
  <script src="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css">


  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4dcdc02d24075b0e9d3a',
      clientSecret: '53cf2cb8b89b9d4bba922bb19bda1290f0d0bf95',
      repo        : 'lyf35.github.io',
      owner       : 'lyf35',
      admin       : ['lyf35'],
      id          : 'ab7a636304c4ddabe2a7ac381642ff71',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
