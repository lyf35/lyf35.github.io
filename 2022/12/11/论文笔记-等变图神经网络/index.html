<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">
  <link rel="manifest" href="/images/site.webmanifest">
  <meta name="msapplication-config" content="/images/browserconfig.xml">
  <meta name="msvalidate.01" content="<meta name="msvalidate.01" content="5D3796A5DDB32CC875380613FB613833" />">
  <meta name="baidu-site-verification" content="<meta name="baidu-site-verification" content="kewHZtFYQk" />">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Helvetica:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-flat-top.min.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lyf35.github.io","root":"/","scheme":"Pisces","version":"8.0.0-rc.5","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="引言 本文的主要内容是关于等变图神经网络的一些研究进展，简单介绍了几种用来实现等变的方法，以及在分子性质预测任务中的一些代表性网络结构的简介。注意本文的内容具有一定的时效性，主要介绍的是本文更新日期之前的工作。">
<meta property="og:type" content="article">
<meta property="og:title" content="论文笔记-等变图神经网络">
<meta property="og:url" content="http://lyf35.github.io/2022/12/11/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E7%AD%89%E5%8F%98%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="Yufei Luo&#39;s Blog">
<meta property="og:description" content="引言 本文的主要内容是关于等变图神经网络的一些研究进展，简单介绍了几种用来实现等变的方法，以及在分子性质预测任务中的一些代表性网络结构的简介。注意本文的内容具有一定的时效性，主要介绍的是本文更新日期之前的工作。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214519.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214514.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214511.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214507.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214500.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214456.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214453.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214449.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214444.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214441.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214436.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214432.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214427.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214424.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214421.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214418.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214411.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214407.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214403.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214359.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210814181956.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210814182002.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210814182009.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210814182032.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210814182037.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210814182053.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214346.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214341.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214326.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214323.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214318.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214314.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214310.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214306.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214304.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214258.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214255.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214252.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214249.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214243.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214232.png">
<meta property="article:published_time" content="2022-12-11T11:02:52.000Z">
<meta property="article:modified_time" content="2022-12-11T15:35:12.000Z">
<meta property="article:author" content="Yufei Luo">
<meta property="article:tag" content="图神经网络">
<meta property="article:tag" content="论文笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214519.png">

<link rel="canonical" href="http://lyf35.github.io/2022/12/11/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E7%AD%89%E5%8F%98%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>论文笔记-等变图神经网络 | Yufei Luo's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
 <!--   <div class="headband"></div>-->

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Yufei Luo's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">But I was so much older then, I am younger than that now.</p>
      <img class="custom-logo-image" src="/images/logo.png" alt="Yufei Luo's Blog">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-计算机基础">

    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80" rel="section"><i class="fa fa-tags fa-fw"></i>计算机基础</a>

  </li>
        <li class="menu-item menu-item-机器学习">

    <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0" rel="section"><i class="fa fa-tags fa-fw"></i>机器学习</a>

  </li>
        <li class="menu-item menu-item-深度学习">

    <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0" rel="section"><i class="fa fa-tags fa-fw"></i>深度学习</a>

  </li>
        <li class="menu-item menu-item-工程实践">

    <a href="/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5" rel="section"><i class="fa fa-tags fa-fw"></i>工程实践</a>

  </li>
        <li class="menu-item menu-item-论文笔记">

    <a href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0" rel="section"><i class="fa fa-tags fa-fw"></i>论文笔记</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">2.</span> <span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BE%A4%E4%B8%8E%E7%BE%A4%E8%A1%A8%E7%A4%BA"><span class="nav-number">2.1.</span> <span class="nav-text">群与群表示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AD%89%E5%8F%98"><span class="nav-number">2.2.</span> <span class="nav-text">等变</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AD%89%E5%8F%98%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.</span> <span class="nav-text">等变性的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#se3-transformer"><span class="nav-number">3.1.</span> <span class="nav-text">\(SE(3)\)-transformer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="nav-number">3.1.2.</span> <span class="nav-text">背景知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%90%83%E8%B0%90%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">球谐函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BE%A4%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%BA%A6%E8%A1%A8%E7%A4%BA"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">群的不可约表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#so3%E7%BE%A4%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%BA%A6%E8%A1%A8%E7%A4%BA"><span class="nav-number">3.1.2.3.</span> <span class="nav-text">SO(3)群的不可约表示</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#so3%E7%AD%89%E5%8F%98%E6%9D%83%E9%87%8D%E7%9F%A9%E9%98%B5"><span class="nav-number">3.1.3.</span> <span class="nav-text">\(SO(3)\)等变权重矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C"><span class="nav-number">3.1.4.</span> <span class="nav-text">实验结果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lieconv"><span class="nav-number">3.2.</span> <span class="nav-text">LieConv</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lifting%E6%93%8D%E4%BD%9C"><span class="nav-number">3.2.2.</span> <span class="nav-text">Lifting操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lieconv%E6%93%8D%E4%BD%9C"><span class="nav-number">3.2.3.</span> <span class="nav-text">LieConv操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C-1"><span class="nav-number">3.2.4.</span> <span class="nav-text">实验结果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#egnn"><span class="nav-number">3.3.</span> <span class="nav-text">EGNN</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="nav-number">3.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.2.</span> <span class="nav-text">网络结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C-2"><span class="nav-number">3.3.3.</span> <span class="nav-text">实验结果</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#gnn%E4%B8%8E%E5%88%86%E5%AD%90%E6%80%A7%E8%B4%A8%E9%A2%84%E6%B5%8B"><span class="nav-number">4.</span> <span class="nav-text">GNN与分子性质预测</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#schnet"><span class="nav-number">4.1.</span> <span class="nav-text">SchNet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="nav-number">4.1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#continuous-filter-convolution"><span class="nav-number">4.1.2.</span> <span class="nav-text">Continuous-filter Convolution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84-1"><span class="nav-number">4.1.3.</span> <span class="nav-text">网络结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.4.</span> <span class="nav-text">损失函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C-3"><span class="nav-number">4.1.5.</span> <span class="nav-text">实验结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.1.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dimenet"><span class="nav-number">4.2.</span> <span class="nav-text">DimeNet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="nav-number">4.2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="nav-number">4.2.2.</span> <span class="nav-text">设计思路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">输入和输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%92%E5%BA%A6%E4%BF%A1%E6%81%AF"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">角度信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E6%96%B9%E5%90%91%E7%9A%84%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="nav-number">4.2.2.3.</span> <span class="nav-text">带方向的消息传递</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84-2"><span class="nav-number">4.2.3.</span> <span class="nav-text">网络结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C-4"><span class="nav-number">4.2.4.</span> <span class="nav-text">实验结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B"><span class="nav-number">4.2.5.</span> <span class="nav-text">改进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">4.2.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gemnet"><span class="nav-number">4.3.</span> <span class="nav-text">GemNet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-5"><span class="nav-number">4.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84-3"><span class="nav-number">4.3.2.</span> <span class="nav-text">网络结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C-5"><span class="nav-number">4.3.3.</span> <span class="nav-text">实验结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">4.3.4.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yufei Luo"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Yufei Luo</p>
  <div class="site-description" itemprop="description">哪怕什么真理无穷，进一寸有进一寸的欢喜</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x5ZjM1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lyf35"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmx5ZjEyMzQwMDAwMDBAMTYzLmNvbQ==" title="E-Mail → mailto:lyf1234000000@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



      </section>
        <div class="back-to-top animated">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x5ZjM1" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lyf35.github.io/2022/12/11/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E7%AD%89%E5%8F%98%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Yufei Luo">
      <meta itemprop="description" content="哪怕什么真理无穷，进一寸有进一寸的欢喜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yufei Luo's Blog">
    </span>

    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          论文笔记-等变图神经网络
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-11 19:02:52 / 修改时间：23:35:12" itemprop="dateCreated datePublished" datetime="2022-12-11T19:02:52+08:00">2022-12-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">论文笔记</span></a>
                </span>
            </span>

          
            <span id="/2022/12/11/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E7%AD%89%E5%8F%98%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" class="post-meta-item leancloud_visitors" data-flag-title="论文笔记-等变图神经网络" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>25k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>23 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="引言">引言</h1>
<p>本文的主要内容是关于等变图神经网络的一些研究进展，简单介绍了几种用来实现等变的方法，以及在分子性质预测任务中的一些代表性网络结构的简介。注意本文的内容具有一定的时效性，主要介绍的是本文更新日期之前的工作。</p>
<span id="more"></span>
<h1 id="基础概念">基础概念</h1>
<h2 id="群与群表示">群与群表示</h2>
<p>如果一个非空集合<span class="math inline">\(G\)</span>上定义了一个二元运算<span class="math inline">\(\cdot\)</span>，满足如下性质：</p>
<ol type="1">
<li>封闭性，即对于<span class="math inline">\(\forall a,b\in G\)</span>，有<span class="math inline">\(a\cdot b\in G\)</span></li>
<li>结合律，即对于<span class="math inline">\(\forall a,b,c\in G\)</span> ，有<span class="math inline">\((a\cdot b)\cdot c=a\cdot(b\cdot c)\)</span></li>
<li>存在<span class="math inline">\(e\in G\)</span> ，使得<span class="math inline">\(\forall a\in G\)</span>，有<span class="math inline">\(a\cdot e=e\cdot a=a\)</span> ；</li>
<li>对于<span class="math inline">\(\forall a\in G\)</span>，存在<span class="math inline">\(b\in G\)</span>，使得<span class="math inline">\(a\cdot b=b\cdot a=a\)</span></li>
</ol>
<p>则称<span class="math inline">\(G\)</span>关于运算<span class="math inline">\(\cdot\)</span>构成一个<strong>群</strong>（group），记为<span class="math inline">\((G,\cdot)\)</span> ，或简记为<span class="math inline">\(G\)</span> 。在第3条性质中，<span class="math inline">\(e\)</span>被称为单位元；在第4条性质中，<span class="math inline">\(b\)</span>被称为<span class="math inline">\(a\)</span>的逆元。例如全体整数对于整数加法构成一个群。</p>
<p>在等变图神经网络中，常见的几个群包括：</p>
<ul>
<li><span class="math inline">\(O(n)\)</span>：<span class="math inline">\(n\)</span>维正交群，包含旋转与反演操作</li>
<li><span class="math inline">\(SO(n)\)</span>：<span class="math inline">\(n\)</span>维特殊正交群，只包含旋转操作</li>
<li><span class="math inline">\(E(n)\)</span>：<span class="math inline">\(n\)</span>维欧几里得群，包含旋转、反演、平移操作</li>
<li><span class="math inline">\(SE(n)\)</span>：<span class="math inline">\(n\)</span>维特殊欧几里得群，包含旋转、平移操作</li>
</ul>
<p>设有群<span class="math inline">\(G\)</span>和线性空间<span class="math inline">\(V\)</span>，<span class="math inline">\(V\)</span>上的所有可逆线性变换构成一个群<span class="math inline">\(GL(V)\)</span>。则可逆映射<span class="math inline">\(\rho(g):G\rightarrow GL(V)\)</span>称为群<span class="math inline">\(G\)</span>在线性空间<span class="math inline">\(V\)</span>上的一个表示，它将群中的元素<span class="math inline">\(g\in G\)</span>映射到线性空间<span class="math inline">\(V\)</span>中的一个元素。一般来说，对于数域<span class="math inline">\(k\)</span>上的<span class="math inline">\(n\)</span>维线性空间<span class="math inline">\(V\)</span>，选定一组基后，<span class="math inline">\(V\)</span>上的可逆线性变换<span class="math inline">\(GL(V)\)</span>就等价于<span class="math inline">\(V\)</span>上的可逆矩阵<span class="math inline">\(GL(n,k)\)</span>。</p>
<p>例如群<span class="math inline">\(O(n)\)</span>中的元素<span class="math inline">\(g\)</span>可以表示为一个正交矩阵<span class="math inline">\(\rho(g)=\boldsymbol{O}_g\in R^n\)</span>；<span class="math inline">\(SO(n)\)</span>群中的元素可以表示为一个满足<span class="math inline">\(\det(\boldsymbol{O}_g)=1\)</span>的正交矩阵。</p>
<p>一个群的表示可以作用在一个<span class="math inline">\(n\)</span>维向量<span class="math inline">\(\boldsymbol{x}\in \mathbb{R}^n\)</span>上，即<span class="math inline">\(\rho(g)\boldsymbol{x}\)</span>，表示对这个向量做变换。例如在<span class="math inline">\(SO(n)\)</span>群中有<span class="math inline">\(\rho(g)\boldsymbol{x}=\boldsymbol{O}_g\boldsymbol{x}\)</span>，代表对向量做旋转操作。</p>
<h2 id="等变">等变</h2>
<p>对于群<span class="math inline">\(G\)</span>中的任意变换，如果有 <span class="math display">\[
\phi(\rho_{\mathcal{X}}(g)x)=\rho_{\mathcal{Y}}(g)\phi(x),\forall g\in G
\]</span> 成立，则称函数<span class="math inline">\(\phi\)</span>在群空间<span class="math inline">\(G\)</span>上具有等变性。其中<span class="math inline">\(\rho_{\mathcal{X}}\)</span>和<span class="math inline">\(\rho_{\mathcal{Y}}\)</span>分别代表输入和输出空间的群表示。例如在<span class="math inline">\(O(3)\)</span>群中，假设输入和输出空间使用同一套坐标系，则等变关系意味着<span class="math inline">\(\phi(\boldsymbol{O}x)=\boldsymbol{O}\phi(x)\)</span>成立；又例如对于一个平移向量<span class="math inline">\(\boldsymbol{t}\in\mathbb{R}^n\)</span>，同一坐标系下的平移等变性可以表示为<span class="math inline">\(\phi(x-\boldsymbol{t})=\phi(x)-\boldsymbol{t}\)</span>。</p>
<p>特殊地，如果<span class="math inline">\(\rho_{\mathcal{Y}}(g)\)</span>为单位元，则可以得到不变性的定义： <span class="math display">\[
\phi(\rho_{\mathcal{X}}(g)x)=\phi(x),\forall g\in G
\]</span> 不变性可以看成是一种特殊的等变性。</p>
<h1 id="等变性的实现">等变性的实现</h1>
<p>常用的在GNN中实现等变的方法包括：</p>
<ul>
<li>不可约表示：一个紧群的线性表示可以被写为一系列不可约表示的直和，利用这一性质可以实现等变。</li>
<li>正则表达：将图卷积滤波器定义为群的函数</li>
<li>标量法：将几何向量转化为具有不变性的标量，然后将其施加在原始的向量上，从而获得等变表示。</li>
</ul>
<p>对于以上的这些方法，下面简单介绍三个它们的代表性工作。</p>
<h2 id="se3-transformer"><span class="math inline">\(SE(3)\)</span>-transformer</h2>
<h3 id="概述">概述</h3>
<p><span class="exturl" data-url="aHR0cDovL2FyeGl2Lm9yZy9hYnMvMjAwNi4xMDUwMw==">SE(3)-transformer<i class="fa fa-external-link-alt"></i></span>这一工作使用了<span class="math inline">\(SO(3)\)</span>群的不可约表示来构造<span class="math inline">\(SE(3)\)</span>等变的网络结构，它的计算过程如下：</p>
<ol type="1">
<li>在一个截断半径内寻找一个结点的邻居，以此构造图中的边</li>
<li>为每一条边<span class="math inline">\(SO(3)\)</span>等变的权重矩阵（最重要也是最难的一步）</li>
<li>计算每条边的query，key和value</li>
<li>为每条边计算attention value，并做聚合与更新操作</li>
</ol>
<p>上述计算过程可以总结为下图：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214519.png" alt="image-20230207220600652" style="zoom: 80%;" /></p>
<h3 id="背景知识">背景知识</h3>
<h4 id="球谐函数">球谐函数</h4>
<p>球谐函数是一组定义在球面上的基函数，它可以从拉普拉斯方程的解中得到。考虑如下的三维拉普拉斯方程： <span class="math display">\[
\frac{\partial^2 f}{\partial x^2}+\frac{\partial^2 f}{\partial y^2}+\frac{\partial^2 f}{\partial z^2}=0
\]</span> 由于Hessian矩阵的迹具有旋转不变性（旋转之后做特征分解，再通过矩阵迹的性质可以证明迹不变），因此这个PDE的解在旋转之后仍然成立。也就是说，三维拉普拉斯方程在<span class="math inline">\(SO(3)\)</span>群的所有元素下具有不变性。</p>
<p>根据这一特性，考虑在球面坐标系下对方程进行求解。方程在球面坐标系下的形式为： <span class="math display">\[
\frac{1}{r^{2}} \frac{\partial}{\partial r}\left(r^{2} \frac{\partial f}{\partial r}\right)+\frac{1}{r^{2} \sin \theta} \frac{\partial}{\partial \theta}\left(\sin \theta \frac{\partial f}{\partial \theta}\right)+\frac{1}{r^{2} \sin ^{2} \theta} \frac{\partial^{2} f}{\partial \varphi^{2}}=0
\]</span> 使用分离变量法，将<span class="math inline">\(f\)</span>写为<span class="math inline">\(f(r,\theta,\varphi)=R(r)Y(\theta,\varphi)\)</span>的形式，代入上式并做分离变量操作之后可得： <span class="math display">\[
\frac{1}{R} \frac{d}{d r}\left(r^{2} \frac{d R}{d r}\right)=\ell(\ell+1)\\
\quad \frac{1}{Y} \frac{1}{\sin \theta} \frac{\partial}{\partial \theta}\left(\sin \theta \frac{\partial Y}{\partial \theta}\right)+\frac{1}{Y} \frac{1}{\sin ^{2} \theta} \frac{\partial^{2} Y}{\partial \varphi^{2}}=-\ell(\ell+1)
\]</span> 再用<span class="math inline">\(Y(\theta,\varphi)=\Theta(\theta)\Phi(\varphi)\)</span>做一次分离变量，可得： <span class="math display">\[
-\frac{1}{\Phi} \frac{d^{2} \Phi}{d \varphi^{2}}=\ell(\ell+1) \sin ^{2} \theta+\frac{\sin \theta}{\Theta} \frac{d}{d \theta}\left(\sin \theta \frac{d \Theta}{d \theta}\right)=\lambda
\]</span> 通过求解上述方程，可得最终解的形式为： <span class="math display">\[
f(r,\theta,\varphi)=\sum\limits_{\ell=0}^\infty\sum\limits_{m=-\ell}^\ell f_\ell^m r^\ell Y_\ell^m(\theta,\varphi)
\]</span> 其中，<span class="math inline">\(Y_\ell^m(\theta,\varphi)\)</span>这一项代表球谐函数。</p>
<p>球谐函数在球坐标下的解析表达式如下： <span class="math display">\[
Y_\ell^{m}(\theta,\varphi)=
\begin{cases}\sqrt{2}K_\ell^{m}\cos(m\varphi)P_\ell^{m}(\cos\theta),&amp; m&gt;0\\ 
\sqrt{2} K_\ell^{m}\sin(-m\varphi)P_\ell^{-m}(\cos\theta),&amp;m&lt;0\\
K_l^0P_l^0(\cos \theta),&amp;m=0 \\
\end{cases} \\
\]</span> 其中，<span class="math inline">\(P_\ell^m(x)\)</span>便是勒让德方程，<span class="math inline">\(K_\ell^m\)</span>为系数，它们的表达式如下： <span class="math display">\[
\begin{aligned}
&amp;P_\ell^{m}(x)=(-1)^{m}(1-x^{2})^{m/2}\dfrac{d^{m}}{dx^{m}}(P_\ell(x)), ~ P_\ell(x)=\dfrac{1}{2^{\ell}\cdot \ell!}\dfrac{d^{\ell}}{dx^{\ell}}[(x^{2}-1)^{\ell}]\\ 
&amp;K_\ell^m=\sqrt{\frac{2\ell+1}{4\pi}\frac{(\ell-|m|)!}{(\ell+|m|)!}}
\end{aligned}
\]</span> 将球谐函数中的<span class="math inline">\(\theta\)</span>和<span class="math inline">\(\varphi\)</span>转化为<span class="math inline">\(x,y,z\)</span>并作图，即可得到它在笛卡尔坐标下的图像，如下图所示：</p>
<figure>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214514.png" alt="image-20230208230937776" /><figcaption aria-hidden="true">image-20230208230937776</figcaption>
</figure>
<p>此外，也可以在单位球面上对其进行可视化，如下图所示：</p>
<figure>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214511.png" alt="image-20230208231339630" /><figcaption aria-hidden="true">image-20230208231339630</figcaption>
</figure>
<p>上面两图中不同的颜色代表在此位置上球谐函数的值是正数还是负数。</p>
<p>根据勒让德方程的正交性，球谐函数组成了球面空间<span class="math inline">\(S^2\)</span>上的一组正交基，任意一个定义在<span class="math inline">\(S^2\)</span>上的函数都可以表示为球谐函数的线性组合： <span class="math display">\[
f(\boldsymbol{x})=\sum_{J\ge 0} \boldsymbol{f}_J^T\boldsymbol{Y}_J(\boldsymbol{x}),~\boldsymbol{x}\in S^2
\]</span> 其中，<span class="math inline">\(\boldsymbol{f}_J\)</span>代表长度为<span class="math inline">\(2J+1\)</span>的系数向量。</p>
<p>下面是一个使用球谐函数对定义在球面上的函数进行重建的示例，可以看出当球谐函数的阶数取的越大则近似效果越好：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214507.webp" alt="img" style="zoom:80%;" /></p>
<h4 id="群的不可约表示">群的不可约表示</h4>
<p>一个群<span class="math inline">\(G\)</span>的群表示<span class="math inline">\(\rho(g):G\rightarrow GL(V)\)</span>可以有多种不同的方式。在这些群表示中，设<span class="math inline">\(\rho\)</span>和<span class="math inline">\(\rho&#39;\)</span>是两个维度相同的表示，如果它们可以用如下的相似变换来联系起来 <span class="math display">\[
\rho&#39;(g)=\boldsymbol{Q}^{-1}\rho(g)\boldsymbol{Q},~ \forall g\in G
\]</span> 则称两个群表示等价。</p>
<p>在此基础上，如果一个群表示可约，那么它可以被表示为如下的形式： <span class="math display">\[
\rho(g)=\mathbf{Q}^{-1}\left(\rho_{1}(g) \oplus \rho_{2}(g)\right) \mathbf{Q}
=\mathbf{Q}^{-1}\left[\begin{array}{ll}
\rho_{1}(g) &amp; \\
&amp; \rho_{2}(g)
\end{array}\right] \mathbf{Q},~\forall g\in G
\]</span> 在这一表达式中，如果<span class="math inline">\(\rho_1\)</span>和<span class="math inline">\(\rho_2\)</span>不可约，则它们被称为群<span class="math inline">\(G\)</span>的不可约表示。也就是说，这些不可约表示相当于是一组基元，使用它们可以构造出所有其它的群表示。</p>
<p>实质上，所有紧群的线性表示都可以写成不可约表示的直和形式： <span class="math display">\[
\rho(g)=\mathbf{Q}^{\top}\left[\bigoplus_{J} \mathbf{D}_{J}(g)\right] \mathbf{Q}
\]</span> 其中，<span class="math inline">\(\boldsymbol{Q}\)</span>是一个正交的<span class="math inline">\(N\times N\)</span>维矩阵，代表基变换矩阵。</p>
<h4 id="so3群的不可约表示">SO(3)群的不可约表示</h4>
<p><span class="math inline">\(SO(3)\)</span>群可以被表示为一个<span class="math inline">\(3\times 3\)</span>的旋转矩阵<span class="math inline">\(\boldsymbol{R}_g\)</span>，除此之外也可以用上述不可约表示的形式来构造出其它的群表示。对于<span class="math inline">\(SO(3)\)</span>群而言，群中的元素<span class="math inline">\(g\)</span>被映射为大小为<span class="math inline">\((2J+1)\times (2J+1),J=0,1,2,\dots\)</span>的矩阵<span class="math inline">\(\boldsymbol{D}_J(g)\)</span>，被称为Wigner-D矩阵，这些矩阵构成了<span class="math inline">\(SO(3)\)</span>群的不可约表示。</p>
<p>根据群论中的舒尔正交关系，球谐函数可以用于构造<span class="math inline">\(SO(3)\)</span>群的不可约表示，此时每个Wigner-D矩阵对应的正交子空间为球谐函数所对应的空间。</p>
<p>相应地，使用<span class="math inline">\(\boldsymbol{D}_J\)</span>做变换的向量（<span class="math inline">\(2J+1\)</span>维）也被称为<span class="math inline">\(\textit{type}-J\)</span>向量，例如，Type-0向量在旋转过程中保持不变，type-1向量则根据三维旋转矩阵做旋转。</p>
<p>球谐函数有一个重要的特性是球谐函数的旋转操作可以直接使用Wigner-D矩阵来实现： <span class="math display">\[
\mathbf{Y}_{J}\left(\mathbf{R}_{g}^{-1} \mathbf{x}\right)=\mathbf{D}_{J}^{*}(g) \mathbf{Y}_{J}(\mathbf{x}), \quad \mathbf{x} \in S^{2}, g \in G
\]</span></p>
<p>其中，<span class="math inline">\(\boldsymbol{D}_J\)</span>代表第J阶的Wigner-D矩阵，<span class="math inline">\(\boldsymbol{D}_J^*\)</span>是<span class="math inline">\(\boldsymbol{D}_J\)</span>的共轭。</p>
<p>基于球谐函数的旋转性质，上述函数<span class="math inline">\(f(\boldsymbol{x})\)</span>的旋转操作也可以写为： <span class="math display">\[
f\left(\mathbf{R}_{g}^{-1} \mathbf{x}\right)=\sum_{J \geq 0} \mathbf{f}_{J}^{\top} \mathbf{D}_{J}^{*}(g) \mathbf{Y}_{J}(\mathbf{x}), \quad \mathbf{x} \in S^{2}, g \in G
\]</span></p>
<p>如果要对两个<span class="math inline">\(k\)</span>阶和<span class="math inline">\(\ell\)</span>阶的Wigner-D矩阵做张量乘法，则它们的张量积可以使用Clebsch-Gordan分解来计算： <span class="math display">\[
\mathbf{D}_k(g)\otimes\mathbf{D}_\ell(g)=\mathbf{Q}^{\ell k\top}\left[\bigoplus\limits_{J=|k- \ell|}^{k+\ell}\mathbf{D}_J(g)\right]\mathbf{Q}^{\ell k}
\]</span> 其中，基变换矩阵<span class="math inline">\(\mathbf{Q}^{\ell k}\)</span>被称为Clebsch-Gordan系数，可以直接查表得到。</p>
<blockquote>
<p>备注：用一个例子说明张量积的计算规则 <span class="math display">\[
\left.\begin{matrix}A=\left[\begin{matrix}a&amp;b\\ c&amp;d\end{matrix}\right]\\ B=\left[\begin{matrix}e&amp;f\\ g&amp;h\end{matrix}\right]\end{matrix}\right\}\Rightarrow A\otimes B=\left[\begin{matrix}aB&amp;bB\\ cB&amp;dB\end{matrix}\right]=\left[\begin{matrix}ae&amp;af&amp;be&amp;bf\\ag&amp;ah&amp;bg&amp;bh\\ ce&amp;cf&amp;de&amp;df\\ cg&amp;ch&amp;dg&amp;dh\end{matrix}\right]
\]</span></p>
</blockquote>
<h3 id="so3等变权重矩阵"><span class="math inline">\(SO(3)\)</span>等变权重矩阵</h3>
<p><span class="math inline">\(SE(3)\)</span>-transformer这一工作的重点在于构造<span class="math inline">\(SO(3)\)</span>等变的权重矩阵。仍使用<span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE4MDIuMDgyMTk=">Tensor field networks<i class="fa fa-external-link-alt"></i></span>这一工作中所定义的<span class="math inline">\(\mathbb{R}^3\rightarrow \mathbb{R}^{(2\ell+1)\times (2k+1)}\)</span>的卷积操作，其中卷积核为矩阵<span class="math inline">\(W^{\ell k}\)</span>： <span class="math display">\[
\begin{aligned}
\mathbf{f}_{\mathrm{out,i}}^{\ell} &amp; =\left[\mathbf{W}^{\ell k} * \mathbf{f}_{\mathrm{in}}^{k}\right](\mathbf{x}) \\
&amp; =\int_{\mathbb{R}^{3}} \mathbf{W}^{\ell k}\left(\mathbf{x}^{\prime}-\mathbf{x}_{i}\right) \mathbf{f}_{\mathrm{in}}^{k}\left(\mathbf{x}^{\prime}\right) \mathrm{d} \mathbf{x}^{\prime} \\
&amp; =\int_{\mathbb{R}^{3}} \mathbf{W}^{\ell k}\left(\mathbf{x}^{\prime}-\mathbf{x}_{i}\right) \sum_{j=1}^{N} \mathbf{f}_{\mathrm{in}, j}^{k} \delta\left(\mathbf{x}^{\prime}-\mathbf{x}_{j}\right) \mathrm{d} \mathbf{x}^{\prime} \\
&amp; =\sum_{j=1}^{N} \int_{\mathbb{R}^{3}} \mathbf{W}^{\ell k}\left(\mathbf{x}^{\prime}-\mathbf{x}_{i}\right) \mathbf{f}_{\mathrm{in}, j}^{k} \delta\left(\mathbf{x}^{\prime}-\mathbf{x}_{j}\right) \mathrm{d} \mathbf{x}^{\prime} \\
&amp; =\sum_{j=1}^{N} \int_{\mathbb{R}^{3}} \mathbf{W}^{\ell k}\left(\mathbf{x}^{\prime \prime}+\mathbf{x}_{j}-\mathbf{x}_{i}\right) \mathbf{f}_{\mathrm{in}, j}^{k} \delta\left(\mathbf{x}^{\prime \prime}\right) \mathrm{d} \mathbf{x}^{\prime \prime} \\
&amp; =\sum_{j=1}^{N} \mathbf{W}^{\ell k}\left(\mathbf{x}_{j}-\mathbf{x}_{i}\right) \mathbf{f}_{\mathrm{in}, j}^{k}
\end{aligned}
\]</span> 这一卷积操作将type-k的向量映射为type-<span class="math inline">\(\ell\)</span>的向量。</p>
<p>上述定义的卷积公式需满足等变性： <span class="math display">\[
\begin{aligned}
\mathbf{D}_{\ell}(g) \mathbf{f}_{\mathrm{out}, \mathrm{i}}^{\ell} &amp; =\sum_{j=1}^{N} \mathbf{W}^{\ell k}\left(\mathbf{R}_{g}^{-1}\left(\mathbf{x}_{j}-\mathbf{x}_{i}\right)\right) \mathbf{D}_{k}(g) \mathbf{f}_{\mathrm{in}, j}^{k} \\
\Longrightarrow \mathbf{f}_{\mathrm{out}, \mathrm{i}}^{\ell} &amp; =\sum_{j=1}^{N} \mathbf{D}_{\ell}(g)^{-1} \mathbf{W}^{\ell k}\left(\mathbf{R}_{g}^{-1}\left(\mathbf{x}_{j}-\mathbf{x}_{i}\right)\right) \mathbf{D}_{k}(g) \mathbf{f}_{\mathrm{in}, j}^{k}
\end{aligned}
\]</span> 两式应该相等，因此从中可以推出： <span class="math display">\[
\mathbf{W}^{\ell k}(\mathbf{R}_{g}^{-1}\mathbf{x})=\mathbf{D}_{\ell}(g)\mathbf{W}^{\ell k}(\mathbf{x})\mathbf{D}_{k}(g)^{-1}
\]</span> 这一公式为矩阵形式，可以通过重排改写为向量形式： <span class="math display">\[
\mathrm{vec}(\mathbf{W}^{\ell k}(\mathbf{R}_g^{-1}\mathbf{x}))=(\mathbf{D}_k(g)\otimes\mathbf{D}_\ell(g))\mathrm{vec}(\mathbf{W}^{\ell k}(\mathbf{x}))
\]</span> 其中的张量积可以用Clebsch-Gordan分解来替换： <span class="math display">\[
\mathrm{vec}(\mathbf{W}^{\ell k}(\mathbf{R}_g^{-1}\mathbf{x}))=\mathbf{Q}^{\ell k\top}\left[\bigoplus\limits_{J=|k-\ell|}^{k+\ell}\mathbf{D}_J(g)\right]\mathbf{Q}^{\ell k}\mathrm{vec}(\mathbf{W}^{\ell k}(\mathbf{x}))
\]</span> 简便起见，定义<span class="math inline">\(\eta^{\ell k}(\mathbf{x})\triangleq\mathbf{Q}^{\ell k}\mathrm{vec}(\mathbf{W}^{\ell k}(\mathbf{x}))\)</span>，从而有 <span class="math display">\[
\eta^{\ell k}(\mathbf{R}_{g}^{-1}\mathbf{x})=\left[\bigoplus_{J=|k-\ell|}^{k+\ell}\mathbf{D}_{J}(g)\right]\eta^{\ell k}(\mathbf{x})
\]</span> 其中的第<span class="math inline">\(J\)</span>个子向量<span class="math inline">\(\eta^{\ell k}_J(\mathbf{x})\)</span>满足约束条件<span class="math inline">\(\eta_{J}^{\ell k}(\mathbf{R}_{g}^{-1}\mathbf{x})=\mathbf{D}_{J}(g)\eta_{J}^{\ell k}(\mathbf{x})\)</span>，这正与球谐函数的变换法则<span class="math inline">\(\mathbf{Y}_{J}\left(\mathbf{R}_{g}^{-1} \mathbf{x}\right)=\mathbf{D}_{J}^{*}(g) \mathbf{Y}_{J}(\mathbf{x})\)</span>相同。因此可以令<span class="math inline">\(\eta^{\ell k}_J(\mathbf{x})=\mathbf{Y}_J(\mathbf{x})\)</span>，从而得到权重矩阵<span class="math inline">\(\boldsymbol{W}^{\ell k}\)</span>的构造： <span class="math display">\[
\operatorname{vec}\left(\mathbf{W}^{\ell k}(\mathbf{x})\right)=\mathbf{Q}^{\ell k\top}\bigoplus\limits_{J=|k-\ell|}^{k+\ell}\mathbf{Y}_J(\mathbf{x})
\]</span> 上面构造的这个权重矩阵中不包含可学习参数，此外这样的构造方式也只考虑了角度方向而没有考虑径向，因此可以加入一个可学习的径向函数<span class="math inline">\(\varphi_J^{\ell k}:\mathbb{R}_{\ge 0}\rightarrow \mathbb{R}\)</span>，从而有： <span class="math display">\[
\operatorname{vec}\left(\mathbf{W}^{\ell k}(\mathbf{x})\right)=\mathbf{Q}^{\ell k\top}\bigoplus\limits_{J=|k-\ell|}^{k+\ell}\varphi_J^{\ell k}(\|\mathbf{x}\|)\mathbf{Y}_J(\mathbf{x})
\]</span> 向量化的权重矩阵重新恢复为矩阵形式为： <span class="math display">\[
\mathbf{W}^{\ell k}(\mathbf{x})=\sum_{J=|k-\ell|}^{k+\ell}\varphi_{J}^{\ell k}(\|\mathbf{x}\|)\sum\limits_{m=-J}^{J}\mathbf{Q}_{Jm}^{\ell k\top}Y_{Jm}(\mathbf{x})\\
\]</span></p>
<h3 id="实验结果">实验结果</h3>
<p>作者分别在三个不同的任务上对模型做了测试，包括N体模拟，点云分类和分子化学性质预测。</p>
<p>在N体模拟任务中，<span class="math inline">\(SE(3)\)</span>-transformer相比于没有加入等变约束的set transformer能够取得更好的结果，对于位置和速度的预测能够体现出等变性（图中的虚线代表旋转之后的正确位置）：</p>
<figure>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214500.png" alt="image-20230212181135922" /><figcaption aria-hidden="true">image-20230212181135922</figcaption>
</figure>
<p>从定量结果上也可以看出<span class="math inline">\(SE(3)\)</span>-transformer具有更高的精确度：</p>
<figure>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214456.png" alt="image-20230212181221900" /><figcaption aria-hidden="true">image-20230212181221900</figcaption>
</figure>
<p>在点云数据集上有着类似的表现，模型的准确度也不会随着数据的旋转而发生下降，此处不再赘述。</p>
<p>在QM9数据集上模型的表现如下：</p>
<figure>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214453.png" alt="image-20230212181626518" /><figcaption aria-hidden="true">image-20230212181626518</figcaption>
</figure>
<p>从中可以看出，<span class="math inline">\(SE(3)\)</span>-transformer的结果并不是SOTA，但是误差与表现最好的模型相比差距并不很大，这也能一定程度说明模型较广的适用范围。</p>
<h2 id="lieconv">LieConv</h2>
<h3 id="概述-1">概述</h3>
<p>LieConv出自<span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzIwMDIuMTI4ODA=">Generalizing Convolutional Neural Networks for Equivariance to Lie Groups on Arbitrary Continuous Data<i class="fa fa-external-link-alt"></i></span>这一工作，它定义了李群上的卷积操作，从而可以实现任意李群上的等变网络。</p>
<p>模型的结构如下图所示：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214449.png" alt="image-20230213111027356" style="zoom:80%;" /></p>
<p>其中，Lifting和LieConv是模型中的两个关键模块，下面将详细介绍。</p>
<h3 id="lifting操作">Lifting操作</h3>
<p>Lifting操作的定义为<span class="math inline">\(\text{Lift}(\boldsymbol{x})=\{\boldsymbol{u}\in G, \boldsymbol{uo}=\boldsymbol{x}\}\)</span>，用于将输入<span class="math inline">\(\boldsymbol{x}_i\)</span>变换为群元素<span class="math inline">\(\boldsymbol{u}_i\)</span>，之后便可以做李群上的卷积操作。它的具体流程如下：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214444.png" alt="image-20230213111300829" style="zoom:80%;" /></p>
<p>设输入为<span class="math inline">\(\{(\boldsymbol{x}_i,\boldsymbol{f}_i)\}_{i=1}^N\)</span>，其中<span class="math inline">\(\boldsymbol{x}_i\in\mathcal{X}\)</span>，对<span class="math inline">\(\boldsymbol{x}_i\)</span>做变换的流程可以总结为三步：</p>
<ol type="1">
<li><p>为每个轨道<span class="math inline">\(q\in \mathcal{X}/G\)</span>选择一个原点<span class="math inline">\(o_q\)</span>。这里的轨道指的是<span class="math inline">\(\boldsymbol{x}\)</span>所对应的空间<span class="math inline">\(\mathcal{X}\)</span>与群<span class="math inline">\(G\)</span>的商空间<span class="math inline">\(\mathcal{X}/G\)</span>，因此轨道可能只有一个或者可能有多个。下图分别为<span class="math inline">\(SO(2)\)</span>群和<span class="math inline">\(T(1)y\)</span>群所对应的轨道示意图：</p>
<figure>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214441.png" alt="image-20230213112422440" /><figcaption aria-hidden="true">image-20230213112422440</figcaption>
</figure></li>
<li><p>为每个原点<span class="math inline">\(o_q\)</span>计算集合<span class="math inline">\(H_q\)</span>，它被称作stabilizer，其中的元素满足<span class="math inline">\(H=\{h\in G,ho=o\}\)</span>。</p></li>
<li><p>在完成上面两步之后，就可以为输入<span class="math inline">\(\boldsymbol{x}_i\)</span>计算lifting之后的结果：</p>
<ul>
<li>首先计算出<span class="math inline">\(\boldsymbol{x}_i\)</span>所在的轨道<span class="math inline">\(q_i\)</span></li>
<li>然后从<span class="math inline">\(H_{q_i}\)</span>中按照哈尔测度（一种定义在拓扑群上的测度）采样<span class="math inline">\(K\)</span>个样本构成集合<span class="math inline">\(\{\boldsymbol{v}_j\}_{j=1}^K, \boldsymbol{v}_j\sim \mu(H_{q_i})\)</span></li>
<li>之后根据公式<span class="math inline">\(\boldsymbol{u}_i\boldsymbol{o}_q=\boldsymbol{x}_i\)</span>得到群中的元素<span class="math inline">\(\boldsymbol{u}_i\in G\)</span></li>
</ul></li>
</ol>
<p>由此便可得到lifting之后的数据<span class="math inline">\(Z_i=\{(\boldsymbol{u}_i\boldsymbol{v}_j,q_i,\boldsymbol{f}_i)\}_{j=1}^K\)</span>。</p>
<p>下图给出了几个不同群上面做lifting操作的示例：</p>
<figure>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214436.png" alt="image-20230213114237130" /><figcaption aria-hidden="true">image-20230213114237130</figcaption>
</figure>
<h3 id="lieconv操作">LieConv操作</h3>
<p>设计在李群上卷积的计算步骤如下：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214432.png" alt="image-20230213150634929" style="zoom:80%;" /></p>
<p>卷积操作主要包括三步：</p>
<ol type="1">
<li><p>首先寻找点<span class="math inline">\(i\)</span>的所有近邻点，即满足<span class="math inline">\(d((\boldsymbol{u}_i,q_i),(\boldsymbol{u}_j,q_j))&lt;r\)</span>的所有点。这里距离的定义为： <span class="math display">\[
d((\boldsymbol{u}_i,{q}_i),(\boldsymbol{u}_j,{q}_j))^2=\|\log (\boldsymbol{u}_i^{-1}\boldsymbol{u}_j)\|_F+\alpha\|q_i-q_j\|
\]</span> 如果lifting之后的数据不包含轨道，则其中含<span class="math inline">\(q\)</span>的项可以省略。</p></li>
<li><p>计算向量<span class="math inline">\(\boldsymbol{a}_{ij}\)</span>，它被用于下一步的卷积计算。</p></li>
<li><p>计算卷积之后的结果。在连续空间中卷积的计算公式为： <span class="math display">\[
h(\boldsymbol{u},q)=\int_{G,Q}k(\boldsymbol{v}^{-1}\boldsymbol{u},q,q&#39;)f(\boldsymbol{v},q&#39;)d\mu(\boldsymbol{v})dq&#39;
\]</span> 将其离散化之后便有： <span class="math display">\[
h_i=\frac{1}{n_i}\sum\limits_{j\in\text{nbd(i)}}\tilde{k}_\theta(\log(\boldsymbol{v}_j^{-1}\boldsymbol{u}_i),q_i,q_j)f_j=\frac{1}{n_i}\sum\limits_{j\in\text{nbd(i)}}\tilde{k}_\theta(\boldsymbol{a}_{ij})f_j
\]</span> 其中<span class="math inline">\(\tilde{k}_{\theta}\)</span>是一个可学习的MLP。</p></li>
</ol>
<p>需要注意的是，这里的卷积操作不是严格意义上的等变，而是依概率分布成立： <span class="math display">\[
\begin{aligned}
(k\hat{\ast}L_{w}f)(u_{i})&amp;=(1/n_{i})\sum_{j}k(v_{j}^{-1}u_{i})f(w^{-1}v_{j})\\
&amp;=(1/n_{i})\sum_{j}k(\tilde{v}_{j}^{-1}w^{-1}u_{i})f(\tilde{v}_{j})\\ 
&amp;\stackrel{d}{=}(k\hat{\ast}f)(w^{-1}u_{i})=L_{w}(k\hat{\ast}f)(u_{i})
\end{aligned}
\]</span></p>
<h3 id="实验结果-1">实验结果</h3>
<p>作者分别在RotMNIST旋转手写数字分类，QM9分子性质预测，以及动力系统的轨迹预测三个任务上对模型的效果进行试验。</p>
<p>在旋转手写数字分类任务上，模型的结果如下：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214427.png" alt="image-20230213154553311" style="zoom:80%;" /></p>
<p>其结果比较接近最好的baseline。</p>
<p>在分子性质预测任务上的表现：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214424.png" alt="image-20230213154648093" style="zoom:80%;" /></p>
<p>结果与另外三个baseline模型也都比较接近。</p>
<p>在动力系统轨迹预测任务中，模型所预测的轨迹能够很好地与真实轨迹重合：</p>
<figure>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214421.png" alt="image-20230213154810944" /><figcaption aria-hidden="true">image-20230213154810944</figcaption>
</figure>
<p>此外，选择不同的李群也让模型能够控制对哪些物理量保持守恒。例如使用<span class="math inline">\(SE(2)\)</span>群就可以让角动量与线动量同时具有等变性，而使用<span class="math inline">\(T(2)\)</span>则只能保持线动量的等变，使用<span class="math inline">\(SO(2)\)</span>只能使模型保持角动量的等变：</p>
<figure>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214418.png" alt="image-20230213155455373" /><figcaption aria-hidden="true">image-20230213155455373</figcaption>
</figure>
<p>虽然LieConv模型无法在所有任务上取得SOTA的结果，但是在几个不同领域的任务上都能取得不错的结果，这也能说明模型的通用性。</p>
<h2 id="egnn">EGNN</h2>
<h3 id="概述-2">概述</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzIxMDIuMDk4NDQ=">E(n) Equivariant Graph Neural Networks<i class="fa fa-external-link-alt"></i></span>通过使用向量的标量化操作来实现<span class="math inline">\(E(3)\)</span>等变性。这一网络结构简单高效，目前在许多任务上都经常被用作Backbone。</p>
<h3 id="网络结构">网络结构</h3>
<p>模型的输入包括结点的嵌入向量<span class="math inline">\(\mathbf{h}^{l}=\left\{\mathbf{h}_{0}^{l},\ldots,\mathbf{h}_{M-1}^{l}\right\}\)</span>，每个结点的坐标向量<span class="math inline">\(\mathbf{x}^{l}=\{\mathbf{x}_{0}^{l},\ldots,\mathbf{x}_{M-1}^{l}\}\)</span>和边的特征向量<span class="math inline">\(\boldsymbol{e}_{ij}\)</span>。EGNN基于如下的消息传递和特征聚合更新操作来做图卷积运算： <span class="math display">\[
\begin{aligned}
\mathbf{m}_{ij}&amp;=\phi_x\left(\mathbf{h}_i^l,\mathbf{h}_j^l,\left\|\mathbf{x}_i^l-\mathbf{x}_j^l\right\|^2,\mathbf{e}_{ij}\right)\\
\mathbf{x}_i^{l+1}&amp;=\mathbf{x}_i^l+\sum_j\left(\mathbf{x}_i^l-\mathbf{x}_j^l\right)\phi_x\left(\mathbf{m}_{ij}\right)\\
\mathbf{m}_i&amp;=\sum_{j\in\mathcal{N}(i)}\mathbf{m}_{ij}\\ \mathbf{h}_i^{l+1}&amp;=\phi_i\left(\mathbf{h}_i^l,\mathbf{m}_i\right)
\end{aligned}
\]</span> 此外还有一个引入动量的拓展版本，坐标向量<span class="math inline">\(\boldsymbol{x}\)</span>将使用一个额外的动量项<span class="math inline">\(\boldsymbol{v}\)</span>做间接地更新： <span class="math display">\[
\begin{array}{l}\mathbf{v}_{i}^{l+1}=\phi_{v}\left(\mathbf{u}_{i}^{l}\right)\mathbf{v}_{i}^{l}+\sum_{j\neq i}\left(\mathbf{x}_{i}^{l}-\mathbf{x}_{j}^{l}\right)\phi_{x}\left(\mathbf{m}_{ij}\right)\\ \mathbf{x}_{i}^{l+1}=\mathbf{x}_{i}^{l}+\mathbf{v}_{i}^{l+1}\end{array}
\]</span> 这一模型等变性的证明比较简单。首先可以证明消息<span class="math inline">\(\mathbf{m}_{ij}\)</span>具有不变性： <span class="math display">\[
\mathbf{m}_{i,j}=\phi_e\left(\mathbf{h}_i^l,\mathbf{h}_j^l,\left\|Q\mathbf{x}_i^l+g-[Q\mathbf{x}_j^l+g]\right\|^2,\mathbf{e}_{ij}\right)=\phi_e\left(\mathbf{h}_i^l,\mathbf{h}_j^l,\left\|\mathbf{x}_i^l-\mathbf{x}_j^l\right\|^2,\mathbf{e}_{ij}\right)
\]</span> 基于此便可以证明<span class="math inline">\(\boldsymbol{x}\)</span>和<span class="math inline">\(\mathbf{v}\)</span>的等变性： <span class="math display">\[
\begin{aligned}
&amp;Q\mathbf{x}_{i}^{l}+g+\sum_{j\neq i}\left(Q \mathbf{x}_{i}^{l}+g-Q \mathbf{x}_{j}^{l}-g\right)\phi_{x}\left(\mathbf{m}_{i,j}\right) \\
=&amp;Q x_{i}^{l}+g+Q\sum_{j\neq i}\left(\mathbf{x}_{i}^{l}-\mathbf{x}_{j}^{l}\right)\phi_{x}\left(\mathbf{m}_{i,j}\right)\\ 
=&amp;Q\left(\mathbf{x}_{i}^{l}+\sum_{j\neq i}\left(\mathbf{x}_{i}^{l}-\mathbf{x}_{j}^{l}\right)\phi_{x}\left(\mathbf{m}_{i,j}\right)\right)+g\\ 
=&amp;Q \mathbf{x}_{i}^{l+1}+g\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;\phi_{v}\left(\mathbf{h}_{i}^{l}\right)Q \mathbf{v}_{i}^{l}+\sum_{j\neq i}\left(Q \mathbf{x}_{i}^{l}+g-[Q \mathbf{x}_{j}^{l}+g]\right)\phi_{x}\left(\mathbf{m}_{ij}\right) \\
=&amp;{Q}\phi_{v}\left(\mathbf{h}_{i}^{l}\right)\mathbf{v}_{i}^l+{Q}\sum_{j\neq i}\left(\mathbf{x}_{i}^{l}-\mathbf{x}_{j}^{l}\right)\phi_{x}\left(\mathbf{m}_{ij}\right)\\
=&amp;Q\left(\phi_{v}\left(\mathbf{h}_{i}^{l}\right)\mathbf{v}_{i}^l+\sum_{j\neq i}\left(\mathbf{x}_{i}^{l}-\mathbf{x}_{j}^{l}\right)\phi_{x}\left(\mathbf{m}_{ij}\right)\right)\\ 
=&amp;Q \mathbf{v}_{i}^{l+1}
\end{aligned}
\]</span></p>
<p>各个特征在变换过程中的等变性和不变性如下图所示：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214411.png" alt="image-20230213165439507" style="zoom:80%;" /></p>
<h3 id="实验结果-2">实验结果</h3>
<p>作者分别在图自编码器，N体模拟和分子性质预测三个任务上面进行实验，下面为它们的结果：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214407.png" alt="image-20230213170017924" style="zoom:80%;" /></p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214403.png" alt="image-20230213170031850" style="zoom:80%;" /></p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214359.png" alt="image-20230213170042077" style="zoom:80%;" /></p>
<p>从中可以看出，EGNN模型在不同的任务上面都能取得很好的结果，甚至在一些任务上面能够达到SOTA。</p>
<h1 id="gnn与分子性质预测">GNN与分子性质预测</h1>
<p>下文为一些分子性质预测任务中一些比较具有代表性的GNN结构。早期的工作例如SchNet主要是从分子能量不变性以及原子力等变性的角度出发，使用标量法来设计网络结构，在此之后也有了一系列的改进工作。</p>
<h2 id="schnet">SchNet</h2>
<h3 id="概述-3">概述</h3>
<p>对于卷积神经网络来说，它处理的是网格化的数据，但是对于分子中的原子来说，它们的位置并不是局限在某个格子内。此外，由于原子的准确位置也包含了重要的物理信息，如果只是简单地将距离离散化，则会丢失掉一些信息。因此，作者构造了SchNet这一图神经网络结构，并且在图卷积操作中使用了连续滤波卷积层（Continuous-filter Convolutional Layers），从而使得图卷积操作可以处理连续变化的数据。</p>
<h3 id="continuous-filter-convolution">Continuous-filter Convolution</h3>
<p>对于原子位置数据，它们的数据类型是连续型的。虽然也可以将这些数据离散化，然后使用离散形式的卷积操作，但是如果要求较高的预测精度则需要使得网格尽量细密。而且更致命的是，离散卷积会导致模型输出的预测值也是离散的。下图所示为使用离散卷积与连续卷积所预测出原子能量变化曲线的示意图：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210814181956.png" alt="image-20210811201216330" style="zoom: 33%;" /></p>
<p>因此，作者提出了Continuous-filter convolutional操作。给定<span class="math inline">\(n\)</span>​​个原子的特征<span class="math inline">\(X^l=(\boldsymbol{x}_1^l,\dots,\boldsymbol{x}_n^l)\)</span>​​，其中<span class="math inline">\(\boldsymbol{x}_i^l\in \mathbb{R}^F\)</span>​​。它们的位置信息为<span class="math inline">\(\boldsymbol{R}=(\boldsymbol{r}_1,\dots,\boldsymbol{r}_n)\)</span>​​，其中<span class="math inline">\(\boldsymbol{r}_i\in \mathbb{R}^D\)</span>​​。第<span class="math inline">\(l\)</span>​​层的Continuous-filter Convolution操作需要一个filter-generating函数<span class="math inline">\(W^l:\mathbb{R}^D \rightarrow \mathbb{R}^F\)</span>​​​​，它将连续形式的位置信息映射为对应的filter value。</p>
<p>在位置<span class="math inline">\(\boldsymbol{r}_i\)</span>​处的Continuous-filter Convolution的计算公式如下： <span class="math display">\[
\boldsymbol{x}_i^{l+1}=(X^l * W^l)_i=\sum_{j} \boldsymbol{x}_j^l \circ W^l(\boldsymbol{r}_i-\boldsymbol{r}_j)
\]</span> 其中<span class="math inline">\(\circ\)</span>代表逐元素相乘，这种计算方式可以提高计算效率。</p>
<h3 id="网络结构-1">网络结构</h3>
<p>SchNet的设计目标是用来预测分子的能量以及其中每个原子的作用力，因此它的网络结构设计能够满足一些基础的物理规则，例如原子序号、平移、旋转不变性，获得连续变化的能量预测值，以及能量守恒的力场。它的网络结构如下图所示：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210814182002.png" alt="image-20210811195328973" style="zoom: 40%;" /></p>
<ul>
<li><p>输入：网络的输入为分子表征，即<span class="math inline">\(n\)</span>个原子的原子序数<span class="math inline">\(Z=(Z_1,\dots,Z_n)\)</span>以及它们的位置<span class="math inline">\(R=(\boldsymbol{r}_1,\dots,\boldsymbol{r}_n)\)</span>。而在网络的隐藏层中，原子的特征被表示为特征向量的形式，即<span class="math inline">\(X^l=(\boldsymbol{x}_1^l,\dots,\boldsymbol{x}_n^l)\)</span>。而特征向量的初始化是通过embedding层来完成的，每个原子序数都对应于一个嵌入向量，即<span class="math inline">\(\boldsymbol{x}_i^0=\boldsymbol{a}_{Z_i}\)</span>。</p></li>
<li><p>激活函数：作者在构造损失函数时，使用了能量与力的联合损失函数，因此要求模型至少二阶可导。为了满足这一条件，作者使用了Shifted softplus函数：<span class="math inline">\(ssp(x)=\ln (0.5e^x+0.5)\)</span></p></li>
<li><p>Atom-wise层：Atom-wise层其实就是一个全连接层，每个原子的特征向量都进行如下的特征变换：<span class="math inline">\(\boldsymbol{x}_i^{l+1}=W^l\boldsymbol{x}_i^n+b^l\)</span>​。由于这些权重系数是所有原子共享的，因此这一网络适用于不同大小的分子。</p></li>
<li><p>Interaction模块：这一模块的主要作用是使用分子的位置信息来更新结点的向量表示。其中使用了残差模块，这使得原子之间的相互作用以及原子自身的特征可以更加灵活地进行组合。</p></li>
<li><p>cfconv层：cfconv层包含了图卷积操作以及filter-generating网络。为了满足旋转不变性，在构造函数<span class="math inline">\(W^l\)</span>​​的时候使用了原子之间的距离。作者提到，如果直接使用距离的标量数值，那么不同层的过滤器将会高度相关，因为初始状态的神经网络接近于线性（为什么？），这将会导致网络难以优化。为了避免这种情况的出现，作者使用了RBF函数对距离的值进行处理，将其扩展为一个向量： <span class="math display">\[
e_k(\boldsymbol{r}_i-\boldsymbol{r}_j)=\exp(-\gamma ||d_{ij}-\mu_k||^2)
\]</span> 通过手动加入非线性，使得过滤器之间的相关性减小。在使用ethanol的分子动力学轨迹数据训练模型之后，三个interaction模块产生的过滤器在二维平面上的可视化效果如下图所示，其中蓝色代表负值，红色代表正值。从中可以看到，每个过滤器只关注特定范围内的原子距离。</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210814182009.png" alt="image-20210811213815132" style="zoom: 50%;" /></p></li>
</ul>
<h3 id="损失函数">损失函数</h3>
<p>网络训练过程中使用的损失函数是能量和力的联合损失函数： <span class="math display">\[
L=\rho ||E-\hat{E}||^2 +\frac{1}{n}\sum_{i=0}^n ||\boldsymbol{F}_i-\hat{\boldsymbol{F}}_i||^2
\]</span> 其中， <span class="math display">\[
\hat{\boldsymbol{F}}_i(Z_1,\dots,Z_n,\boldsymbol{r}_1,\dots,\boldsymbol{r}_n)=-\frac{\partial \hat{E}}{\partial \boldsymbol{r}_i}\left(Z_1,\dots,Z_n,\boldsymbol{r}_1,\dots,\boldsymbol{r}_n \right)
\]</span></p>
<blockquote>
<p>备注：如果使用PyTorch训练SchNet的话，力的计算可以使用<code>torch.autograd.grad</code>函数方便地求得。</p>
</blockquote>
<h3 id="实验结果-3">实验结果</h3>
<p>作者使用QM9、MD17和ISO17三个不同的数据集对SchNet进行训练。其中QM9只包含了平衡态的分子结构，MD17包含了一个分子的分子动力学模拟演化，ISO17同时包含了结构变化和化学变化。结果如下：</p>
<ol type="1">
<li>作者比较了DTNN、enn-s2s以及SchNet这三个网络在QM9数据集上的能量预测误差（MAE），从中可以看出，SchNet的表现是三者中最好的：</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210814182032.png" alt="image-20210811224836103" style="zoom:50%;" /></p>
<ol start="2" type="1">
<li><p>在MD17数据集上，作者将训练结果与GDML和DTNN两个网络进行对比。由于GDML无法在大规模数据集上训练，因此作者使用小规模数据集同时训练SchNet和GDML。在小规模的数据集上，GDML的表现总体优于SchNet。</p>
<p>而如果单从SchNet的训练结果来看，如果在训练过程中只使用能量的数据，那么训练效果并不好，能量和力的误差都较高；但是如果使用能量与力的联合误差，那么能量和力的预测精度都会提升。</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210814182037.png" alt="image-20210811225124541" style="zoom:67%;" /></p></li>
<li><p>在ISO17数据集中，包括了129种化学式为<span class="math inline">\(C_7O_2H_{10}\)</span>​​​​​​​的同分异构体的分子动力学轨迹数据。从模型的预测误差中可以看出，在预测已知分子结构的未知构象（即化学键相同，但是原子的空间位置排布方式不同）时，模型的预测效果较好；但是当遇到分子结构和构象都未知的情况下，预测误差会显著上升。</p></li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20210814182053.png" alt="image-20210811231017558" style="zoom: 33%;" /></p>
<h3 id="总结">总结</h3>
<p>本文提出了Continuous-filter convolution这一新的图卷积运算，使其能够使用连续型的数据直接进行运算，并基于这一图卷积运算提出了SchNet网络结构。SchNet网络结构能够满足如平移不变性、旋转不变性等物理规则，在量子化学的任务上取得了很好的效果。此外，通过构造能量与力的联合损失函数，在分子动力学轨迹数据集上也取得了精确的预测结果。</p>
<p>但是这一结构也具有一定的局限性，比如它无法区分下面的两个图：</p>
<figure>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214346.png" alt="image-20230213173436407" /><figcaption aria-hidden="true">image-20230213173436407</figcaption>
</figure>
<h2 id="dimenet">DimeNet</h2>
<h3 id="概述-4">概述</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzIwMDMuMDMxMjM=">Directional Message Passing for Molecular Graphs<i class="fa fa-external-link-alt"></i></span>是来自于ICLR2020的一篇文章。在这篇文章中，作者提到之前的一些图神经网络在预测分子性质的时候只使用到了原子之间的距离信息，但是却没有考虑原子之间的空间方向信息。但是在一些分子的经验势函数中，原子之间的角度信息却起着关键作用。因此，作者基于MPNN框架设计了DimeNet网络结构，在信息传递过程中加入了角度信息。此外，作者还使用了球贝塞尔函数（可参考<span class="exturl" data-url="aHR0cHM6Ly93dWxpLndpa2kvY2hhbmdlZC9TcGhCc2wuaHRtbA==">球贝塞尔函数<i class="fa fa-external-link-alt"></i></span>）和球谐函数（可参考<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNTEyODkyMTc=">球谐函数介绍<i class="fa fa-external-link-alt"></i></span>）来代替广泛使用的高斯径向基函数，这样可以使用更少的参数量取得更好的效果。</p>
<h3 id="设计思路">设计思路</h3>
<h4 id="输入和输出">输入和输出</h4>
<p>作者设计的DimeNet主要是为了做回归任务，即预测连续型的分子性质，如势能、偶极矩、毒性等。网络的输入仅为原子序数<span class="math inline">\(\boldsymbol{z}=\{z_1,\dots,z_n\}\)</span>和原子的位置<span class="math inline">\(\boldsymbol{X}=\{\boldsymbol{x}_1,\dots,\boldsymbol{x}_n\}\)</span>，输入为一个实数域上的标量，因此网络可以简单地表示为函数<span class="math inline">\(f_{\theta}:\{\boldsymbol{X},\boldsymbol{z}\}\rightarrow \mathbb{R}\)</span>。一些模型额外加入了辅助特征例如化学键类型、原子的电负性等特征，但是作者认为这些信息并不是必要的。此外，如果要将DimeNet作为势函数来使用，则要求网络结构对应的函数满足二阶连续可微的条件，这些辅助特征的加入无法使得网络结构满足这一条件。</p>
<h4 id="角度信息">角度信息</h4>
<p>传统分子势函数的经验公式可以表示为四个部分的和： <span class="math display">\[
E=E_{\text{bond}}+E_{\text{angle}}+E_{\text{torsion}}+E_{\text{non-bonded}}
\]</span> 对于没有加入角度信息的图神经网络来说，上述四个组成部分中缺少了<span class="math inline">\(E_{\text{angle}}+E_{\text{torsion}}\)</span>这两个部分。因此作者提出，加入角度信息是很有必要的。此外，如果没有角度信息，则无法对一些分子结构进行区分，例如苯环结构对应的图结构和两个环丙烷组成的图结构。从这一点来看，引入角度信息就可以解决这一问题。</p>
<p>此外，为了降低计算量，需要引入截断半径，只在一个原子的局部范围内做图卷积运算。</p>
<h4 id="带方向的消息传递">带方向的消息传递</h4>
<p>对于分子性质预测任务来说，图卷积操作需要满足平移不变性、旋转不变性、奇偶对称性，以及网络的输出应当与原子的排列顺序无关。因此作者构造的消息传递函数如下： <span class="math display">\[
\boldsymbol{m}_{ji}^{(l+1)}=f_{\text{update}}\left(\boldsymbol{m}_{ji}^{(l)},\sum_{k\in N(j)\backslash \{i\}} f_{\text{int}}(\boldsymbol{m}_{kj}^{(l)},\boldsymbol{e}_{\text{RBF}}^{(ji)},\boldsymbol{a}_{\text{SBF}}^{(kj,ji)}) \right)
\]</span> 上述公式其实相当于是两次消息传递过程的叠加。消息更新过程使用简单的加和即可，即<span class="math inline">\(\boldsymbol{h}_i^{(l+1)}=\sum_{j}\boldsymbol{m}_{ji}^{(l+1)}\)</span>​。这一过程可以表示为下图：</p>
<figure>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214341.png" alt="image-20210822170218554" /><figcaption aria-hidden="true">image-20210822170218554</figcaption>
</figure>
<p>其中，<span class="math inline">\(\boldsymbol{e}_{\text{RBF}}^{(ji)}\)</span>​​是结点之间距离<span class="math inline">\(d_{ji}\)</span>​​​经过径向基函数的转换而得到的一个长度为<span class="math inline">\(N_{\text{RBF}}\)</span>​的向量，每个元素通过下面的公式计算而得： <span class="math display">\[
e_{\text{RBF,n}}(d)=u(d)\sqrt{\frac{2}{c}}\frac{\sin (\frac{n\pi}{c}d)}{d}
\]</span> 上式中的<span class="math inline">\(n\in[1,2,\dots,N_{\text{RBF}}]\)</span>​​​，<span class="math inline">\(c\)</span>​代表截断半径。</p>
<p>而<span class="math inline">\(\boldsymbol{a}_{\text{SBF}}^{(kj,ji)}\)</span>则指的是结点之间距离<span class="math inline">\(d_{kj}\)</span>和结点<span class="math inline">\(i,j,k\)</span>的角度<span class="math inline">\(\alpha_{(kj,ji)}\)</span>经过贝塞尔基函数计算得到的一个长度为<span class="math inline">\(N_{\text{SRBF}}*N_{\text{SHBF}}\)</span>向量，其中每个元素的计算公式如下： <span class="math display">\[
a_{\text{SBF,ln}}(d,\alpha)=u(d)\sqrt{\frac{2}{c^3 j_{l+1}^2(z_{ln})}}j_l(\frac{z_{ln}}{c}d)Y_l^0(\alpha)
\]</span> 上式中，<span class="math inline">\(l\in[0,1,\dots,N_{\text{SHBF}-1}]\)</span>，<span class="math inline">\(n\in[1,2,\dots,N_{\text{SRBF}}]\)</span>，<span class="math inline">\(c\)</span>为截断半径，<span class="math inline">\(z_{ln}\)</span>代表<span class="math inline">\(l\)</span>阶贝塞尔函数的第<span class="math inline">\(n\)</span>个根（可以通过数值计算的方法提前计算完成），<span class="math inline">\(j_l\)</span>代表第一类球贝塞尔函数的第<span class="math inline">\(l\)</span>项表达式，<span class="math inline">\(Y_l^0\)</span>表示<span class="math inline">\(m=0\)</span>的第<span class="math inline">\(l\)</span>项球谐函数的表达式。这样构造的原因是考虑了定态薛定谔方程在三维无限深势阱内的球坐标解可以表示为<span class="math inline">\(\Psi(d,\alpha,\phi)=\sum_{l=0}^{\infty}\sum_{m=-l}^{l}(a_{lm}j_l(kd)+b_{lm}y_{l}(kd))Y_l^m(\alpha,\phi)\)</span>。</p>
<p>RBF和SBF函数乘上<span class="math inline">\(u(d)\)</span>​是为了使它们能够在截断半径处连续地过渡到0，作者使用了如下的多项式函数： <span class="math display">\[
u(d)=1-\frac{(p+1)(p+2)}{2}d^p+p(p+2)d^{p+1}-\frac{p(p-1)}{2}d^{p+2}
\]</span> 按照这种方式构造的消息传递操作可以满足平移不变性、旋转不变性、奇偶对称性的要求，且输出与原子的排列顺序无关。</p>
<h3 id="网络结构-2">网络结构</h3>
<p>DimeNet的网络结构如下图所示。图中的<span class="math inline">\(\boldsymbol{W}\)</span>​和<span class="math inline">\(\boldsymbol{b}\)</span>代表可学习参数，<span class="math inline">\(||\)</span>​代表向量的拼接操作，<span class="math inline">\(\odot\)</span>​代表逐元素相乘的操作，<span class="math inline">\(\sum\)</span>代表累加操作，<span class="math inline">\(+\)</span>​代表逐元素相加，<span class="math inline">\(\sigma\)</span>代表Swish激活函数<span class="math inline">\(\sigma(x)=x\cdot \text{sigmoid}(x)\)</span>。</p>
<figure>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214326.png" alt="image-20210822170721639" /><figcaption aria-hidden="true">image-20210822170721639</figcaption>
</figure>
<h3 id="实验结果-4">实验结果</h3>
<p>DimeNet在QM9数据集上的表现如下表所示，其中每一个预测目标都对应于一个单独的模型：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214323.png" alt="image-20210822172442992" style="zoom: 50%;" /></p>
<p>从中可以看到，相比于其它几个网络结构，DimeNet在大多数预测目标上面都能取得最好的效果。而且从平均绝对误差百分比来看，DimeNet比效果第二好的PhysNet要好31%。</p>
<p>在MD17数据集上，DimeNet的表现如下。需要注意的是，这一结果是通过仅使用1000个训练样本来训练模型得到的。</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214318.png" alt="image-20210822173015784" style="zoom:50%;" /></p>
<p>从中可以看出，DimeNet的预测误差率与sGDML比较接近，能够取得较好的精度。</p>
<h3 id="改进">改进</h3>
<p>原始的DimeNet需要很大的计算开销，而且计算速度较慢，因此后面有了优化版的模型DimeNet++，它对原始的网络结构做了一些修改（其中红色部分为修改的地方）：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214314.png" alt="image-20230213180242647" style="zoom: 80%;" /></p>
<p>原始的DimeNet模型最耗时的在矩阵乘法<span class="math inline">\(\square^T \mathbf{W}\square\)</span>这一步计算上，因此作者舍弃掉了这一步，将其修改为逐元素乘积，从而显著加快了速度。与此同时，模型的精度相比于原始模型也有了微弱的提升：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214310.png" alt="image-20230213180600070" style="zoom:80%;" /></p>
<h3 id="总结-1">总结</h3>
<p>DimeNet结构在消息传递的过程中引入了键角信息，从而使得在分子性质预测任务上能够取得更好的效果。但是这样仍然具有一定的局限性。例如DimeNet无法区分如下的两个分子：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214306.png" alt="image-20230213181156947" style="zoom:80%;" /></p>
<p>此外，DimeNet也无法区分手性分子。</p>
<p>DimeNet虽然引入了键角信息，但消息传递过程仍然只是具有<span class="math inline">\(E(3)\)</span>不变性。要解决上述的问题，则需要设计<span class="math inline">\(SE(3)\)</span>不变的消息传递。或者另一种方法是引入具有<span class="math inline">\(E(3)\)</span>等变性的特征（可以参考工作<span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzIxMDIuMDMxNTA=">Equivariant message passing for the prediction of tensorial properties and molecular spectra<i class="fa fa-external-link-alt"></i></span>），比如EGNN网络中使用的动量特征<span class="math inline">\(\mathbf{v}\)</span>，如下图所示：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214304.png" alt="image-20230213181900528" style="zoom:80%;" /></p>
<h2 id="gemnet">GemNet</h2>
<h3 id="概述-5">概述</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzIxMDYuMDg5MDM=">GemNet<i class="fa fa-external-link-alt"></i></span>这一工作在DimeNet的基础上，在消息传递过程中额外添加了二面角信息，从而实现了在消息传递过程中的<span class="math inline">\(SE(3)\)</span>不变性，但是与此同时也使得模型的计算开销进一步增大。</p>
<h3 id="网络结构-3">网络结构</h3>
<p>在消息传递过程中，作者定义了下图所示的两跳消息传递：</p>
<figure>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214258.png" alt="image-20230213204939931" /><figcaption aria-hidden="true">image-20230213204939931</figcaption>
</figure>
<p>在两跳消息传递的过程中，以原子<span class="math inline">\(a\)</span>为中心，计算原子<span class="math inline">\(c\)</span>给原子<span class="math inline">\(a\)</span>传递的消息<span class="math inline">\(\boldsymbol{m}_{ca}\)</span>时，不仅要像DimeNet一样考虑<span class="math inline">\(a,c\)</span>的直接作用关系，<span class="math inline">\(a\)</span>的另一个邻居<span class="math inline">\(b\)</span>再加上<span class="math inline">\(c\)</span>所产生的<span class="math inline">\(a,b,c\)</span>三者之间的作用关系，还要考虑<span class="math inline">\(b\)</span>的邻居<span class="math inline">\(d\)</span>所产生的<span class="math inline">\(a,b,c,d\)</span>这四个原子之间的关系。</p>
<p>最终的消息传递表达式如下： <span class="math display">\[
\tilde{\boldsymbol{m}}_{ca}=\sum_{b\in\mathcal{N}_{a}^\mathrm{int}\setminus\{c\},d\in \mathcal{N}_{b}^\mathrm{emb}\setminus\{a,c\}} \left((\mathbf{W}_{\mathrm{SBF1}}\mathbf{e}_{\mathrm{SBF}}(x_{ca},\varphi_{cab},\theta_{cabd}))^T\mathbf{W}((\mathbf{W}_{\mathrm{CBF2}}\mathbf{W}_{\mathrm{CBF1}}e_{\mathrm{CBF}}(x_{ba},\varphi_{abd})) \\
\odot(\boldsymbol{W}_{\mathrm{RBF2}}\boldsymbol{W}_{\mathrm{RBF1}}\boldsymbol{e}_{\mathrm{RBF}}(x_{db}))\odot\boldsymbol{m}_{db})\right)
\]</span> GemNet的网络结构如下图所示，与DimeNet有些类似之处：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214255.png" alt="image-20230213204219340" style="zoom: 67%;" /></p>
<p>其中RBF，CBF和SBF的定义如下： <span class="math display">\[
\begin{aligned}
\tilde{\mathbf{e}}_{\mathrm{RBF},n}(x_{d b})=&amp;\sqrt{\frac{2}{c_{\mathrm{emb}}}}\frac{\sin(\frac{\pi\pi}{c_{\mathrm{emb}}}x_{d b})}{x_{d b}}\\ 
\tilde{\mathbf{e}}_{\mathrm{CBF};l n}(x_{b a},\varphi_{a b d})=&amp;\sqrt{\frac{2}{c_{\mathrm{int}}^{3}j_{a}^{2}+1}(z_{l n})}j_{l}(\frac{z_{l n}}{c_{\mathrm{int}}}x_{b a})Y_{l0}(\varphi_{a b d})\\
\tilde{\mathbf{e}}_{\mathbf{SBF},l m n}(x_{c a},\varphi_{c a b},\theta_{c a b d})=&amp;\sqrt{\frac{2}{c_{\mathrm{emb}}^{3}j_{l+1}^{2}(z_{l n})}}j_{l}(\frac{z_{l n}}{c_{\mathrm{emb}}}x_{c a})Y_{l m}(\varphi_{c a b},\theta_{c a b d})
\end{aligned}
\]</span> 这里的RBF和CBF定义与DimeNet中的RBF和SBF相同，而GemNet中的SBF则是以球谐函数作为基函数所计算出的特征向量。</p>
<h3 id="实验结果-5">实验结果</h3>
<p>作者在MD17，COLL以及OC20数据集上分别做了实验。在实验结果中，GemNet-Q代表使用两跳的消息传递，GemNet-T代表只使用一跳的消息传递（类似DimeNet），后缀为dQ和dT的代表让模型直接预测原子力。</p>
<p>MD17数据集上的原子力的预测误差（MAE）如下表所示：</p>
<figure>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214252.png" alt="image-20230213211747478" /><figcaption aria-hidden="true">image-20230213211747478</figcaption>
</figure>
<p>从中可以看出，GemNet比其它几种参与对比的网络结构有着更低的预测误差。同时也可以看到，使用两跳消息传递与一跳消息传递的预测误差十分接近。</p>
<p>在COLL数据集上的预测误差（MAE）如下表所示：</p>
<figure>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214249.png" alt="image-20230213212140209" /><figcaption aria-hidden="true">image-20230213212140209</figcaption>
</figure>
<p>在这一数据集上的结果显示，两跳的消息传递能够取得更低的预测误差。此外，直接预测原子力的误差，相比于先预测能量然后再求导计算原子力的误差，也会更大一些。</p>
<p>在OC20数据集上的结果显示，GemNet相比于其它模型也有着更好的表现：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214243.png" alt="image-20230213212700994" style="zoom:80%;" /></p>
<p>除此之外，作者也做了不同模型的运行时间对比：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20230213214232.png" alt="image-20230213212843141"  /></p>
<p>将运行时间进行对比可以发现，模型训练过程中最耗时的模块为两跳的消息传递过程（Q和T相比）。此外如果对能量求导来计算力，然后再反向传播优化模型的过程也比较耗时（Q和dQ，T和dT相比）。而在推理阶段，最耗时的仍然为两跳的消息传播（Q和T相比）。</p>
<h3 id="总结-2">总结</h3>
<p>GemNet这一工作设计了两跳的消息传递，使得模型的消息传递过程能够保持<span class="math inline">\(SE(3)\)</span>不变性，在下游任务上面能够取得更好的结果。但是这样的设计也带来了更大的计算开销，在模型训练和推理阶段，相比于DimeNet这种一跳的消息传递，用时会有成倍的提升。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Yufei Luo
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://lyf35.github.io/2022/12/11/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E7%AD%89%E5%8F%98%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" title="论文笔记-等变图神经网络">http://lyf35.github.io/2022/12/11/论文笔记-等变图神经网络/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" rel="tag"><i class="fa fa-tag"></i> 图神经网络</a>
              <a href="/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 论文笔记</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/12/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Score-based%20model/" rel="prev" title="深度学习-Score-Based model">
      <i class="fa fa-chevron-left"></i> 深度学习-Score-Based model
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yufei Luo</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">22:56</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动
  </div>

        






<script data-pjax>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"ypNNXSdcGIIoldC5BBmViS2g-gzGzoHsz","app_key":"0TDwohU7eO4yHTn4tley8PtE","server_url":"https://leancloud.cn/dashboard/data.html?appid=ypNNXSdcGIIoldC5BBmViS2g-gzGzoHsz#/","security":false};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="//cdn.jsdelivr.net/npm/ribbon.js@1/dist/ribbon.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/next-theme/pjax@0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  
  <script data-pjax>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>









<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>


    <div class="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      const script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4dcdc02d24075b0e9d3a',
      clientSecret: '53cf2cb8b89b9d4bba922bb19bda1290f0d0bf95',
      repo        : 'lyf35.github.io',
      owner       : 'lyf35',
      admin       : ['lyf35'],
      id          : '44ad081822993c024b43209664a078b7',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
