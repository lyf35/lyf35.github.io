<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">
  <link rel="manifest" href="/images/site.webmanifest">
  <meta name="msapplication-config" content="/images/browserconfig.xml">
  <meta name="msvalidate.01" content="<meta name="msvalidate.01" content="5D3796A5DDB32CC875380613FB613833" />">
  <meta name="baidu-site-verification" content="<meta name="baidu-site-verification" content="kewHZtFYQk" />">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Helvetica:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-flat-top.min.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lyf35.github.io","root":"/","scheme":"Pisces","version":"8.0.0-rc.5","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="Computational secure encryption Perfect secrecy Perfect secrecy: absolutely no information is leaked, even the eavesdropper has unlimited computational power(not practical in reality so it could be co">
<meta property="og:type" content="article">
<meta property="og:title" content="密码学-私钥加密">
<meta property="og:url" content="http://lyf35.github.io/2020/07/30/%E5%AF%86%E7%A0%81%E5%AD%A6-%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/index.html">
<meta property="og:site_name" content="Yufei Luo&#39;s Blog">
<meta property="og:description" content="Computational secure encryption Perfect secrecy Perfect secrecy: absolutely no information is leaked, even the eavesdropper has unlimited computational power(not practical in reality so it could be co">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000711.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000601.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000614.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000652.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000624.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000754.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000800.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000809.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000823.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000836.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000850.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000857.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000906.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000929.png">
<meta property="article:published_time" content="2020-07-30T13:29:24.000Z">
<meta property="article:modified_time" content="2020-08-15T14:52:35.000Z">
<meta property="article:author" content="Yufei Luo">
<meta property="article:tag" content="信息安全">
<meta property="article:tag" content="密码学">
<meta property="article:tag" content="计算机基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000711.png">

<link rel="canonical" href="http://lyf35.github.io/2020/07/30/%E5%AF%86%E7%A0%81%E5%AD%A6-%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>密码学-私钥加密 | Yufei Luo's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
 <!--   <div class="headband"></div>-->

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Yufei Luo's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">But I was so much older then, I am younger than that now.</p>
      <img class="custom-logo-image" src="/images/logo.png" alt="Yufei Luo's Blog">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-计算机基础">

    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80" rel="section"><i class="fa fa-tags fa-fw"></i>计算机基础</a>

  </li>
        <li class="menu-item menu-item-机器学习">

    <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0" rel="section"><i class="fa fa-tags fa-fw"></i>机器学习</a>

  </li>
        <li class="menu-item menu-item-深度学习">

    <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0" rel="section"><i class="fa fa-tags fa-fw"></i>深度学习</a>

  </li>
        <li class="menu-item menu-item-工程实践">

    <a href="/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5" rel="section"><i class="fa fa-tags fa-fw"></i>工程实践</a>

  </li>
        <li class="menu-item menu-item-论文笔记">

    <a href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0" rel="section"><i class="fa fa-tags fa-fw"></i>论文笔记</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#computational-secure-encryption"><span class="nav-number">1.</span> <span class="nav-text">Computational secure encryption</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#perfect-secrecy"><span class="nav-number">1.1.</span> <span class="nav-text">Perfect secrecy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#computational-secrecy"><span class="nav-number">1.2.</span> <span class="nav-text">Computational secrecy</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#definitions"><span class="nav-number">1.2.1.</span> <span class="nav-text">Definitions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#approaches"><span class="nav-number">1.2.2.</span> <span class="nav-text">Approaches</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#proof-by-reduction"><span class="nav-number">1.3.</span> <span class="nav-text">Proof by reduction</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#constructing-secure-encryption-schemes"><span class="nav-number">2.</span> <span class="nav-text">Constructing secure encryption schemes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#private-key-encryption-scheme"><span class="nav-number">2.1.</span> <span class="nav-text">Private-key encryption scheme</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#basic-definition-of-security"><span class="nav-number">2.2.</span> <span class="nav-text">Basic definition of security</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#adversarial-indistinguishability-experiment"><span class="nav-number">2.2.1.</span> <span class="nav-text">Adversarial indistinguishability experiment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eav-secure"><span class="nav-number">2.2.2.</span> <span class="nav-text">EAV-secure</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pseudorandom-generators-stream-cipher"><span class="nav-number">2.3.</span> <span class="nav-text">Pseudorandom generators &amp; Stream cipher</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pseudorandom-pad"><span class="nav-number">2.4.</span> <span class="nav-text">Pseudorandom pad</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#definition"><span class="nav-number">2.4.1.</span> <span class="nav-text">Definition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#proof-by-reduction-1"><span class="nav-number">2.4.2.</span> <span class="nav-text">Proof by reduction</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cpa-secure-encryption-schemes"><span class="nav-number">3.</span> <span class="nav-text">CPA-secure encryption schemes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#security-for-multiple-encryptions"><span class="nav-number">3.1.</span> <span class="nav-text">Security for multiple encryptions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chosen-plaintext-attacks-and-cpa-security"><span class="nav-number">3.2.</span> <span class="nav-text">Chosen-Plaintext Attacks and CPA security</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cpa-indistinguishability-experiment"><span class="nav-number">3.2.1.</span> <span class="nav-text">CPA indistinguishability experiment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lr-oracle-experiment"><span class="nav-number">3.2.2.</span> <span class="nav-text">LR-oracle experiment</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pseudorandom-functions"><span class="nav-number">3.3.</span> <span class="nav-text">Pseudorandom functions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#definition-1"><span class="nav-number">3.3.1.</span> <span class="nav-text">Definition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pseudorandom-permutations"><span class="nav-number">3.3.2.</span> <span class="nav-text">Pseudorandom permutations</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pseudorandom-generator-using-pseudorandom-functions"><span class="nav-number">3.3.3.</span> <span class="nav-text">Pseudorandom generator using pseudorandom functions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cpa-secure-encryption"><span class="nav-number">3.4.</span> <span class="nav-text">CPA-secure encryption</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#definition-2"><span class="nav-number">3.4.1.</span> <span class="nav-text">Definition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#proof-by-reduction-2"><span class="nav-number">3.4.2.</span> <span class="nav-text">Proof by reduction</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stream-cipher-revisit"><span class="nav-number">3.5.</span> <span class="nav-text">Stream cipher revisit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#block-cipher"><span class="nav-number">3.6.</span> <span class="nav-text">Block cipher</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#electronic-code-bookecb-mode"><span class="nav-number">3.6.1.</span> <span class="nav-text">Electronic Code Book(ECB) mode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cipher-block-chainingcbc-mode"><span class="nav-number">3.6.2.</span> <span class="nav-text">Cipher Block Chaining(CBC) mode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#output-feedbackofb-mode"><span class="nav-number">3.6.3.</span> <span class="nav-text">Output Feedback(OFB) mode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#counterctr-mode"><span class="nav-number">3.6.4.</span> <span class="nav-text">Counter(CTR) mode</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chosen-ciphertext-attacks"><span class="nav-number">4.</span> <span class="nav-text">Chosen-Ciphertext Attacks</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#cca-security"><span class="nav-number">4.1.</span> <span class="nav-text">CCA-security</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#practical-applications"><span class="nav-number">5.</span> <span class="nav-text">Practical applications</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#stream-cipher"><span class="nav-number">5.1.</span> <span class="nav-text">Stream cipher</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#linear-feedback-shift-registers"><span class="nav-number">5.1.1.</span> <span class="nav-text">Linear-feedback Shift Registers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trivium"><span class="nav-number">5.1.2.</span> <span class="nav-text">Trivium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rc4"><span class="nav-number">5.1.3.</span> <span class="nav-text">RC4</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#block-cipher-1"><span class="nav-number">5.2.</span> <span class="nav-text">Block cipher</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#des-encryption-scheme"><span class="nav-number">5.2.1.</span> <span class="nav-text">DES encryption scheme</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#feistel-networks"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">Feistel networks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#des"><span class="nav-number">5.2.1.2.</span> <span class="nav-text">DES</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aes-encryption-scheme"><span class="nav-number">5.2.2.</span> <span class="nav-text">AES encryption scheme</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#substitution-permutation-networks"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">Substitution-permutation networks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#aes"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">AES</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#references"><span class="nav-number">6.</span> <span class="nav-text">References</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yufei Luo"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Yufei Luo</p>
  <div class="site-description" itemprop="description">哪怕什么真理无穷，进一寸有进一寸的欢喜</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x5ZjM1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lyf35"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmx5ZjEyMzQwMDAwMDBAMTYzLmNvbQ==" title="E-Mail → mailto:lyf1234000000@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



      </section>
        <div class="back-to-top animated">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x5ZjM1" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lyf35.github.io/2020/07/30/%E5%AF%86%E7%A0%81%E5%AD%A6-%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Yufei Luo">
      <meta itemprop="description" content="哪怕什么真理无穷，进一寸有进一寸的欢喜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yufei Luo's Blog">
    </span>

    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          密码学-私钥加密
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-30 21:29:24" itemprop="dateCreated datePublished" datetime="2020-07-30T21:29:24+08:00">2020-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-15 22:52:35" itemprop="dateModified" datetime="2020-08-15T22:52:35+08:00">2020-08-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">理论知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">信息安全</span></a>
                </span>
            </span>

          
            <span id="/2020/07/30/%E5%AF%86%E7%A0%81%E5%AD%A6-%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/" class="post-meta-item leancloud_visitors" data-flag-title="密码学-私钥加密" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>34k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>31 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="computational-secure-encryption">Computational secure encryption</h1>
<h2 id="perfect-secrecy">Perfect secrecy</h2>
<p><strong>Perfect secrecy</strong>: absolutely no information is leaked, even the eavesdropper has unlimited computational power(not practical in reality so it could be compromised in implementation).</p>
<p>Two attacks apply regardless of how the encryption scheme is constructed:</p>
<ol type="1">
<li><p>Brute force attack: the adversary decrypt <span class="math inline">\(c\)</span> using all keys <span class="math inline">\(k\in \mathcal{K}\)</span>.</p></li>
<li><p>Random attack: the adversary guess a uniform key <span class="math inline">\(k\in \mathcal{K}\)</span> and check to see whether <span class="math inline">\(Dec_{k}(c_{i})=m_{i}\)</span> for all <span class="math inline">\(i\)</span>, which has success probability <span class="math inline">\(\frac{1}{|\mathcal{K}|}\)</span>. <span id="more"></span></p></li>
</ol>
<p><em>Introducting relaxations of perfect secrecy are essential for achieving practical encryption schemes!</em></p>
<h2 id="computational-secrecy">Computational secrecy</h2>
<h3 id="definitions">Definitions</h3>
<p><strong>Computational secrecy</strong>: incorporates two relaxations relative to theoretic definitions of security</p>
<ol type="1">
<li>Security is only guaranteed against efficient adversaries that run for some feasible amount of time.</li>
<li>Adversaries can potentially succeed with very small probability.</li>
</ol>
<h3 id="approaches">Approaches</h3>
<p>Two general approaches to realize computational secrecy:</p>
<ol type="1">
<li>The concrete approach</li>
</ol>
<p>Definition: A scheme is <span class="math inline">\((t, \epsilon)\)</span>-secure if any adversary running for time at most <span class="math inline">\(t\)</span> succeeds in breaking the scheme with probability at most <span class="math inline">\(\epsilon\)</span>.</p>
<p>In practice, precise concrete guarantees are <em>diffcult</em> to provide(The uncertainty of computing power, algorithm, etc).</p>
<ol start="2" type="1">
<li>The asymptotic approach</li>
</ol>
<p>Definition: A scheme is secure if any PPT(probabilistic polynomial-time, i.e. randomized algorithm running in time polynomial in <span class="math inline">\(n\)</span>, which could be defined to be efficient) adversary <span class="math inline">\(\mathcal{A}\)</span> carrying out an attack of some formally specied type, and for every positive polynomial <span class="math inline">\(p\)</span>, there exists an integer <span class="math inline">\(N\)</span> such that when <span class="math inline">\(n&gt;N\)</span> the probability that <span class="math inline">\(\mathcal{A}\)</span> succeeds in the attack is less than <span class="math inline">\(\frac{1}{p(n)}\)</span> (i.e. negligible success probability).</p>
<p>Please note that <em>nothing is guaranteed for values <span class="math inline">\(n\le N\)</span></em>!</p>
<p>Example: an adversary running for <span class="math inline">\(n^3\)</span> minutes can succeed in breaking the scheme with probability <span class="math inline">\(2^{40-n}\)</span>. For <span class="math inline">\(n=50\)</span>, the adversary running for 3 months could only succeed with probability roughly <span class="math inline">\(\frac{1}{1000}\)</span>, while for <span class="math inline">\(n\le 40\)</span> the adversary can definitely succeed within 6 weeks.</p>
<p>Negligible function: a function <span class="math inline">\(f\)</span> from natural numbers <span class="math inline">\(n\)</span> to the non-negative real numbers is negligible if for every positive polynomial <span class="math inline">\(p(n)\)</span> there is an N such that for all integers <span class="math inline">\(n&gt;N\)</span> it holds that <span class="math inline">\(f(n)&lt;\frac{1}{p(n)}\)</span>. E.g. <span class="math inline">\(f(n)=2^{-n}\)</span>.</p>
<p>Closure properties for negligible functions:</p>
<ul>
<li><span class="math inline">\(negl_{3}=negl_{1}+negl_{2}\)</span> is negligible.</li>
<li>For any positive polynomial <span class="math inline">\(poly\)</span>, <span class="math inline">\(negl_{4}=poly\cdot negl_{1}\)</span> is negligible.</li>
</ul>
<h2 id="proof-by-reduction">Proof by reduction</h2>
<p>To prove that a given encryption construction is computationally secure, we must rely on unproven assumptions (mostly <span class="math inline">\(P\ne NP\)</span>) which is hard mathematically unless it's information-theoretically secure.</p>
<p>Steps of proof by reduction:</p>
<ol type="1">
<li>Assuming some efficient (i.e. probabilistic polynomial-time) adversary <span class="math inline">\(\mathcal{A}\)</span> attacking <span class="math inline">\(\Pi\)</span> with succcess probability <span class="math inline">\(\epsilon(n)\)</span>.</li>
<li>Construct an efficient algorithm <span class="math inline">\(\mathcal{A}&#39;\)</span>, called the "reduction", that attempts to solve problem X using adversary <span class="math inline">\(\mathcal{A}\)</span> as a subroutine. <span class="math inline">\(\mathcal{A}&#39;\)</span> knows nothing about <span class="math inline">\(\mathcal{A}\)</span> except that <span class="math inline">\(\mathcal{A}\)</span> is attacking <span class="math inline">\(\Pi\)</span>. Given some input instance x of problem X, algorithm <span class="math inline">\(\mathcal{A}&#39;\)</span> will simulate for <span class="math inline">\(\mathcal{A}\)</span> an instance of <span class="math inline">\(\Pi\)</span> that:
<ul>
<li>The view of <span class="math inline">\(\mathcal{A}\)</span> when run as a subroutine by <span class="math inline">\(\mathcal{A}&#39;\)</span> should be distributed identically to (or at least close to) the view of <span class="math inline">\(\mathcal{A}\)</span> when it interacts with <span class="math inline">\(\Pi\)</span> itself.</li>
<li>If <span class="math inline">\(\mathcal{A}\)</span> succeeds in breaking the instance of <span class="math inline">\(\Pi\)</span> that simulated by <span class="math inline">\(\mathcal{A}&#39;\)</span>, this should allow <span class="math inline">\(\mathcal{A}&#39;\)</span> to solve the instance x it was given, at least with inverse polynomial probability <span class="math inline">\(1/p(n)\)</span>.</li>
</ul></li>
<li>1 &amp; 2 imply that <span class="math inline">\(\mathcal{A}&#39;\)</span> solves X with probability <span class="math inline">\(\epsilon(n)/p(n)\)</span>. If <span class="math inline">\(\epsilon(n)\)</span> is negligible, then neither is <span class="math inline">\(\epsilon(n)/p(n)\)</span>.</li>
<li>Given our assumption regarding X, we conclude that no efficient adversary <span class="math inline">\(\mathcal{A}\)</span> can succeed in breaking <span class="math inline">\(\Pi\)</span> with non-negligible probability. i.e. <span class="math inline">\(\Pi\)</span> is computational secure.</li>
</ol>
<h1 id="constructing-secure-encryption-schemes">Constructing secure encryption schemes</h1>
<h2 id="private-key-encryption-scheme">Private-key encryption scheme</h2>
<p><strong>Private-key encryption scheme</strong>: A tuple of probability polynomial-time algorithms $(Gen, Enc, Dec) $ that</p>
<ol type="1">
<li><p>The key-generation algorithm <span class="math inline">\(Gen\)</span> takes as input <span class="math inline">\(1^{n}\)</span> (i.e. the security parameter is fixed) and outputs a key <span class="math inline">\(k\)</span>, i.e. <span class="math inline">\(k\leftarrow Gen(1^{n})\)</span>(emphasizing that Gen is a randomized algorithm). Without loss of generality, assuming that <span class="math inline">\(|k|\ge n\)</span>.</p></li>
<li><p>The encryption algorithm <span class="math inline">\(Enc\)</span> takes a key <span class="math inline">\(k\)</span> and a plaintext message <span class="math inline">\(m\in \{0, 1\}^*\)</span> as input and outputs a ciphertext <span class="math inline">\(c\)</span>. Since Enc might be randomized, we write it as <span class="math inline">\(c\leftarrow Enc_{k}(m)\)</span>.</p></li>
<li><p>The decryption algorithm <span class="math inline">\(Dec\)</span> takes a key <span class="math inline">\(k\)</span> and a ciphertext <span class="math inline">\(c\)</span> as input and outputs a message <span class="math inline">\(m\)</span> or an error. Assuming that Dec is deterministic, so we write <span class="math inline">\(m=Dec_{k}(c)\)</span>.</p></li>
</ol>
<p>It's required that for every <span class="math inline">\(n\)</span>, every <span class="math inline">\(k\leftarrow Gen(1^n)\)</span> and every message <span class="math inline">\(m\in {0, 1}^*\)</span>, it always holds that <span class="math inline">\(Dec_{k}(Enc_{k}(m))=m\)</span>.</p>
<p>Note that the definition considers stateless schemes, in which each invocation of <span class="math inline">\(Enc\)</span> and <span class="math inline">\(Dec\)</span> is independent of all prior invocations.</p>
<h2 id="basic-definition-of-security">Basic definition of security</h2>
<h3 id="adversarial-indistinguishability-experiment">Adversarial indistinguishability experiment</h3>
<p><strong>The adversarial indistinguishability experiment <span class="math inline">\(PrivK_{\mathcal{A},\pi}^{eav}(n)\)</span></strong>:</p>
<ol type="1">
<li><p>The adversary <span class="math inline">\(\mathcal{A}\)</span> outputs a pair of messages <span class="math inline">\(m_{0}, m_{1}\in \mathcal{M}\)</span> with <span class="math inline">\(|m_{0}|=|m_{1}|\)</span> (no limitation with the length itself).</p></li>
<li><p>A key <span class="math inline">\(k\)</span> is generated by running <span class="math inline">\(Gen(1^n)\)</span>, and a uniform bit <span class="math inline">\(b\in \{0, 1\}\)</span> is chosen. Challenge ciphertext <span class="math inline">\(c\leftarrow Enc_{k}(m_{b})\)</span> is computed and given to <span class="math inline">\(\mathcal{A}\)</span>.</p></li>
<li><p><span class="math inline">\(\mathcal{A}\)</span> outputs a bit <span class="math inline">\(b&#39;\)</span>.</p></li>
<li><p>The output of the experiment is 1 if <span class="math inline">\(b&#39;=b\)</span>, and 0 otherwise. We say <span class="math inline">\(PrivK_{\mathcal{A},\pi}^{eav}(n)=1\)</span> if the output of the experiment is 1 and in this case we say that <span class="math inline">\(\mathcal{A}\)</span> succeeds.</p></li>
</ol>
<p>The modification in the definition of adversarial indistinguishability experiment <span class="math inline">\(PrivK_{\mathcal{A}, \pi}^{eav}\)</span>:</p>
<ol type="1">
<li><p>The adversaries running in polynomial time rather than unbounded running time.</p></li>
<li><p>The adversary might determine the encrypted message with probability negligibly better than <span class="math inline">\(\frac{1}{2}\)</span>.</p></li>
<li><p>The experiment is parameterized with a security parameter <span class="math inline">\(n\)</span>, for both running time and success probability.</p></li>
<li><p>The experiment requires two messages <span class="math inline">\(m_{0}\)</span>, <span class="math inline">\(m_{1}\)</span> with equal length.</p></li>
</ol>
<h3 id="eav-secure">EAV-secure</h3>
<p><strong>EAV-secure</strong>: a private-key encryption scheme <span class="math inline">\(\Pi=(Gen, Enc, Dec)\)</span> has indistinguishable encryptions in the presence of an eavesdropper if all probabilistic polynomial-time adversaries <span class="math inline">\(\mathcal{A}\)</span> there is a negligible function <span class="math inline">\(negl\)</span> such that, for all <span class="math inline">\(n\)</span>, <span class="math display">\[
Pr[PrivK_{\cal{A}, \pi}^{eav}(n)]\le \frac{1}{2}+negl(n)
\]</span></p>
<p>An equivalent formulation: <span class="math display">\[
|Pr[out_{\cal{A}}(PrivK_{\cal{A}, \pi}^{eav}(n,0))=1]-Pr[out_{\cal{A}}(PrivK_{\cal{A}, \pi}^{eav}(n,1))=1]|\le negl(n)
\]</span> <span class="math inline">\(PrivK_{\mathcal{A}, \pi}^{eav}(n,b)\)</span> means that the fixed bit <span class="math inline">\(b\)</span> is used in the experiment, i.e. the encrypted message is determined rather than random.</p>
<p>Note: the default notion of secure encryption does not require to hide the plaintext length, and all commonly used encryption schemes reveal the plaintext length, since it is impossible to support arbitrary-length messages while hiding information about the plaintext length. But sometimes leaking the plaintext length is problematic. E.g. simple numeric/text data, database searches, auto-suggestions, etc.. <em>By padding them to pre-determined length before encrypting</em> could mitigate or prevent the leakage.</p>
<h2 id="pseudorandom-generators-stream-cipher">Pseudorandom generators &amp; Stream cipher</h2>
<p><strong>Pseudorandom generator</strong>: let <span class="math inline">\(\ell\)</span> (called the expansion factor) be a polynomial and let <span class="math inline">\(G\)</span> be a deterministic polynomial-time algorithm such that for any <span class="math inline">\(n\)</span> and any input <span class="math inline">\(s\in \{0, 1\}^n\)</span>, the result <span class="math inline">\(G(s)\)</span> is a string of length <span class="math inline">\(\ell(n)\)</span>. We say that <span class="math inline">\(G\)</span> is a pseudorandom ("uniform looking") generator if the following conditions hold:</p>
<ol type="1">
<li><p>Expansion: for every <span class="math inline">\(n\)</span> it holds that <span class="math inline">\(\ell(n)&gt;n\)</span></p></li>
<li><p>Pseudorandomness: for any PPT algorithm <span class="math inline">\(D\)</span>, there is a negligible function <span class="math inline">\(negl\)</span> such that <span class="math display">\[
|Pr[D(G(s))=1]-Pr[D(r)=1]|\le negl(n)
\]</span> where the first probability is taken over uniform choice of <span class="math inline">\(s\in \{0, 1\}^n\)</span> and the randomness of <span class="math inline">\(D\)</span>, and the second probability is taken over uniform choice <span class="math inline">\(r\in \{0, 1\}^{\ell(n)}\)</span> and the randomness of <span class="math inline">\(D\)</span>.</p></li>
</ol>
<p>The seed for a pseudorandom generator is analogous to the cryptographic key used by an encryption scheme, so the seed must be chosen uniformly and be kept secret from any adversary. And <span class="math inline">\(s\)</span> must be long enough to make it infeasible to numerate all possible seeds.</p>
<p><strong>Stream ciphers</strong> are used to instantiate pseudorandom generators. The pseudorandom output bits are produced gradually and on demand, so the application can request exactly as many pseudorandom bits as needed, which improves efficiency and flexibility.</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000711.png" alt="image-20201019205856414" style="zoom: 80%;" /></p>
<h2 id="pseudorandom-pad">Pseudorandom pad</h2>
<h3 id="definition">Definition</h3>
<p><strong>Pseudorandom pad</strong>: Let <span class="math inline">\(G\)</span> be a pseudorandom generator with expansion factor <span class="math inline">\(\ell\)</span> (please note that the expansion factor is fixed in this definition, so do not confuse with the definition of stream cipher above). Define a private-key encryption scheme for messages of length <span class="math inline">\(\ell\)</span> as follows:</p>
<ul>
<li><span class="math inline">\(Gen\)</span>: on input <span class="math inline">\(1^n\)</span>, choose uniform <span class="math inline">\(k\in \{0,1\}^n\)</span> and output it as the key. (<span class="math inline">\(|G(k)|\)</span> could be much larger than <span class="math inline">\(n\)</span> so that's why we use it).</li>
<li><span class="math inline">\(Enc\)</span>: on input key <span class="math inline">\(k\in \{0,1\}^n\)</span> and a message <span class="math inline">\(m\in \{0,1\}^{\ell(n)}\)</span>, output the ciphertext <span class="math inline">\(c:=G(k)~XOR~m\)</span>.</li>
<li><span class="math inline">\(Dec\)</span>: on input key <span class="math inline">\(k\in \{0,1\}^n\)</span> and a ciphertext <span class="math inline">\(c\in \{0,1\}^{\ell(n)}\)</span>, output the message <span class="math inline">\(m:=G(k)~XOR~c\)</span>.</li>
</ul>
<p>If <span class="math inline">\(G\)</span> is a pseudorandom generator, then the above construction is a fixed-length private-key encryption scheme that has indistinguishable encryptions in the presence of an <em>eavesdropper</em>.</p>
<h3 id="proof-by-reduction-1">Proof by reduction</h3>
<p>let <span class="math inline">\(\Pi\)</span> denote the construction of pseudorandom pad. <span class="math inline">\(\mathcal{A}\)</span> satisfies the definition of EAV-secure. i.e. for any probabilistic polynomial-time adversary <span class="math inline">\(\mathcal{A}\)</span> there is a negligible function <span class="math inline">\(negl\)</span> satisfies: <span class="math inline">\(Pr[PrivK_{\mathcal{A},\pi}^{eav}(n)=1]\le \frac{1}{2}+negl(n)\)</span>.</p>
<p>Constructing a distinguisher <span class="math inline">\(D\)</span> based on <span class="math inline">\(\mathcal{A}\)</span>: <span class="math inline">\(D\)</span> is given a string <span class="math inline">\(w\in \{0, 1\}^{\ell(n)}\)</span> as input.</p>
<ul>
<li>Run <span class="math inline">\(\mathcal{A}\)</span><span class="math inline">\((1^{n})\)</span> to obtain a pair of messages <span class="math inline">\(m_{0}, m_{1}\in \{0, 1\}^{\ell(n)}\)</span>.</li>
<li>Choose a uniform bit <span class="math inline">\(b\in \{0, 1\}\)</span>. Set <span class="math inline">\(c:=w~XOR~m_b\)</span>.</li>
<li>Give <span class="math inline">\(c\)</span> to <span class="math inline">\(\mathcal{A}\)</span> and obtain output <span class="math inline">\(b&#39;\)</span>. Output 1 if <span class="math inline">\(b&#39;=b\)</span>, and output 0 otherwise.</li>
</ul>
<p>Let <span class="math inline">\(\tilde{\Pi}=(\tilde{Gen},\tilde{Enc},\tilde{Dec})\)</span> denote the exactly one-time pad encryption scheme. Perfect secrecy of one-time pad implies that <span class="math inline">\(Pr[PrivK_{\mathcal{A},\tilde{\pi}}^{eav}(n)=1]=\frac{1}{2}\)</span>.</p>
<ul>
<li><p>If <span class="math inline">\(w\)</span> is chosen uniformly from <span class="math inline">\(\{0,1\}^{\ell(n)}\)</span>, then the view of <span class="math inline">\(\mathcal{A}\)</span> when run as a subroutine by <span class="math inline">\(D\)</span> is distributed identically to the view of <span class="math inline">\(\mathcal{A}\)</span> in experiment <span class="math inline">\(PrivK_{\mathcal{A},\tilde{\pi}}^{eav}(n)\)</span>. So we have <span class="math display">\[
      Pr_{w\leftarrow \{0,1\}}^{\ell(n)}[D(w)=1]=Pr[PrivK_{\cal{A},\tilde{\pi}}^{eav}(n)]=\frac{1}{2}
\]</span></p></li>
<li><p>If <span class="math inline">\(w\)</span> is generated by choosing uniform <span class="math inline">\(k\in \{0,1\}^n\)</span> and then setting <span class="math inline">\(w:=G(k)\)</span>, then the view of <span class="math inline">\(\mathcal{A}\)</span> when run as a subroutine by <span class="math inline">\(D\)</span> is distributed identically to the view of <span class="math inline">\(\mathcal{A}\)</span> in experiment <span class="math inline">\(PrivK_{\mathcal{A},\tilde{\pi}}^{eav}(n)\)</span>. Thus, <span class="math display">\[
      Pr_{k\leftarrow \{0,1\}}^{n}[D(G(k))=1]=Pr[PrivK_{\cal{A},\pi}^{eav}(n)]
\]</span></p></li>
</ul>
<p>Since <span class="math inline">\(G\)</span> is a pseudorandom generator, there is a negligible function <span class="math inline">\(negl\)</span> such that <span class="math display">\[
    |Pr_{w\leftarrow \{0,1\}}^{\ell(n)}[D(w)=1]-Pr_{k\leftarrow \{0,1\}}^{n}[D(G(k))=1]|\le negl(n)
\]</span> Combining the above three equations, we can get <span class="math inline">\(|\frac{1}{2}-Pr[PrivK_{\mathcal{A},\pi}^{eav}(n)]|\le negl(n)\)</span>, i.e. <span class="math inline">\(Pr[PrivK_{\mathcal{A},\pi}^{eav}(n)]\le \frac{1}{2}+negl(n)\)</span>.</p>
<h1 id="cpa-secure-encryption-schemes">CPA-secure encryption schemes</h1>
<h2 id="security-for-multiple-encryptions">Security for multiple encryptions</h2>
<p><strong>The multiple-message eavesdropping experiment <span class="math inline">\(PrivK_{\mathcal{A},\pi}^{multi}(n)\)</span>:</strong></p>
<ol type="1">
<li>The adversary <span class="math inline">\(\mathcal{A}\)</span> is given input <span class="math inline">\(1^n\)</span>, and outputs a pair of equal-length lists of messages <span class="math inline">\(\overrightarrow{M_0}=(m_{0,1},\dots,m_{0,t})\)</span> and <span class="math inline">\(\overrightarrow{M_1}=(m_{1,1},\dots,m_{1,t})\)</span>, with <span class="math inline">\(|m_{0,i}|=|m_{1,i}|\)</span> for all <span class="math inline">\(i\)</span>.</li>
<li>A key <span class="math inline">\(k\)</span> is generated by running <span class="math inline">\(Gen(1^n)\)</span>, and a uniform big <span class="math inline">\(b\in \{0,1\}\)</span> is chosen. For all <span class="math inline">\(i\)</span>, the ciphertext <span class="math inline">\(c_{i}\leftarrow Enc_{k}(m_{b,i})\)</span> is computed and the list <span class="math inline">\(\overrightarrow{C}=(c_{1},\dots,c_{t})\)</span> is given to <span class="math inline">\(\mathcal{A}\)</span>.</li>
<li><span class="math inline">\(\mathcal{A}\)</span> outputs a bit <span class="math inline">\(b&#39;\)</span>.</li>
<li>The output of the experiment is defined to be 1 if <span class="math inline">\(b&#39;=b\)</span>, and 0 otherwise.</li>
</ol>
<p>A private-key encryption scheme <span class="math inline">\(\Pi=(Gen,Enc,Dec)\)</span> has indistinguishable multiple encryptions in the presense of an eavesdropper if for all probabilistic polynomial-time adversaries <span class="math inline">\(\mathcal{A}\)</span> there is a negligible function <span class="math inline">\(negl\)</span> such that <span class="math display">\[
Pr[PrivK_{\cal{A},\pi}^{multi}(n)=1]\le \frac{1}{2}+negl(n)
\]</span></p>
<p><em>There is a private-key encryption scheme that has indistinguishable encryptions in the presence of an eavesdropper, but not indistinguishable multiple encryptions in the presence of an eavesdropper.</em> (Consider <span class="math inline">\(\mathcal{A}\)</span> attacking one-time pad encryption with <span class="math inline">\(\overrightarrow{M_{0}}=(0^{\ell},0^{\ell})\)</span> and <span class="math inline">\(\overrightarrow{M_{1}}=(0^{\ell},1^{\ell})\)</span>)</p>
<p><strong>Necessity of probabilistic encryption</strong>: if <span class="math inline">\(\Pi\)</span> is a stateless encryption scheme in which <span class="math inline">\(Enc\)</span> is a deterministic function of the key and the message, then <span class="math inline">\(\Pi\)</span> cannot have indistinguishable multiple encryptions in the presence of an eavesdropper. i.e. the encryption should be randomized for encrypting multiple messages.</p>
<h2 id="chosen-plaintext-attacks-and-cpa-security">Chosen-Plaintext Attacks and CPA security</h2>
<h3 id="cpa-indistinguishability-experiment">CPA indistinguishability experiment</h3>
<p>The CPA(Chosen-Plaintest Attacks) indistinguishability experiment <span class="math inline">\(PrivK_{\mathcal{A},\pi}^{cpa}(n)\)</span>:</p>
<ol type="1">
<li>A key is generated by running <span class="math inline">\(Gen(1^n)\)</span>.</li>
<li>The adversary <span class="math inline">\(\mathcal{A}\)</span> is given input <span class="math inline">\(1^{n}\)</span> and oracle access to <span class="math inline">\(Enc_{K}(\cdot)\)</span>, and outputs a pair of messages <span class="math inline">\(m_{0}, m_{1}\)</span> of the same length.</li>
<li>A uniform bit <span class="math inline">\(b\in \{0,1\}\)</span> is chosen, and then a ciphertext <span class="math inline">\(c\leftarrow Enc_{k}(m_{b})\)</span> is computed and given to <span class="math inline">\(\mathcal{A}\)</span>.</li>
<li>The adversary <span class="math inline">\(\mathcal{A}\)</span> continues to have oracle access to <span class="math inline">\(Enc_{K}(\cdot)\)</span>, and outputs a bit <span class="math inline">\(b&#39;\)</span>.</li>
<li>The output of the experiment is defined to be 1 if <span class="math inline">\(b&#39;=b\)</span>, and 0 otherwise. The former case means that <span class="math inline">\(\mathcal{A}\)</span> succeeds.</li>
</ol>
<p>A private-key encryption scheme <span class="math inline">\(\Pi=(Gen, Enc, Dec)\)</span> has indistinguishable encryptions under a chosen-plaintext attack, or is CPA-secure, is for all probabilistic polynomial-time adversaries <span class="math inline">\(\mathcal{A}\)</span> there is a negligible function <span class="math inline">\(negl\)</span> such that <span class="math display">\[
Pr[PrivK_{\cal{A},\pi}^{cpa}(n)=1]\le \frac{1}{2}+negl(n)
\]</span></p>
<h3 id="lr-oracle-experiment">LR-oracle experiment</h3>
<p>The above definition of CPA-secure can be extended to the case of multiple encryptions by using lists of plaintexts.</p>
<p>The LR-oracle(left-or-right) experiment <span class="math inline">\(PrivK_{\mathcal{A},\pi}^{LR-cpa}(n)\)</span>:</p>
<ol type="1">
<li>A key <span class="math inline">\(k\)</span> is generated by running <span class="math inline">\(Gen(1^{n})\)</span>.</li>
<li>A uniform bit <span class="math inline">\(b\in \{0,1\}\)</span> is chosen.</li>
<li>The adversary <span class="math inline">\(\mathcal{A}\)</span> is given input <span class="math inline">\(1^{n}\)</span> and oracle access to <span class="math inline">\(LR_{k,b}(m_{0,1},m_{1,1}),\dots,LR_{k,b}(m_{0,t},m_{1,t})\)</span> (The function <span class="math inline">\(LR_{k,b}(\cdot,\cdot)\)</span> randomly choose one of the two input texts and return the encrypted text).</li>
<li>The adversary <span class="math inline">\(\mathcal{A}\)</span> outputs a bit <span class="math inline">\(b&#39;\)</span>.</li>
<li>The output of the experiment is defined to be 1 if <span class="math inline">\(b&#39;=b\)</span> and 0 otherwise. In the former case we say that <span class="math inline">\(\mathcal{A}\)</span> succeeds.</li>
</ol>
<p>Private-key encryption scheme <span class="math inline">\(\Pi\)</span> has indistinguishable multiple encryptions under a chosen-plaintext attack, or is CPA-secure for multiple encryptions, if for all probabilistic polynomial-time adversaries <span class="math inline">\(\mathcal{A}\)</span> there is a negligible function <span class="math inline">\(negl\)</span> such that <span class="math display">\[
Pr[PrivK_{\cal{A},\pi}^{LR-cpa}(n)=1]\le \frac{1}{2}+negl(n)
\]</span></p>
<p><em>Any private-key encryption scheme that is CPA-secure is also CPA-secure for multiple encryptions.</em>(Different from eavesdropping adversaries!)</p>
<h2 id="pseudorandom-functions">Pseudorandom functions</h2>
<h3 id="definition-1">Definition</h3>
<p>Define a keyed function <span class="math inline">\(F(k,x):\{0,1\}^{*}\times \{0,1\}^{*}\rightarrow \{0,1\}^{*}\)</span> to be a two-input function, where the first input is called the key and denoted <span class="math inline">\(k\)</span>. When the key is fixed, it becomes a single-input function <span class="math inline">\(F_{k}(x)\)</span>. If there is a polynomial-time algorithm to compute <span class="math inline">\(F\)</span>, we say <span class="math inline">\(F\)</span> is efficient. And <span class="math inline">\(F\)</span> is length-preserving if <span class="math inline">\(\ell_{key}=\ell_{in}=\ell_{out}=n\)</span>.</p>
<p><strong>Pseudorandom functions</strong>: let <span class="math inline">\(F(k,x):\{0,1\}^{*}\times \{0,1\}^{*}\rightarrow \{0,1\}^{*}\)</span> be an efficient, length-preserving, keyed function. F is a pseudorandom function if for all probabilistic polynomial-time distinguishers <span class="math inline">\(D\)</span>, there is a negligible function <span class="math inline">\(negl\)</span> such that: <span class="math display">\[
|Pr[D^{F_{K}(\cdot)}(1^{n})=1]-Pr[D^{f(\cdot)}(1^{n})=1]|\le negl(n)
\]</span> where the first probability is taken over uniform choice of <span class="math inline">\(k\in \{0,1\}^{n}\)</span> and the randomness of <span class="math inline">\(D\)</span>, and the second probability is taken over uniform choice of <span class="math inline">\(f\in Func_{n}\)</span> and the randomness of <span class="math inline">\(D\)</span>.</p>
<p>The set <span class="math inline">\(Func_{n}\)</span> contains all the functions that mapping n-bit strings to n-bit strings. How large is <span class="math inline">\(Func_{n}\)</span>?</p>
<ul>
<li>View the function <span class="math inline">\(f\in Func_{n}\)</span> as a large look-up table.</li>
<li><span class="math inline">\(f\)</span> has <span class="math inline">\(2^n\)</span> rows(all possible n-bit strings) with each row contains a n-bit string(here the string in each row could be same). So each <span class="math inline">\(f\)</span> can be viewed as a string with <span class="math inline">\(n\cdot 2^n\)</span> bits.</li>
<li>For a string with <span class="math inline">\(n\cdot 2^n\)</span> bits, the number of string with this length is <span class="math inline">\(2^{n\cdot 2^n}\)</span>(each bit could be 0 or 1).</li>
<li>So we conclude that <span class="math inline">\(|Func_{n}|=2^{n\cdot 2^n}\)</span>.</li>
</ul>
<h3 id="pseudorandom-permutations">Pseudorandom permutations</h3>
<p>Let <span class="math inline">\(Perm_{n}\)</span> denotes the set of all permutations(i.e. bijections) on <span class="math inline">\(\{0,1\}^{n}\)</span>. For any <span class="math inline">\(f\in Perm_{n}\)</span>, we can still view it as a look-up table, but <em>with a constraint that the entries in any two distinct rows must be different</em>. There are <span class="math inline">\(2^n\)</span> different choices for the first row; then the second row is left with <span class="math inline">\(2^{n}-1\)</span> choices, and so on. So we can get <span class="math inline">\(|Perm_{n}|=(2^{n})!\)</span></p>
<p>Keyed permutation: let <span class="math inline">\(F\)</span> be a keyed funciton. If <span class="math inline">\(\ell_{in}=\ell_{out}\)</span>, and for all <span class="math inline">\(k\in \ell_{key}(n)\)</span> the function <span class="math inline">\(F_{k}:\{0,1\}^{\ell_{in}(n)}\rightarrow \{0,1\}^{\ell_{in}(n)}\)</span> is a permutation, we call <span class="math inline">\(F\)</span> a keyed permutation. <span class="math inline">\(\ell_{in}\)</span> is the block length of <span class="math inline">\(F\)</span>. If <span class="math inline">\(\ell_{key}=\ell_{in}=n\)</span>, we say <span class="math inline">\(F\)</span> is length-preserving. And a keyed permutation is efficient if there is a polynomial-time algorithm for computing <span class="math inline">\(y=F_{k}(x)\)</span> as well as a polynomial-time algorithm for computing <span class="math inline">\(x=F_{k}^{-1}(y)\)</span>.</p>
<p>If <span class="math inline">\(F\)</span> is a pseudorandom permutation and additionally <span class="math inline">\(\ell_{in}\ge n\)</span>, then <span class="math inline">\(F\)</span> is also a pseudorandom function.</p>
<p><strong>Pseudorandom permutations</strong>: Let <span class="math inline">\(F:\{0,1\}^{*}\times \{0,1\}^{*}\rightarrow \{0,1\}^{*}\)</span> be an efficient, length-preserving, keyed permutation. <span class="math inline">\(F\)</span> is a strong pseudorandom permutation if for all probabilistic polynomial-time distinguishers <span class="math inline">\(D\)</span> there exists a negligible function <span class="math inline">\(negl\)</span> such that: <span class="math display">\[
|Pr[D^{F_{K}(\cdot),F_{K}^{-1}(\cdot)}(1^{n})=1]-Pr[D^{f(\cdot),f^{-1}(\cdot)}(1^{n})=1]|\le negl(n)
\]</span> where the first probability is taken over uniform choice of <span class="math inline">\(k\in \{0,1\}^{n}\)</span> and the randomness of <span class="math inline">\(D\)</span>, and the second probability is taken over uniform choice of <span class="math inline">\(f\in Perm_{n}\)</span> and the randomness of <span class="math inline">\(D\)</span>.</p>
<h3 id="pseudorandom-generator-using-pseudorandom-functions">Pseudorandom generator using pseudorandom functions</h3>
<p>Once we get a pseudorandom function <span class="math inline">\(F\)</span>, it becomes easy to construct a pseudorandom generator <span class="math inline">\(G(s)\overset{def}{=}F_{s}(1)||F_{s}(2)||\cdots ||F_{s}(\ell)\)</span> for any desired <span class="math inline">\(\ell\)</span>.</p>
<p>We can also use pseudorandom function to construct a stream cipher <span class="math inline">\((Init, GetBits)\)</span> where each call to <span class="math inline">\(GetBits\)</span> outputs <span class="math inline">\(n\)</span> bits as follows:</p>
<ul>
<li><span class="math inline">\(Init\)</span>: on input <span class="math inline">\(s\in \{0,1\}^n\)</span> and <span class="math inline">\(IV\in \{0,1\}^n\)</span>, set <span class="math inline">\(st_{0}:=(s,IV)\)</span>.</li>
<li><span class="math inline">\(GetBits\)</span>: on input <span class="math inline">\(st_{i}:=(s,IV)\)</span>, compute <span class="math inline">\(IV&#39;=IV+1\)</span> and set <span class="math inline">\(y:=F_{s}(IV&#39;)\)</span> and <span class="math inline">\(st_{i+1}:=(s,IV&#39;)\)</span>. Output <span class="math inline">\((y,st_{i+1})\)</span>.</li>
</ul>
<h2 id="cpa-secure-encryption">CPA-secure encryption</h2>
<h3 id="definition-2">Definition</h3>
<p>Let <span class="math inline">\(F\)</span> be a pseudorandom function, then a CPA-secure private-key encryption scheme for messages of length <span class="math inline">\(n\)</span> can be constructed as follows:</p>
<ul>
<li><span class="math inline">\(Gen\)</span>: on input <span class="math inline">\(1^n\)</span>, choose uniform <span class="math inline">\(k\in \{0,1\}^n\)</span> and output it.</li>
<li><span class="math inline">\(Enc\)</span>: on input a key <span class="math inline">\(k\in \{0,1\}^n\)</span> and a message <span class="math inline">\(m\in \{0,1\}^n\)</span>, choose uniform <span class="math inline">\(r\in\{0,1\}^n\)</span> and output the ciphertext <span class="math inline">\(c:=&lt;r,F_{k}(r)~XOR~m&gt;\)</span>.</li>
<li><span class="math inline">\(Dec\)</span>: on input a key <span class="math inline">\(k\in \{0,1\}^n\)</span> and a ciphertext <span class="math inline">\(c=&lt;r,s&gt;\)</span>, output the plaintext message <span class="math inline">\(m:=F_{k}(r)~XOR~s\)</span>.</li>
</ul>
<h3 id="proof-by-reduction-2">Proof by reduction</h3>
<p><strong>Step 1:</strong></p>
<p>Construct a distinguisher <span class="math inline">\(D\)</span> that is given input <span class="math inline">\(1^n\)</span> and access to an oracle <span class="math inline">\(\mathcal{O}\)</span><span class="math inline">\(:\{0,1\}^{n}\rightarrow \{0,1\}^{n}\)</span>. 1. Run <span class="math inline">\(\mathcal{A}\)</span><span class="math inline">\((1^n)\)</span>. Whenever <span class="math inline">\(\mathcal{A}\)</span> queries its encryption oracle on a message <span class="math inline">\(m\in \{0,1\}^{n}\)</span>, 1) choose a uniform <span class="math inline">\(r\in \{0,1\}^{n}\)</span>; 2) query <span class="math inline">\(\mathcal{O}\)</span><span class="math inline">\((r)\)</span> and get response <span class="math inline">\(y\)</span>; 3) return the ciphertext <span class="math inline">\(&lt;r,y~XOR~m&gt;\)</span> to <span class="math inline">\(\mathcal{A}\)</span>. 2. When <span class="math inline">\(\mathcal{A}\)</span> outputs messages <span class="math inline">\(m_{0},m_{1}\in \{0,1\}^{n}\)</span>, choose a uniform bit <span class="math inline">\(b\in \{0,1\}\)</span> and then 1) choose uniform <span class="math inline">\(r\in \{0,1\}^{n}\)</span>; 2) query <span class="math inline">\(\mathcal{O}\)</span><span class="math inline">\((r)\)</span> and obtain response <span class="math inline">\(y\)</span>; 3) return the challenge ciphertext <span class="math inline">\(&lt;r,y~XOR~m_{b}&gt;\)</span> to <span class="math inline">\(\mathcal{A}\)</span>. 3. Continue answering encryption-oracle queries of <span class="math inline">\(\mathcal{A}\)</span> as before until <span class="math inline">\(\mathcal{A}\)</span> outputs a bit <span class="math inline">\(b&#39;\)</span>. Output 1 if <span class="math inline">\(b&#39;=b\)</span> and 0 otherwise.</p>
<ol type="a">
<li><p>If <span class="math inline">\(D\)</span>'s oracle is pseudorandom function, then the view of <span class="math inline">\(\mathcal{A}\)</span> when run as a subroutine by <span class="math inline">\(D\)</span> is distributed identically to the view of <span class="math inline">\(\mathcal{A}\)</span> in experiment <span class="math inline">\(PrivK_{\mathcal{A},\pi}^{cpa}(n)\)</span>, since <span class="math inline">\(k\)</span> and <span class="math inline">\(r\)</span> are chosen uniformly. So, <span class="math display">\[
Pr_{k\leftarrow \{0,1\}^n}[D^{F_{k}(\cdot)}(1^{n})=1]=Pr[PrivK_{\cal{A},\pi}^{cpa}(n)=1]
\]</span></p></li>
<li><p>If <span class="math inline">\(D\)</span>'s oracle is a random function, then the view of <span class="math inline">\(\mathcal{A}\)</span> when run as a subroutine by <span class="math inline">\(D\)</span> is distributed identically to the view of <span class="math inline">\(\mathcal{A}\)</span> in experiment <span class="math inline">\(PrivK_{\mathcal{A},\tilde{\pi}}^{cpa}(n)\)</span> (<span class="math inline">\(\tilde{\pi}\)</span> represents the encryption scheme using a truly random function <span class="math inline">\(f\)</span> instead). So, <span class="math display">\[
Pr_{f\leftarrow Func_{n}}[D^{F_{k}(\cdot)}(1^{n})=1]=Pr[PrivK_{\cal{A},\tilde{\pi}}^{cpa}(n)=1]
\]</span></p></li>
<li><p>By the assumption that <span class="math inline">\(F\)</span> is a pseudorandom function, the following inequation holds: <span class="math display">\[
|Pr[D^{F_{K}(\cdot)}(1^{n})=1]-Pr[D^{f(\cdot)}(1^{n})=1]|\le negl(n)
\]</span></p></li>
</ol>
<p>Combining the above three equations we can get: <span class="math display">\[
|Pr[PrivK_{\cal{A},\pi}^{cpa}(n)=1]-Pr[PrivK_{\cal{A},\tilde{\pi}}^{cpa}(n)=1]|\le negl(n)
\]</span></p>
<p><strong>Step 2:</strong></p>
<p>Everytime a message <span class="math inline">\(m\)</span> is encrypted in <span class="math inline">\(PrivK_{\mathcal{A},\tilde{\pi}}^{cpa}(n)\)</span> (either by the encryption oracle or computing the challenge ciphertext), a uniform <span class="math inline">\(r\in \{0,1\}^n\)</span> is chosen and the ciphertext is set equal to <span class="math inline">\(&lt;r,f(r)~XOR~m&gt;\)</span>.</p>
<p>Let <span class="math inline">\(r^*\)</span> denote the random string used when generating the challenge ciphertext <span class="math inline">\(&lt;r^{*},f(r^{*})~XOR~m_{b}&gt;\)</span>. There are two possibilities:</p>
<ol type="a">
<li><p>The value <span class="math inline">\(r^*\)</span> is never used when answering any of <span class="math inline">\(\mathcal{A}\)</span>'s encryption-oracle queries: <span class="math inline">\(\mathcal{A}\)</span> learns nothing about <span class="math inline">\(f(r^{*})\)</span> from its interaction with the encryption oracle. The value <span class="math inline">\(f(r^{*})\)</span> is uniformly distrubuted and independent of the rest of the experiment. So the probability that <span class="math inline">\(\mathcal{A}\)</span> outputs <span class="math inline">\(b&#39;=b\)</span> in this case is exactly <span class="math inline">\(1/2\)</span>.</p></li>
<li><p>The value <span class="math inline">\(r^*\)</span> is used when answering at lease one of <span class="math inline">\(\mathcal{A}\)</span>'s encryption-oracle queries: in this case, <span class="math inline">\(\mathcal{A}\)</span> may easily determine whether <span class="math inline">\(m_{0}\)</span> or <span class="math inline">\(m_{1}\)</span> was encrypted (<span class="math inline">\(\mathcal{A}\)</span> can get <span class="math inline">\(f(r^{*})\)</span> from ciphertext <span class="math inline">\(&lt;r^*, s&gt;\)</span> and message <span class="math inline">\(m\)</span> by <span class="math inline">\(s~XOR~m\)</span>). However, <span class="math inline">\(\mathcal{A}\)</span> makes at most <span class="math inline">\(q(n)\)</span> queries(i.e. at most <span class="math inline">\(q(n)\)</span> values of <span class="math inline">\(r\)</span>), and since <span class="math inline">\(r^{*}\)</span> is chosen uniformly from <span class="math inline">\(\{0,1\}^n\)</span>, the probability of this event is at most <span class="math inline">\(q(n)/2^{n}\)</span>.</p></li>
</ol>
<p>Let <span class="math inline">\(Repeat\)</span> denote the event that <span class="math inline">\(r^*\)</span> is used by the encryption oracle when answering at least one of <span class="math inline">\(\mathcal{A}\)</span>'s queries. The probability of <span class="math inline">\(Repeat\)</span> is at most <span class="math inline">\(q(n)/2^{n}\)</span>, and the probability that <span class="math inline">\(\mathcal{A}\)</span> succeeds in <span class="math inline">\(PrivK_{\mathcal{A},\tilde{\pi}}^{cpa}(n)\)</span> if <span class="math inline">\(Repeat\)</span> does not occur is exactly <span class="math inline">\(1/2\)</span>. Therefore: <span class="math display">\[
\begin{align}
Pr[PrivK_{\cal{A},\tilde{\pi}}^{cpa}(n)=1] &amp;= Pr[PrivK_{\cal{A},\tilde{\pi}}^{cpa}(n)=1\wedge Repeat]+Pr[PrivK_{\cal{A},\tilde{\pi}}^{cpa}(n)=1\wedge \overline{Repeat}]  \\
      &amp;\le Pr[Repeat]+Pr[PrivK_{\cal{A},\tilde{\pi}}^{cpa}(n)=1|\overline{Repeat}] \\
      &amp;\le \frac{q(n)}{2^{n}}+\frac{1}{2}
\end{align}
\]</span></p>
<p>Combining the equations, we can get: <span class="math display">\[
Pr[PrivK_{\cal{A},\pi}^{cpa}(n)=1]\le \frac{1}{2}+\frac{q(n)}{2^{n}}+negl(n)
\]</span> Since <span class="math inline">\(q\)</span> is polynomial, <span class="math inline">\(q(n)/2^{n}\)</span> is negligible. The sum of two negligible functions is still negligible, so there exists a negligible function <span class="math inline">\(negl&#39;\)</span> such that <span class="math display">\[
Pr[PrivK_{\cal{A},\pi}^{cpa}(n)=1]\le \frac{1}{2}+negl&#39;(n)
\]</span> thus completing the proof.</p>
<h2 id="stream-cipher-revisit">Stream cipher revisit</h2>
<p>Recall that the pseudorandom pad encryption is not CPA-secure since the key could only be used once, and the length of the message must be fixed and known in advance.</p>
<p>We already have a brief introduction about stream cipher, which can be used to address the drawbacks of pseudorandom pad encryption. In practice, stream cipher are used for encryption in two ways:</p>
<ul>
<li><strong>Synchronized mode</strong>: the sender and receiver must be synchronized in the sense that they know how much plaintext has been encrypted (decrypted) so far. The initialization vector <span class="math inline">\(IV\)</span> is not needed.</li>
<li><strong>unsynchronized mode</strong>: the initialization vector <span class="math inline">\(IV\)</span> is needed to generate pseudorandom bits. If <span class="math inline">\(IV\)</span> is chosen uniformly, then this scheme is CPA-secure.</li>
</ul>
<figure>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000601.png" alt="image-20201019213147276" /><figcaption aria-hidden="true">image-20201019213147276</figcaption>
</figure>
<h2 id="block-cipher">Block cipher</h2>
<p>The CPA-secure scheme encryption has the drawback that the ciphertext is double the length of the plaintext. Block-cipher modes of operation provide a way of encrypting arbitrary-lengh message using shorter ciphertexts.</p>
<p>All the messages are seperated as several blocks <span class="math inline">\(m=m_{1},m_{2},\dots m_{\ell}\)</span> where each <span class="math inline">\(m_{i}\in \{0,1\}^{n}\)</span> represents a block of the plaintext. The block size <span class="math inline">\(n\)</span> should be sufficient large to ensure concrete security. If the message length is not a multiple of <span class="math inline">\(n\)</span>, it can be padded by appending a 1 followed by sufficiently many 0s.</p>
<h3 id="electronic-code-bookecb-mode">Electronic Code Book(ECB) mode</h3>
<p><span class="math inline">\(c:=&lt;F_{k}(m_{1}),F_{k}(m_{2},\cdots,F_{k}(m_{\ell}))&gt;\)</span>. This mode is <em>deterministic</em> and therefore cannot be CPA-secure. This mode is even not indistinguishable in the presence of an eavesdropper(the block might be repeated in the plaintext which result in a repeating block in the ciphertext). <em>This mode should not be used!</em></p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000614.png" alt="image-20201019213425365" style="zoom:50%;" /></p>
<h3 id="cipher-block-chainingcbc-mode">Cipher Block Chaining(CBC) mode</h3>
<p>First choose a uniform initialization vector <span class="math inline">\(IV\)</span>, then set <span class="math inline">\(c_{0}:=IV\)</span> and <span class="math inline">\(c_{i}=F_{k}(c_{i-1}~XOR~m_{i})\)</span>. The final ciphertext is <span class="math inline">\(&lt;c_{0},c_{1},\dots,c_{\ell}&gt;\)</span>. If <span class="math inline">\(F\)</span> is a pseudorandom permutation, then CBC-mode encryption is CPA-secure. But the encryption must be carried out sequentially, and <span class="math inline">\(F\)</span> should be invertible.</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000652.png" alt="image-20201019213454186" style="zoom:50%;" /></p>
<p>A variant of CBC-mode encryption is called chained CBC-mode, in which the last block of the previous ciphertext is used as the <span class="math inline">\(IV\)</span> when encrypting the next message. But chained CBC mode is vulnerable to a chosen-plaintext attack.</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000624.png" alt="image-20201019213512182" style="zoom: 80%;" /></p>
<h3 id="output-feedbackofb-mode">Output Feedback(OFB) mode</h3>
<p>First choose a uniform initialization vector <span class="math inline">\(IV\)</span>. Define <span class="math inline">\(y_{0}:=IV\)</span> and set <span class="math inline">\(y_{i}:=F_{k}(y_{i-1})\)</span>. Each block of plaintext is encrypted by <span class="math inline">\(c_{i}:=y_{i}~XOR~m_{i}\)</span>. Compared with CBC mode, OFB mode does not require <span class="math inline">\(F\)</span> be invertible, and the plaintext length is not required to be a multiple of the block length. If <span class="math inline">\(F\)</span> is a pseudorandom permutation, then OFB-mode encryption is CPA-secure.</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000754.png" alt="image-20201019213643311" style="zoom:50%;" /></p>
<h3 id="counterctr-mode">Counter(CTR) mode</h3>
<p>First choose a uniform value <span class="math inline">\(ctr\in \{0,1\}^n\)</span>. Then the pseudorandom stream is generated by computing <span class="math inline">\(y_{i}:=F_{k}[(ctr+i)~mod~2^{n}]\)</span>, and the ciphertext is <span class="math inline">\(c_{i}=y_{i}~XOR~m_{i}\)</span>. This encryption does not require <span class="math inline">\(F\)</span> to be invertible, or even a permutation. Also, the encryption and decryptinon can be fully parallelized. If <span class="math inline">\(F\)</span> is a pseudorandom function, then CTR-mode encryption is CPA-secure.</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000800.png" alt="image-20201019213705204" style="zoom:50%;" /></p>
<h1 id="chosen-ciphertext-attacks">Chosen-Ciphertext Attacks</h1>
<h2 id="cca-security">CCA-security</h2>
<p>In a chosen-ciphertext attack, the adversary has the ability to obtain not only the encryptions of messages of its choice, but also the decryption of ciphertexts of its choice.</p>
<p><strong>The CCA indistinguishability experiment</strong> <span class="math inline">\(PrivK_{\mathcal{A},\pi}^{cca}(n)\)</span>:</p>
<ul>
<li>A key <span class="math inline">\(k\)</span> is generated by running <span class="math inline">\(Gen(1^n)\)</span>.</li>
<li>Adversary <span class="math inline">\(\mathcal{A}\)</span> is given input <span class="math inline">\(1^n\)</span> and oracle access to <span class="math inline">\(Enc_{k}(\cdot)\)</span> and <span class="math inline">\(Dec_{k}(\cdot)\)</span>. It outputs a pair of messages <span class="math inline">\(m_{0},m_{1}\)</span> of the same length.</li>
<li>A uniform bit <span class="math inline">\(b\in \{0,1\}\)</span> is chosen, and then a ciphertext <span class="math inline">\(c\leftarrow Enc_{k}(m_{b})\)</span> is computed and given to <span class="math inline">\(\mathcal{A}\)</span>. We call <span class="math inline">\(c\)</span> the challenge ciphertext.</li>
<li>The adversary <span class="math inline">\(\mathcal{A}\)</span> continues to have oracle access to <span class="math inline">\(Enc_{k}(\cdot)\)</span> and <span class="math inline">\(Dec_{k}(\cdot)\)</span>, but is not allowed to query the latter on the challenge ciphertext itself. Eventually, <span class="math inline">\(\mathcal{A}\)</span> outputs a bit <span class="math inline">\(b&#39;\)</span>.</li>
<li>The output of the experiment is defined to be 1 if <span class="math inline">\(b&#39;=b\)</span> and 0 otherwise. If the output of the experiment is 1, we say that <span class="math inline">\(\mathcal{A}\)</span> succeeds.</li>
</ul>
<p>A private-key encryption scheme <span class="math inline">\(\Pi\)</span> has indistinguishable encryptions under a chosen-ciphertext attack, or is CCA-secure, if for all probabilistic polynomial-time adversaries <span class="math inline">\(\mathcal{A}\)</span> there is a negligible function <span class="math inline">\(negl\)</span> such that: <span class="math display">\[
Pr[PrivK_{\cal{A},\pi}^{cca}(n)=1]\le \frac{1}{2}+negl(n)
\]</span> And any private-key encryption scheme that is CCA-secure is also CCA-secure for multiple encryptions.</p>
<p><em>Any encryption scheme that allows ciphertexts to be "manipulated" in any controlled way cannot be CCA-secure</em>. So all the encryption scheme above is <strong>not CCA-secure</strong>!</p>
<p>CCA-secure encryption requires an important property called <strong>non-malleability</strong>: if the adversary tries to modify a given ciphertext, the result is either an invalid ciphertext or one that decrypts to a plaintext having no relation to the original one (message authentication).</p>
<h1 id="practical-applications">Practical applications</h1>
<h2 id="stream-cipher">Stream cipher</h2>
<h3 id="linear-feedback-shift-registers">Linear-feedback Shift Registers</h3>
<p>A Linear-feedback Shift Registers(LFSR) consists of an array of <span class="math inline">\(n\)</span> registers <span class="math inline">\(s_{n-1},\dots,s_0\)</span> along with a feedback loop specified by a set of <span class="math inline">\(n\)</span> feedback coefficients <span class="math inline">\(c_{n-1},\dots,c_0\)</span>. The size of the array is called the degree of LFSR.</p>
<figure>
<img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000809.png" alt="image-20201019214218689" /><figcaption aria-hidden="true">image-20201019214218689</figcaption>
</figure>
<p>Each register stores a single bit, and the state <span class="math inline">\(st\)</span> of the LFSR at any point in time is simply the set of bits contained in the registers. The state of the LFSR is updated in each of a series of “clock ticks” by shifting the values in all the registers to the right, and setting the new value of the left-most register equal to the XOR of some subset of the current registers, with the subset determined by the feedback coefficients.</p>
<p>Say the state at some time <span class="math inline">\(t\)</span> is <span class="math inline">\(s_{n-1}^{(t)},\dots,s_{0}^{(t)}\)</span>, then the state after the next clock tick is <span class="math inline">\(s_{n-1}^{(t+1)},\dots,s_{0}^{(t+1)}\)</span> with <span class="math display">\[
s_{i}^{(t+1)}:=s_{i+1}^{(t)},~i=0,\dots,n-2
\]</span> <span class="math display">\[
s_{n-1}^{(t+1)}:=\oplus_{i=0}^{n-1}c_{i}s_{i}^{(t)}
\]</span> And the LFSR outputs the value of the right-most register <span class="math inline">\(s_{0}^{(t)}\)</span>.</p>
<p>The state of the LFSR consists of <span class="math inline">\(n\)</span> bits, thus it can cycle through at most <span class="math inline">\(2^n\)</span> possible states. Because the all-0 state will make LFSR remains in that state forever, a maximum-length LFSR cycles through all <span class="math inline">\(2^n-1\)</span> nonzero states before repeating.</p>
<p>The output of a maximal-length LFSR of degree <span class="math inline">\(n\)</span> has good statistical properties. Nevertheless, it is not good pseudoramdon generators for cryptographic purposes because of the predictibility of their output. The attacker can reconstruct the entire state after observing at most <span class="math inline">\(2n\)</span> output bits using the following linear equations: <span class="math display">\[
\begin{align}
    y_{n+1}=&amp; c_{n-1}y_{n}\oplus\cdots\oplus c_{0}y_{1} \\
    \cdot&amp; \\
    \cdot&amp; \\
    \cdot&amp; \\
    y_{2n}=&amp; c_{n-1}y_{2n-1}\oplus\cdots\oplus c_{0}y_{n}
\end{align}
\]</span></p>
<p>To thwart reconstruction attacks, the system must introduce some nonlinearity. E.g. add nonlinearity for the left-most register or in the output sequence.</p>
<p>LFSRs are efficient when implemented in hardware, but have poor performance in software.</p>
<h3 id="trivium">Trivium</h3>
<p>Trivium uses three coupled, nonlinear FSRs denoted by A, B, and C and having degree 93, 84, and 111, respectively.</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000823.png" alt="image-20201019214427187" style="zoom: 50%;" /></p>
<p>The <span class="math inline">\(GetBits\)</span> algorithm for Trivium works as follows: At each clock tick, the output of each FSR is the XOR of its right-most register and one additional register; the output of Trivium is the XOR of the output bits of the three FSRs.</p>
<p>The <span class="math inline">\(Init\)</span> algorithm of Trivium accepts an 80-bit key and an 80-bit IV . The key is loaded into the 80 left-most registers of A, and the IV is loaded into the 80 left-most registers of B. The remaining registers are set to 0, except for the three right-most registers of C, which are set to 1. Then <span class="math inline">\(GetBits\)</span> is run <span class="math inline">\(4·288\)</span> times (with output discarded), and the resulting state is taken as <span class="math inline">\(st_0\)</span>.</p>
<p>To date, no cryptanalytic attacks better than exhaustive key search are known against the full Trivium cipher.</p>
<h3 id="rc4">RC4</h3>
<p>RC4 is remarkable for its speed and simplicity. Although it is widely used today, but recent attacks have shown serious cryptographic weaknesses in RC4 so it should no longer be used.</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000836.png" alt="image-20201019214555086" style="zoom: 33%;" /></p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000850.png" alt="image-20201019214646690" style="zoom:33%;" /></p>
<h2 id="block-cipher-1">Block cipher</h2>
<h3 id="des-encryption-scheme">DES encryption scheme</h3>
<h4 id="feistel-networks">Feistel networks</h4>
<p>Feistel networks offer an approach for constructing block ciphers. An advantage of Feistel networks over substitution-permutation networks is that the underlying functions used in a Feistel network need not be invertible.</p>
<p>In the <span class="math inline">\(i\)</span>th round of a Feistel network, the input is divided into two halves <span class="math inline">\(L_{i-1}\)</span> and <span class="math inline">\(R_{i-1}\)</span> with equal length <span class="math inline">\(\ell/2\)</span>. The output <span class="math inline">\((L_{i},R_{i})\)</span> of the round is <span class="math inline">\(L_{i}:=R_{i-1}\)</span> and <span class="math inline">\(R_{i}:=L_{i-1}\oplus f_{i}(R_{i-1})\)</span>, with <span class="math inline">\(f_{i}(R)=\hat{f}_{i}(k_{i},R)\)</span> and <span class="math inline">\(k_i\)</span> is the sub-key in the <span class="math inline">\(i\)</span>th round.</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000857.png" alt="image-20201019214742849" style="zoom:67%;" /></p>
<p>A Feistel network is invertible regardless of the <span class="math inline">\(\{f_i\}\)</span>. Given the output <span class="math inline">\((L_i,R_i)\)</span> of the <span class="math inline">\(i\)</span>th round, we can compute <span class="math inline">\((L_{i-1},R_{i-1})\)</span> as follows: first set <span class="math inline">\(R_{i-1}:= L_i\)</span>, Then compute <span class="math inline">\(L_{i-1}:=R_{i}\oplus f_{i}(R_{i-1})\)</span>.</p>
<h4 id="des">DES</h4>
<p>The DES block cipher is a 16-round Feistel network with a block length of 64 bits and a key length of 56 bits. The same round function <span class="math inline">\(\hat{f}\)</span> is used in each of the 16 rounds. The round function takes a 48-bit sub-key and a 32-bit input.</p>
<p>The key schedule of DES is used to derive a sequence of 48-bit sub-keys <span class="math inline">\(k_{1},\dots,k_{16}\)</span> from the 56-bit master key, with each sub-key <span class="math inline">\(k_{i}\)</span> being a permuted subset of 48 bits of the master key.</p>
<p>The DES round function <span class="math inline">\(\hat{f}\)</span> (or the DES mangler function) is constructed as the following figure:</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000906.png" alt="image-20201019215049875" style="zoom:50%;" /></p>
<p><span class="math inline">\(E\)</span> is called the expansion function, which works by simply duplicating half the bits of <span class="math inline">\(R\)</span> (according to a fixed rule). Each S-box maps a 6-bit input to a 4-bit output. Changing one bit of any input to an S-box always changes at least two bits of the output, so the DES exhibits a strong avalanche effect.</p>
<p>Unfortunately, the 56-bit key length of DES is short enough that an exhaustive search through all <span class="math inline">\(2^{56}\)</span> possible keys is now feasible. Using differential cryptoanalysis make the time to decrypt becomes much shorter.</p>
<p><strong>3DES</strong>: Triple-DES (or 3DES) is based on a triple invocation of DES using two or three keys. There are two variants:</p>
<ul>
<li><em>three keys</em>: Choose three independent keys and define <span class="math inline">\(F_{k_{1},k_{2},k_{3}}^{&#39;&#39;}(x)=F_{k_{3}}(F_{k_2}^{-1}(F_{k_1}(x)))\)</span>.</li>
<li><em>two keys</em>: Choose two independent keys and define <span class="math inline">\(F_{k_{1},k_{2}}^{&#39;&#39;}(x)=F_{k_{1}}(F_{k_2}^{-1}(F_{k_1}(x)))\)</span> .</li>
</ul>
<p>The security of the two variants is both <span class="math inline">\(2^{2n}\)</span>, since the three keys encryption is susceptible to a meet-in-the-middle attack. 3DES is relatively slow and the key length is short, so it is recommended to use AES instead.</p>
<p>For the details of DES encryption scheme, refer to:</p>
<ul>
<li>https://blog.csdn.net/baidu_36856113/article/details/53558795</li>
<li>Understanding Cryptography: A Textbook for Students and Practitioners. Chapter 3</li>
</ul>
<h3 id="aes-encryption-scheme">AES encryption scheme</h3>
<h4 id="substitution-permutation-networks">Substitution-permutation networks</h4>
<p>A SPN can be viewed as a direct implementation of the confusion-diffusion paradigm. Define <span class="math inline">\(S\)</span> as a fixed public substitution function. The cipher proceeds in a series of rounds, where in each round we apply the following sequence of operations to the n-bit input <span class="math inline">\(x\)</span> of that round.</p>
<ol type="1">
<li><em>Key mixing</em>: Set <span class="math inline">\(x:=x\oplus k\)</span>, where <span class="math inline">\(k\)</span> is the current-round sub-key;</li>
<li><em>Substitution</em>: Set <span class="math inline">\(x:=S_{1}(x_{1})||\cdots||S_{n}(x_{n})\)</span>, where <span class="math inline">\(x_i\)</span> is the ith byte of <span class="math inline">\(x\)</span>;</li>
<li><em>Permutation</em>: Permute the bits of <span class="math inline">\(x\)</span> to obtain the output of the round.</li>
</ol>
<p>The following figure is a simple example of substitution-permutation network with a 16-bit block length and 4-bit S-boxes:</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201105000929.png" alt="image-20201019215321463" style="zoom:50%;" /></p>
<p><strong>The avalanche effect</strong>: a small change in the input must “affect” every bit of the output in any block cipher. In substitution-permutation network, the avalanche effect is ensured by the following two properties:</p>
<ul>
<li><p>changing a single bit of the input to an S-box changes at least two bits in the output of the S-box;</p></li>
<li><p>the mixing permutations makes the output bits of any given S-box are used as input to multiple S-boxes in the next round.</p></li>
</ul>
<h4 id="aes">AES</h4>
<p>AES is essentially a substitution-permutation network. During computation of the AES algorithm, a 4-by-4 array of bytes called the state is modified in a series of rounds. The state is initially set equal to the input to the cipher(i.e., the block size is 128 bit). The following operations are then applied to the state in a series of four stages during each round:</p>
<ol type="1">
<li><p><strong>AddRoundKey</strong>: In every round of AES, a 128-bit sub-key is derived from the master key, and is interpreted as a 4-by-4 array of bytes. The state array is updated by XORing it with this sub-key.</p></li>
<li><p><strong>SubBytes</strong>: each byte of the state array is replaced by another byte according to a single fixed lookup table S. This substitution table (or S-box) is a bijection over <span class="math inline">\(\{0, 1\}^8\)</span>.</p></li>
<li><p><strong>ShiftRows</strong>: the bytes in each row of the state array are shifted to the left as follows: the first row of the array is untouched, the second, third and fourth row is shifted to the left by one place, two places and three places, respectively. All shifts are cyclic.</p></li>
<li><p><strong>MixColumns</strong>: an invertible transformation is applied to the four bytes in each column (i.e., a linear transformation over <span class="math inline">\(GF(2^8)\)</span>).</p>
<p>In the final round, MixColumns is replaced with AddRoundKey.</p></li>
</ol>
<p>The number of rounds depends on the key length. Ten rounds are used for a 128-bit key, 12 rounds for a 192-bit key, and 14 rounds for a 256-bit key.</p>
<p>AES encryption is free, standardized, efficient, and highly secure. To date, there are no practical cryptanalytic attacks that are significantly better than an exhaustive search for the key.</p>
<p>For the details of AES encryption scheme, refer to:</p>
<ul>
<li>https://blog.csdn.net/qq_38289815/article/details/80900813</li>
<li>https://blog.csdn.net/weixin_40876133/article/details/82797732</li>
<li>Understanding Cryptography: A Textbook for Students and Practitioners. Chapter 4</li>
</ul>
<h1 id="references">References</h1>
<ol type="1">
<li>Introduction to Modern Cryptography, Second Edition.</li>
<li>Understanding Cryptography: A Textbook for Students and Practitioners (Chinese Version).</li>
</ol>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Yufei Luo
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://lyf35.github.io/2020/07/30/%E5%AF%86%E7%A0%81%E5%AD%A6-%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/" title="密码学-私钥加密">http://lyf35.github.io/2020/07/30/密码学-私钥加密/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/" rel="tag"><i class="fa fa-tag"></i> 信息安全</a>
              <a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" rel="tag"><i class="fa fa-tag"></i> 密码学</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> 计算机基础</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/25/%E5%AF%86%E7%A0%81%E5%AD%A6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="prev" title="密码学-基础知识">
      <i class="fa fa-chevron-left"></i> 密码学-基础知识
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/05/%E5%AF%86%E7%A0%81%E5%AD%A6-%E6%B6%88%E6%81%AF%E9%AA%8C%E8%AF%81%E7%A0%81/" rel="next" title="密码学-消息验证码">
      密码学-消息验证码 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yufei Luo</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">22:56</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动
  </div>

        






<script data-pjax>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"ypNNXSdcGIIoldC5BBmViS2g-gzGzoHsz","app_key":"0TDwohU7eO4yHTn4tley8PtE","server_url":"https://leancloud.cn/dashboard/data.html?appid=ypNNXSdcGIIoldC5BBmViS2g-gzGzoHsz#/","security":false};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="//cdn.jsdelivr.net/npm/ribbon.js@1/dist/ribbon.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/next-theme/pjax@0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  
  <script data-pjax>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>









<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>


    <div class="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      const script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4dcdc02d24075b0e9d3a',
      clientSecret: '53cf2cb8b89b9d4bba922bb19bda1290f0d0bf95',
      repo        : 'lyf35.github.io',
      owner       : 'lyf35',
      admin       : ['lyf35'],
      id          : '18066b9f865bfb3b5ec36191b241c3b5',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
