<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">
  <link rel="manifest" href="/images/site.webmanifest">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Helvetica:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-flat-top.min.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lyf35.github.io","root":"/","scheme":"Pisces","version":"8.0.0-rc.5","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="简介  网络层服务  分组 网络层的首要责任就是分组。源主机从上层协议接收分组，加入一个头部，头部包含了源和目的地址以及其他网络层协议所需要的信息，并将其传给数据链路层。源端不可改变负载内容，除非负载过大不能传递才需要分段。 目的主机从数据链路层接收网络层分组，解封分组并将负载传递到相应的上层协议。如果分组在源端或在沿途的路由器被分段，那么网络层负责等待，直到所有的分组都到达，它同时负责重组分组">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络-网络层">
<meta property="og:url" content="http://lyf35.github.io/2020/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/index.html">
<meta property="og:site_name" content="Yufei Luo&#39;s Blog">
<meta property="og:description" content="简介  网络层服务  分组 网络层的首要责任就是分组。源主机从上层协议接收分组，加入一个头部，头部包含了源和目的地址以及其他网络层协议所需要的信息，并将其传给数据链路层。源端不可改变负载内容，除非负载过大不能传递才需要分段。 目的主机从数据链路层接收网络层分组，解封分组并将负载传递到相应的上层协议。如果分组在源端或在沿途的路由器被分段，那么网络层负责等待，直到所有的分组都到达，它同时负责重组分组">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132016.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132021.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132034.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132044.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132113.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132122.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132130.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132137.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132244.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132236.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132205.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132205.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132213.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132220.png">
<meta property="article:published_time" content="2020-11-15T14:55:30.000Z">
<meta property="article:modified_time" content="2021-01-09T11:18:37.000Z">
<meta property="article:author" content="Yufei Luo">
<meta property="article:tag" content="计算机基础">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132016.png">

<link rel="canonical" href="http://lyf35.github.io/2020/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机网络-网络层 | Yufei Luo's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
 <!--   <div class="headband"></div>-->

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Yufei Luo's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">But I was so much older then, I am younger than that now.</p>
      <img class="custom-logo-image" src="/images/logo.png" alt="Yufei Luo's Blog">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-计算机基础">

    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80" rel="section"><i class="fa fa-tags fa-fw"></i>计算机基础</a>

  </li>
        <li class="menu-item menu-item-机器学习">

    <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0" rel="section"><i class="fa fa-tags fa-fw"></i>机器学习</a>

  </li>
        <li class="menu-item menu-item-深度学习">

    <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0" rel="section"><i class="fa fa-tags fa-fw"></i>深度学习</a>

  </li>
        <li class="menu-item menu-item-工程实践">

    <a href="/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5" rel="section"><i class="fa fa-tags fa-fw"></i>工程实践</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text"> 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.1.</span> <span class="nav-text"> 网络层服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%BB%84"><span class="nav-number">1.1.1.</span> <span class="nav-text"> 分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1"><span class="nav-number">1.1.2.</span> <span class="nav-text"> 路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E5%8F%91"><span class="nav-number">1.1.3.</span> <span class="nav-text"> 转发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">1.1.4.</span> <span class="nav-text"> 拥塞控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2"><span class="nav-number">1.2.</span> <span class="nav-text"> 分组交换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.1.</span> <span class="nav-text"> 数据报方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E7%94%B5%E8%B7%AF%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.2.</span> <span class="nav-text"> 虚电路方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E6%80%A7%E8%83%BD"><span class="nav-number">1.3.</span> <span class="nav-text"> 网络层性能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F"><span class="nav-number">1.3.1.</span> <span class="nav-text"> 延迟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-number">1.3.2.</span> <span class="nav-text"> 吞吐量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E4%B8%A2%E5%A4%B1"><span class="nav-number">1.3.3.</span> <span class="nav-text"> 分组丢失</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8B%A5%E5%A1%9E"><span class="nav-number">1.4.</span> <span class="nav-text"> 网络层拥塞</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.4.1.</span> <span class="nav-text"> 原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6-2"><span class="nav-number">1.4.2.</span> <span class="nav-text"> 拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E7%8E%AF%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">1.4.2.1.</span> <span class="nav-text"> 开环拥塞控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AD%E7%8E%AF%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">1.4.2.2.</span> <span class="nav-text"> 闭环拥塞控制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.</span> <span class="nav-text"> 路由器的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E4%BB%B6"><span class="nav-number">1.5.1.</span> <span class="nav-text"> 元件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%89%88%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.</span> <span class="nav-text"> 第四版网络层协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ipv4"><span class="nav-number">2.2.</span> <span class="nav-text"> IPv4</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="nav-number">2.2.1.</span> <span class="nav-text"> 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.2.2.</span> <span class="nav-text"> 数据报格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%AE%B5"><span class="nav-number">2.2.3.</span> <span class="nav-text"> 分段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="nav-number">2.2.3.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8E%E5%88%86%E6%AE%B5%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="nav-number">2.2.3.2.</span> <span class="nav-text"> 与分段相关的字段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%AE%89%E5%85%A8"><span class="nav-number">2.2.4.</span> <span class="nav-text"> 数据报安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ipv4%E5%9C%B0%E5%9D%80"><span class="nav-number">2.2.5.</span> <span class="nav-text"> IPv4地址</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="nav-number">2.2.5.1.</span> <span class="nav-text"> 简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">2.2.5.2.</span> <span class="nav-text"> 地址空间</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E6%B3%95"><span class="nav-number">2.2.5.2.1.</span> <span class="nav-text"> 标记法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.5.2.2.</span> <span class="nav-text"> 地址层次结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%B1%BB%E5%AF%BB%E5%9D%80"><span class="nav-number">2.2.5.3.</span> <span class="nav-text"> 分类寻址</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.5.3.1.</span> <span class="nav-text"> 地址类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%80%97%E5%B0%BD"><span class="nav-number">2.2.5.3.2.</span> <span class="nav-text"> 地址耗尽</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%90%E7%BD%91%E5%8C%96%E5%92%8C%E8%B6%85%E7%BD%91%E5%8C%96"><span class="nav-number">2.2.5.3.3.</span> <span class="nav-text"> 子网化和超网化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E7%B1%BB%E5%AF%BB%E5%9D%80"><span class="nav-number">2.2.5.4.</span> <span class="nav-text"> 无类寻址</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.5.4.1.</span> <span class="nav-text"> 方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E9%95%BF%E5%BA%A6"><span class="nav-number">2.2.5.4.2.</span> <span class="nav-text"> 前缀长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E%E5%9C%B0%E5%9D%80%E4%B8%AD%E6%8A%BD%E5%8F%96%E4%BF%A1%E6%81%AF"><span class="nav-number">2.2.5.4.3.</span> <span class="nav-text"> 从地址中抽取信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9D%97%E5%88%86%E9%85%8D%E4%B8%8E%E5%AD%90%E7%BD%91"><span class="nav-number">2.2.5.4.4.</span> <span class="nav-text"> 块分配与子网</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E5%9C%B0%E5%9D%80"><span class="nav-number">2.2.5.5.</span> <span class="nav-text"> 特殊地址</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AEdhcp"><span class="nav-number">2.3.</span> <span class="nav-text"> 动态主机配置协议（DHCP）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-4"><span class="nav-number">2.3.1.</span> <span class="nav-text"> 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.3.2.</span> <span class="nav-text"> 报文格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dhcp%E8%BF%90%E8%A1%8C"><span class="nav-number">2.3.3.</span> <span class="nav-text"> DHCP运行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2nat"><span class="nav-number">2.4.</span> <span class="nav-text"> 网络地址转换（NAT）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-number">2.4.1.</span> <span class="nav-text"> 作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.4.2.</span> <span class="nav-text"> 地址转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ip%E5%88%86%E7%BB%84%E7%9A%84%E8%BD%AC%E5%8F%91"><span class="nav-number">2.5.</span> <span class="nav-text"> IP分组的转发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E5%8F%91"><span class="nav-number">2.5.1.</span> <span class="nav-text"> 基于目的地址的转发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">2.5.1.1.</span> <span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%81%9A%E5%90%88"><span class="nav-number">2.5.1.2.</span> <span class="nav-text"> 地址聚合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E6%8E%A9%E7%A0%81%E5%8C%B9%E9%85%8D"><span class="nav-number">2.5.1.3.</span> <span class="nav-text"> 最长掩码匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B1%82%E8%B7%AF%E7%94%B1%E4%B8%8E%E5%9C%B0%E7%90%86%E8%B7%AF%E7%94%B1"><span class="nav-number">2.5.1.4.</span> <span class="nav-text"> 分层路由与地理路由</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%A0%87%E7%AD%BE%E7%9A%84%E8%BD%AC%E5%8F%91"><span class="nav-number">2.5.2.</span> <span class="nav-text"> 基于标签的转发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-2"><span class="nav-number">2.5.2.1.</span> <span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E5%8D%8F%E8%AE%AE%E6%A0%87%E8%AE%B0%E4%BA%A4%E6%8D%A2"><span class="nav-number">2.5.2.2.</span> <span class="nav-text"> 多协议标记交换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#icmpv4"><span class="nav-number">2.6.</span> <span class="nav-text"> ICMPv4</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8-2"><span class="nav-number">2.6.1.</span> <span class="nav-text"> 作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%A5%E6%96%87"><span class="nav-number">2.6.2.</span> <span class="nav-text"> 报文</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F-2"><span class="nav-number">2.6.2.1.</span> <span class="nav-text"> 报文格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%AE%E9%94%99%E6%8A%A5%E5%91%8A%E6%8A%A5%E6%96%87"><span class="nav-number">2.6.2.2.</span> <span class="nav-text"> 差错报告报文</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%8A%A5%E6%96%87"><span class="nav-number">2.6.2.3.</span> <span class="nav-text"> 查询报文</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E6%92%AD%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9"><span class="nav-number">3.</span> <span class="nav-text"> 单播路由选择</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E6%83%B3%E4%BB%A5%E5%9B%BE%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%9B%A0%E7%89%B9%E7%BD%91"><span class="nav-number">3.1.</span> <span class="nav-text"> 思想：以图的形式表示因特网</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text"> 路由选择算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9"><span class="nav-number">3.2.1.</span> <span class="nav-text"> 距离向量路由选择</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E6%81%AF%E4%BA%A4%E6%8D%A2"><span class="nav-number">3.2.1.1.</span> <span class="nav-text"> 信息交换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bellman-ford%E6%96%B9%E7%A8%8B"><span class="nav-number">3.2.1.2.</span> <span class="nav-text"> Bellman-Ford方程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F"><span class="nav-number">3.2.1.3.</span> <span class="nav-text"> 距离向量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9"><span class="nav-number">3.2.2.</span> <span class="nav-text"> 链路状态路由选择</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">3.2.2.1.</span> <span class="nav-text"> 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">3.2.2.2.</span> <span class="nav-text"> 链路状态数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%E6%A0%91%E7%9A%84%E5%BD%A2%E6%88%90"><span class="nav-number">3.2.2.3.</span> <span class="nav-text"> 最小代价树的形成</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9"><span class="nav-number">3.2.3.</span> <span class="nav-text"> 路径向量路由选择</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87"><span class="nav-number">3.2.3.1.</span> <span class="nav-text"> 目标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">3.2.3.2.</span> <span class="nav-text"> 生成树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E5%90%91%E9%87%8F%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.3.3.</span> <span class="nav-text"> 路径向量算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E6%92%AD%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.3.</span> <span class="nav-text"> 单播路由选择协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E4%BF%A1%E6%81%AF%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.3.1.</span> <span class="nav-text"> 路由选择信息协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="nav-number">3.3.1.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E6%95%B0"><span class="nav-number">3.3.1.2.</span> <span class="nav-text"> 跳数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E5%8F%91%E8%A1%A8"><span class="nav-number">3.3.1.3.</span> <span class="nav-text"> 转发表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rip%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.1.4.</span> <span class="nav-text"> RIP实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.3.1.4.1.</span> <span class="nav-text"> 应用层程序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#rip%E6%8A%A5%E6%96%87"><span class="nav-number">3.3.1.4.2.</span> <span class="nav-text"> RIP报文</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#rip%E7%AE%97%E6%B3%95"><span class="nav-number">3.3.1.4.3.</span> <span class="nav-text"> RIP算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#rip%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="nav-number">3.3.1.4.4.</span> <span class="nav-text"> RIP计时器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rip%E6%80%A7%E8%83%BD"><span class="nav-number">3.3.1.5.</span> <span class="nav-text"> RIP性能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E6%94%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%BC%98%E5%85%88"><span class="nav-number">3.3.2.</span> <span class="nav-text"> 开放最短路径优先</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="nav-number">3.3.2.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%A6%E9%87%8F"><span class="nav-number">3.3.2.2.</span> <span class="nav-text"> 度量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E5%8F%91%E8%A1%A8-2"><span class="nav-number">3.3.2.3.</span> <span class="nav-text"> 转发表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E5%9F%9F"><span class="nav-number">3.3.2.4.</span> <span class="nav-text"> 区域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E9%80%9A%E5%91%8A"><span class="nav-number">3.3.2.5.</span> <span class="nav-text"> 链路状态通告</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ospf%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.2.6.</span> <span class="nav-text"> OSPF实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-5"><span class="nav-number">3.3.2.6.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ospf%E6%8A%A5%E6%96%87"><span class="nav-number">3.3.2.6.2.</span> <span class="nav-text"> OSPF报文</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%89%B4%E5%AE%9A"><span class="nav-number">3.3.2.6.3.</span> <span class="nav-text"> 鉴定</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ospf%E7%AE%97%E6%B3%95"><span class="nav-number">3.3.2.6.4.</span> <span class="nav-text"> OSPF算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%A7%E8%83%BD"><span class="nav-number">3.3.2.6.5.</span> <span class="nav-text"> 性能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE%E7%AC%AC%E5%9B%9B%E7%89%88"><span class="nav-number">3.3.3.</span> <span class="nav-text"> 边界网关协议第四版</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.3.3.1.</span> <span class="nav-text"> 介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%96%E9%83%A8bgp"><span class="nav-number">3.3.3.1.1.</span> <span class="nav-text"> 外部BGP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E9%83%A8bgp"><span class="nav-number">3.3.3.1.2.</span> <span class="nav-text"> 内部BGP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%9F%E5%86%85%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E4%BF%A1%E6%81%AF%E6%8F%92%E5%85%A5"><span class="nav-number">3.3.3.1.3.</span> <span class="nav-text"> 域内路由选择信息插入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%81%9A%E5%90%88-2"><span class="nav-number">3.3.3.1.4.</span> <span class="nav-text"> 地址聚合</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7"><span class="nav-number">3.3.3.2.</span> <span class="nav-text"> 路径属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9"><span class="nav-number">3.3.3.3.</span> <span class="nav-text"> 路由选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%A5%E6%96%87-2"><span class="nav-number">3.3.3.4.</span> <span class="nav-text"> 报文</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%83%BD-2"><span class="nav-number">3.3.3.5.</span> <span class="nav-text"> 性能</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E6%92%AD%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9"><span class="nav-number">4.</span> <span class="nav-text"> 多播路由选择</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="nav-number">4.1.</span> <span class="nav-text"> 介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E6%92%AD"><span class="nav-number">4.1.1.</span> <span class="nav-text"> 单播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%92%AD"><span class="nav-number">4.1.2.</span> <span class="nav-text"> 多播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E6%92%AD"><span class="nav-number">4.1.3.</span> <span class="nav-text"> 广播</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%92%AD%E5%9C%B0%E5%9D%80"><span class="nav-number">4.2.</span> <span class="nav-text"> 多播地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%A0%E7%89%B9%E7%BD%91%E7%BB%84%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.3.</span> <span class="nav-text"> 因特网组管理协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%92%AD%E8%BD%AC%E5%8F%91"><span class="nav-number">4.4.</span> <span class="nav-text"> 多播转发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E5%8D%95%E6%92%AD%E8%BD%AC%E5%8F%91%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-number">4.4.1.</span> <span class="nav-text"> 与单播转发的不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%BA%90%E6%A0%91%E6%96%B9%E6%B3%95"><span class="nav-number">4.4.2.</span> <span class="nav-text"> 基于源树方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%85%B1%E4%BA%AB%E6%A0%91%E6%96%B9%E6%B3%95"><span class="nav-number">4.4.3.</span> <span class="nav-text"> 组共享树方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%9F%E5%86%85%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.5.</span> <span class="nav-text"> 域内路由选择协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%92%AD%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F"><span class="nav-number">4.5.1.</span> <span class="nav-text"> 多播距离向量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%92%AD%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81"><span class="nav-number">4.5.2.</span> <span class="nav-text"> 多播链路状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E7%8B%AC%E7%AB%8B%E5%A4%9A%E6%92%AD"><span class="nav-number">4.5.3.</span> <span class="nav-text"> 协议独立多播</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.6.</span> <span class="nav-text"> 域间路由选择协议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8B%E4%B8%80%E4%BB%A3ip"><span class="nav-number">5.</span> <span class="nav-text"> 下一代IP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-5"><span class="nav-number">5.1.</span> <span class="nav-text"> 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E6%A0%BC%E5%BC%8F"><span class="nav-number">5.2.</span> <span class="nav-text"> 分组格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ipv6%E5%AF%BB%E5%9D%80"><span class="nav-number">5.3.</span> <span class="nav-text"> IPv6寻址</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E6%A0%BC%E5%BC%8F"><span class="nav-number">5.3.1.</span> <span class="nav-text"> 地址格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E7%B1%BB%E5%9E%8B-2"><span class="nav-number">5.3.2.</span> <span class="nav-text"> 地址类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D"><span class="nav-number">5.3.3.</span> <span class="nav-text"> 地址空间分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E5%9C%B0%E5%9D%80-2"><span class="nav-number">5.3.4.</span> <span class="nav-text"> 特殊地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ipv4%E5%88%B0ipv6%E7%9A%84%E8%BF%87%E6%B8%A1"><span class="nav-number">5.4.</span> <span class="nav-text"> IPv4到IPv6的过渡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#icmpv6"><span class="nav-number">5.5.</span> <span class="nav-text"> ICMPv6</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">6.</span> <span class="nav-text"> 参考</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yufei Luo"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Yufei Luo</p>
  <div class="site-description" itemprop="description">哪怕什么真理无穷，进一寸有进一寸的欢喜</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x5ZjM1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lyf35"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmx5ZjEyMzQwMDAwMDBAMTYzLmNvbQ==" title="E-Mail → mailto:lyf1234000000@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



      </section>
        <div class="back-to-top animated">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x5ZjM1" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lyf35.github.io/2020/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Yufei Luo">
      <meta itemprop="description" content="哪怕什么真理无穷，进一寸有进一寸的欢喜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yufei Luo's Blog">
    </span>

    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络-网络层
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-15 22:55:30" itemprop="dateCreated datePublished" datetime="2020-11-15T22:55:30+08:00">2020-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-09 19:18:37" itemprop="dateModified" datetime="2021-01-09T19:18:37+08:00">2021-01-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">理论知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          
            <span id="/2020/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/" class="post-meta-item leancloud_visitors" data-flag-title="计算机网络-网络层" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<h2 id="网络层服务"><a class="markdownIt-Anchor" href="#网络层服务"></a> 网络层服务</h2>
<h3 id="分组"><a class="markdownIt-Anchor" href="#分组"></a> 分组</h3>
<p>网络层的首要责任就是分组。源主机从上层协议接收分组，加入一个头部，头部包含了源和目的地址以及其他网络层协议所需要的信息，并将其传给数据链路层。源端不可改变负载内容，除非负载过大不能传递才需要分段。</p>
<p>目的主机从数据链路层接收网络层分组，解封分组并将负载传递到相应的上层协议。如果分组在源端或在沿途的路由器被分段，那么网络层负责等待，直到所有的分组都到达，它同时负责重组分组并将其传到上层协议。</p>
<p>在传递路径上的路由器不可以解封它们接收到的分组，除非它们接收到的分组需要分段。同时，路由器仅仅可以检查地址，不允许改变源端和目的端地址。</p>
<a id="more"></a>
<h3 id="路由"><a class="markdownIt-Anchor" href="#路由"></a> 路由</h3>
<p>网络层另一个同等重要的责任是路由。一个物理网络是网络和连接它们的路由器的组合。网络层负责将分组从源端路由传递到目的端，这一过程需要经过多个路由器。网络层负责寻找最佳路由，它是通过运行某些路由协议来帮助路由器协调它们关于邻居的信息，并提出当分组到达时使用的一致性表格。</p>
<h3 id="转发"><a class="markdownIt-Anchor" href="#转发"></a> 转发</h3>
<p>如果路由使用一些策略并运行某些路由协议来为每个路由器创建决策表，那么转发可以定义为当分组到达路由器的一个端口时，路由器所采取的行为。决策表又被称为<em>转发表</em>，路由器通常用它来实施行为。当路由器从它连接的网络接收到另一个分组时，它需要将分组转发到一个或者多个自己所连接的网络上。为了做出决策，路由器使用分组头部的一个信息片段来找到转发表中相应的输出接口号。</p>
<h3 id="拥塞控制"><a class="markdownIt-Anchor" href="#拥塞控制"></a> 拥塞控制</h3>
<p>网络层协议也提供了拥塞控制的功能。</p>
<h2 id="分组交换"><a class="markdownIt-Anchor" href="#分组交换"></a> 分组交换</h2>
<h3 id="数据报方法"><a class="markdownIt-Anchor" href="#数据报方法"></a> 数据报方法</h3>
<p>数据报方法被用于无连接服务的路由分组。当网络层提供无连接服务时，因特网中每一个正在传输的分组都是一个独立的实体，属于同一个报文的多个分组之间没有联系，网络层只负责将分组从源端传递到目的端。</p>
<p>此时，每个分组都是基于其头部的源地址和目的地址信息进行路由的。报文中的分组可能会也可能不会经过同一条通向目的端的路径。</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132016.png" alt="无连接路由转发" /></p>
<h3 id="虚电路方法"><a class="markdownIt-Anchor" href="#虚电路方法"></a> 虚电路方法</h3>
<p>虚电路方法被用于面向连接服务的路由分组。此时，属于同一报文的所有分组之间存在联系。在报文中的所有数据被发送之前，应该建立虚连接从而定义数据报的路径。在连接建立之后，数据报可以沿着相同的路径发送。</p>
<p>在这种类型服务中，分组不仅必须包含源和目的地址，也必须包含流标号，这是一个虚电路标识符，它定义了分组应该经过的路径。每个分组基于分组中的标签被转发。</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132021.png" alt="虚电路分组交换" /></p>
<p>为了创建面向连接服务，需要经过如下三个阶段：</p>
<ul>
<li>建立阶段：在这一阶段，路由器为虚电路创建了一个表格项。通过一个路由输出端口的标签与另一个路由输入端口的标签相对应，便在网络中建立了一条虚电路。这是通过请求分组和确认分组这两个辅助分组在发送方和接收方之间交换来完成的。</li>
<li>数据传输阶段：在所有路由器为特定虚电路创建好它们的转发表之后，属于同一个报文的网络层分组可以被一个接着一个地发送。报文中所有的分组都按照相同的标签序列，并且分组有序到达目的端。</li>
<li>拆除阶段：当所有分组全部发送完成之后，发送方发送一个被称为拆除分组的特殊分组，接收方确认分组回复，所有路由器从表格中删除相应的项。</li>
</ul>
<h2 id="网络层性能"><a class="markdownIt-Anchor" href="#网络层性能"></a> 网络层性能</h2>
<h3 id="延迟"><a class="markdownIt-Anchor" href="#延迟"></a> 延迟</h3>
<p>网络中的延迟可以分为如下四种类型：</p>
<ul>
<li>发送延迟：一台源主机或路由器不能立即发送分组，需要将分组中的位一个接一个地发送到线上。从发送第一个位到发送最后一个位所经过的时间即为分组的发送延迟。</li>
<li>传播延迟：指的是传输介质中一个位从A到B点所花费的时间。分组交换网络的传播延迟取决于每个网络的传播延迟，而传播延迟取决于介质的传输速度与链路的距离。</li>
<li>处理延迟：指的是路由器或目的主机从它的输入端接收分组、去除头部、执行差错检测程序并将分组传递到输出端口或将分组传递到上层协议所需要的时间。</li>
<li>排队延迟：指分组在输入和输出队列中的等待时间。</li>
</ul>
<p>因此，总延迟等于发送方到接收方的过程中，这四种延迟时间的总和。</p>
<h3 id="吞吐量"><a class="markdownIt-Anchor" href="#吞吐量"></a> 吞吐量</h3>
<p>网络中任意一点的吞吐量指的是一秒内通过这个点的位的数量，即这一点的数据发送速率。从源到目的端的路径中，一个分组会穿过多条链路，吞吐量取决于这些链路传输速率的最小值。在实际情况中，可能会遇到链路共享的情况，这会导致实际的传输速率要被多个设备平均。</p>
<h3 id="分组丢失"><a class="markdownIt-Anchor" href="#分组丢失"></a> 分组丢失</h3>
<p>当路由器处理一个分组的同时接收到另一个分组，那么接收到的分组就要被存储在缓冲区等待轮次。但是由于缓冲区大小有限，如果缓冲区满则会导致新到来的分组需要被丢弃。这会导致因特网网络层的分组被重发，反过来可能造成溢出并导致更多的分组丢失。</p>
<h2 id="网络层拥塞"><a class="markdownIt-Anchor" href="#网络层拥塞"></a> 网络层拥塞</h2>
<h3 id="原因"><a class="markdownIt-Anchor" href="#原因"></a> 原因</h3>
<p>网络层的拥塞与吞吐量和延迟有关。当网络中的负载大小达到网络容量时，延迟便会急剧增加，因为此时需要考虑到排队延迟。同时，此时也会因为路由器丢弃分组而导致吞吐量急剧下降，而且丢弃分组也不会减少网络中的分组数量（因为源端会重发）。</p>
<h3 id="拥塞控制-2"><a class="markdownIt-Anchor" href="#拥塞控制-2"></a> 拥塞控制</h3>
<h4 id="开环拥塞控制"><a class="markdownIt-Anchor" href="#开环拥塞控制"></a> 开环拥塞控制</h4>
<p>开环拥塞控制指的是在发生拥塞之前，使用某种策略来预防拥塞现象的发生。在这些机制中，源端和目的端都可以处理拥塞控制。常用的策略有：</p>
<ul>
<li>重传策略：一个好的重传策略可以预防拥塞，因此必须优化设计重传策略和重传定时器，使之具有高效率，并用来预防拥塞。</li>
<li>窗口策略：选择性重复窗口要优于回退N帧窗口。在回退N帧窗口时，会重发多个分组，虽然一些分组会安全完整到达接收方，但是这种重复使得拥塞更加严重。而选择性重复窗口只发送那些丢弃或者损坏的特定分组。</li>
<li>确认策略：如果接收方并不对它所接收的每一个分组都进行确认，这会使得发送方放慢发送速度，从而有助于预防拥塞。由于确认也是网络负载的一部分，因此这样也可以减少网络负载。</li>
<li>丢弃策略：一个好的丢弃策略可以预防拥塞，同时不破坏传输完整性。例如音频传输中丢弃不敏感的分组，仍然可以保证声音质量，并且还可以减轻或预防拥塞发生。</li>
<li>许可策略：在允许数据流进入网络之前，与数据流通路相连的交换机首先检查其资源需求，如果网络有拥塞或是可能出现拥塞就拒绝建立虚电路。</li>
</ul>
<h4 id="闭环拥塞控制"><a class="markdownIt-Anchor" href="#闭环拥塞控制"></a> 闭环拥塞控制</h4>
<p>在拥塞发生之后，使用闭环拥塞控制可以缓解拥塞状况。常用的机制有：</p>
<ul>
<li>背压：一个拥塞点停止接收来自直接上行节点或是一些近邻结点的数据，这样就引起上行结点或是近邻结点的拥塞，然后依次拒绝它们的上行或近邻结点的数据，以此类推。背压技术仅适用于虚电路中。</li>
<li>抑制分组：在这种方法中，警告从已经发生拥塞的路由器直接传到源端，但是该分组经过的那些中间结点没有被警告。在这种方法中，一个单独的分组用于实现这一目的。</li>
<li>隐含信令：虽然拥塞结点与源端之间没有通信，但是源端从其它的有关征兆中察觉到网络在某处发生拥塞。例如源端发送多个分组但是暂时没有收到确认，或者接收确认时的延迟现象。</li>
<li>显式指令：发生拥塞的结点直接发送显式指令来通知源端或者目的端发生了拥塞。在这种方法中，信号包含在携带数据的分组中。</li>
</ul>
<h2 id="路由器的结构"><a class="markdownIt-Anchor" href="#路由器的结构"></a> 路由器的结构</h2>
<h3 id="元件"><a class="markdownIt-Anchor" href="#元件"></a> 元件</h3>
<p>路由器大致可以分为四个元件：</p>
<ul>
<li>输入端口：它发挥路由器的物理层和链路层功能。比特位从接收信号中获取，分组从帧中解封、检查差错。如果分组被破坏那么它就会被丢弃。之后，分组准备好被网络层处理。同时，输入端口也有缓冲区队列，用来在分组被发送到交换网络之前存储它们。</li>
<li>发送端口：发送端口与输入端口的功能相同，但是顺序相反。首先输出分组要排队，每个分组被封装进一个帧，并且最终对帧使用物理层功能来创建一个信号发送到线上。</li>
<li>路由处理器：发挥网络层功能。目的地址被用来找到下一条的地址以及输出端口号，同时分组从这个输出端口号发送出去。这个行为有时被称为表格查询。</li>
<li>交换结构：路由器中最复杂的任务就是将分组从输入队列移动到输出队列。这个任务影响输入/输出队列的大小以及分组传递的总延迟。路由器中使用多种不同的交换结构。</li>
</ul>
<h1 id="第四版网络层协议"><a class="markdownIt-Anchor" href="#第四版网络层协议"></a> 第四版网络层协议</h1>
<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>第四版网络层可以被看作是一个主要协议以及三个辅助协议。主要协议指的是因特网协议第四版（IPv4），它负责网络层的分组、转发以及传递；因特网控制报文协议第四版（ICMPv4）帮助IPv4处理一些网络层传递中可能发生的错误；因特网组管理协议（IGMP）用于帮助IPv4多播；在网络层地址映射到链路层地址当中，地址解析协议（ARP）用来将网络和数据链路层联合起来。</p>
<h2 id="ipv4"><a class="markdownIt-Anchor" href="#ipv4"></a> IPv4</h2>
<h3 id="简介-2"><a class="markdownIt-Anchor" href="#简介-2"></a> 简介</h3>
<p>IPv4是一个不可靠且无连接的数据报协议，也就是说它是一个尽力而为的传递服务，因此IPv4分组可能被破坏、丢失、失序到达或延迟，也可能造成网络的拥塞。</p>
<p>IPv4使用数据报的分组交换网的无连接协议。这意味着每个数据报被独立处理，并且每个数据报可以沿着不同路由到达目的端。因此同一个源端发送到同一个目的端的数据报可能会失序到达，某些分组也可能在传输阶段丢失或者被破坏，IPv4依赖于高层协议来处理这些问题。</p>
<h3 id="数据报格式"><a class="markdownIt-Anchor" href="#数据报格式"></a> 数据报格式</h3>
<p>IP使用的分组被称为数据报，它是可变长分组，由头部和数据组成。头部长度在20~60字节，包含有与路由选择和传输相关的重要信息。IP数据报的格式如下图所示：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132034.png" alt="IP数据报" /></p>
<p>其中一些字段的含义如下：</p>
<ul>
<li>版本号（VER）：定义IPv4协议的版本，它的值为4</li>
<li>头部长度（HLEN）：以4字节定义数据报头部的总长度</li>
<li>服务类型：目前这一字段被重定义为提供差分服务</li>
<li>总长：定义了一个以字节计算的IP数据报总长度（头部加上数据）</li>
<li>标识（identification）、标记（flag）和分段偏移：当数据报大于底层网络可以携带的大小时，这三个字段和IP数据报的分段有关</li>
<li>生存时间：用于控制数据报访问的最大跳数（即路由器）。当源主机发送数据报，它在这个字段存储一个数字，每个处理数据报的路由器将此数值减1。如果减1之后字段的值变为0，则路由器丢弃该数据报</li>
<li>协议：分组的数据段称为负载，它从另一个协议中携带整个分组。因特网机构给任何一个使用IP服务的协议一个唯一的8位数字，它被插入到协议字段。在源端IP将负载被封装到数据报时，插入相应的协议号；而数据报到达目的端时，这个字段的值帮助定义负载应该被传到哪个协议。</li>
<li>头部校验和：使用这一字段来检查头部是否被破坏。它需要在每个路由器重新计算。</li>
<li>源和目的地址：定义源端和目的端的IP地址</li>
<li>选项：用于进行网络测试和调试</li>
<li>负载：使用IP服务的其他协议的分组</li>
</ul>
<h3 id="分段"><a class="markdownIt-Anchor" href="#分段"></a> 分段</h3>
<h4 id="概述-2"><a class="markdownIt-Anchor" href="#概述-2"></a> 概述</h4>
<p>一个数据报可以通过几个不同的网络进行传输，每一个路由器将它所接收的帧拆封成IP数据报，对它进行处理，然后再封装成另一个帧。接收到的帧的格式和长度取决于此帧刚刚经过的物理网络所使用的协议。被发送帧的格式和长度取决于此帧将要经过的物理网络所使用的协议。</p>
<p>每一个数据链路层协议都有自己的帧格式，每种格式的特征之一就是可以封装的负载的最大长度。最大传输单元（Maximum Transfer Unit, MTU）的值随着物理网络协议的不同而不同。</p>
<p>为了使得IP协议独立于物理网络，IP数据报的最大长度被限制为65536字节。对于一些MTU小于这个值的物理网络，就需要将数据报进行分割，使其能够通过这些网络，这一过程就称为分段。如果一个分段的数据报遇到MTU更小的网络，它有可能再次被分段。</p>
<p>一个数据报可能被源主机或路径上的任意路由器分段，但是数据报的重组只能在目的主机上进行，因为每个分段都是一个独立的数据报。被分段的数据报可能沿着不同的路径被传输，而且在传输期间重组分组也会导致效率的降低。</p>
<h4 id="与分段相关的字段"><a class="markdownIt-Anchor" href="#与分段相关的字段"></a> 与分段相关的字段</h4>
<p>当数据报被分段时，主要是讲IP数据报的负载进行分段。每个段都有自己的头部，其中标记、分段偏移和总长度会被改变，校验和被重新计算，而剩余字段则直接被拷贝。</p>
<p>与分段相关的三个字段分别为标识、标记和分段偏移，它们的含义如下：</p>
<ul>
<li>标识：用于识别一个从源主机发出的数据报。当数据报离开源主机时，这个标识和源IP地址的组合必须唯一地定义这个数据报。为了保证唯一性，IP协议使用一个计数器来标识数据报。当IP协议发送数据报时，就将该计数器的当前值复制到标识字段中，并将此计数器的值加1。当数据报分段时，标识字段的值就被复制到所有的分组中。因此，目的端可以将所有具有相同标识的分段重组成一个数据报。</li>
<li>标记：共有3位，定义了3个标记。最左侧为保留位（不使用）；第二位（D位）称为不分段位，如果该位为1，则机器不能将该数据进行分段，如果无法将此数据报通过任何可用物理网络传递，则丢弃这个分组并向源主机发送一个ICMP差错报文，该位为0则可以根据需要进行分段；第三位（M位）称为多分段位，如果其值为1则表示此数据报不是最后的分段，如果其值为0则表示它是最后一个或者唯一的分段。</li>
<li>分段偏移：表示这个分段在整个数据报中的相对位置。它的值为原始数据报中的数据偏移量除以8。因此，每个分段的第一个字节标号一定可以被8整除。</li>
</ul>
<h3 id="数据报安全"><a class="markdownIt-Anchor" href="#数据报安全"></a> 数据报安全</h3>
<p>IP协议容易受下面三个问题的影响：</p>
<ul>
<li>分组嗅探：入侵者可能劫持一个IP分组并制作一份拷贝。这是一种被动攻击，分组的内容没有被改变。如果使用分组加密则可以使得攻击者的企图无效。</li>
<li>分组修改：攻击者拦截分组，改变其内容并将新的分组发送到接收方。可以使用数据完整性机制来发现这种类型的攻击。</li>
<li>IP欺骗：一个攻击者可以伪装成其他人并创建一个IP分组，它携带另一个电脑的源地址。这种类型的攻击可以使用源鉴别机制来预防。</li>
</ul>
<p>如今的IP分组可以使用一个称为IPSec（IP Security）的协议以免遭到之前提到的攻击。这个协议与IP协议一起使用，在两个实体之间创建一个面向连接的服务。IPSec提供了下面的四种服务：</p>
<ul>
<li>定义算法和密钥：创建安全信道的两个实体统一使用一些算法和密钥</li>
<li>分组加密：在双方之间交换的分组可以使用约定好的加密算法和密钥来进行加密</li>
<li>数据完整性：保证分组在传输阶段没有被修改</li>
<li>源鉴别：通过鉴别分组的源，从而确认分组不是冒名顶替者伪造的</li>
</ul>
<h3 id="ipv4地址"><a class="markdownIt-Anchor" href="#ipv4地址"></a> IPv4地址</h3>
<h4 id="简介-3"><a class="markdownIt-Anchor" href="#简介-3"></a> 简介</h4>
<p>一个IPv4地址是32位地址，它唯一地并通用地定义了一个连接在因特网上的主机或者路由器。注意IP地址是连接的地址，而不是主机或者路由器的地址。IPv4地址是唯一的，这表示每一个地址对应于唯一一个连接到因特网上的设备。</p>
<h4 id="地址空间"><a class="markdownIt-Anchor" href="#地址空间"></a> 地址空间</h4>
<p>地址空间是该系统能够使用地址的总个数。IPv4使用32位地址，因此地址空间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>，这意味着超过40亿个设备可以被连接到因特网上。</p>
<h5 id="标记法"><a class="markdownIt-Anchor" href="#标记法"></a> 标记法</h5>
<p>IPv4地址有下面三种常用的标记法：</p>
<ul>
<li>二进制标记法：IPv4地址用32位表示，为了使得可读性更强，通常在每8位之间插入空格来隔开。</li>
<li>点分十进制标记法：将IPv4地址每8位为一段分成4段，并将每一段用点隔开。每一段的数据写成十进制格式，对应于0到255之间的数字。</li>
<li>十六进制表示：使用8个十六进制数字来表示IP地址，这种方法通常用于网络编程。</li>
</ul>
<h5 id="地址层次结构"><a class="markdownIt-Anchor" href="#地址层次结构"></a> 地址层次结构</h5>
<p>一个32位的IPv4地址被分为两部分，左边n位被称为前缀，它定义了网络；后面32-n位被称为后缀，它定义了设备到因特网的连接。前缀可以是固定长度的也可以是变长的。</p>
<h4 id="分类寻址"><a class="markdownIt-Anchor" href="#分类寻址"></a> 分类寻址</h4>
<h5 id="地址类型"><a class="markdownIt-Anchor" href="#地址类型"></a> 地址类型</h5>
<p>当因特网刚开始发展时，IPv4地址被设计为定长前缀。为了满足较小或较大的网络，设计了三种长度的前缀，并将整个地址空间分为五类。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类</th>
<th style="text-align:center">前缀</th>
<th style="text-align:center">首字节</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">8位</td>
<td style="text-align:center">0~127</td>
<td style="text-align:center">128个网络可以拥有</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">16位</td>
<td style="text-align:center">128~191</td>
<td style="text-align:center">2<sup>14</sup>个网络可以拥有</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">24位</td>
<td style="text-align:center">192~223</td>
<td style="text-align:center">2<sup>21</sup>个网络可以拥有</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">不可用</td>
<td style="text-align:center">224~239</td>
<td style="text-align:center">多播地址</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">不可用</td>
<td style="text-align:center">240~255</td>
<td style="text-align:center">保留未来使用</td>
</tr>
</tbody>
</table>
<h5 id="地址耗尽"><a class="markdownIt-Anchor" href="#地址耗尽"></a> 地址耗尽</h5>
<p>由于分类寻址中的地址没有被恰当分配，因此因特网迅速面临地址被用光的问题。这主要是因为使用A类或B类地址的网络中，绝大多数的地址都被浪费；而使用C类地址的网络中，每个网络可以使用的地址数量过小。</p>
<h5 id="子网化和超网化"><a class="markdownIt-Anchor" href="#子网化和超网化"></a> 子网化和超网化</h5>
<p>子网化中，A类或B类中的一大块地址被分成几个子网，每个子网有一个比原网络更大的前缀长度。</p>
<p>超网化与子网化的想法相反，是将几个C类地址块组合为一个较大的块。但是这种方法使得分组路由更加困难。</p>
<h4 id="无类寻址"><a class="markdownIt-Anchor" href="#无类寻址"></a> 无类寻址</h4>
<h5 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h5>
<p>一个解决地址空间被耗尽的短期解决办法是使用无类寻址（长期为IPv6）。在无类寻址中，整个地址空间被分为变长块，地址的前缀定义了块（网络），后缀定义了结点（设备）。但是其中的一个限制是块内的地址数量需要为2的乘方。</p>
<h5 id="前缀长度"><a class="markdownIt-Anchor" href="#前缀长度"></a> 前缀长度</h5>
<p>由于无类寻址中地址的前缀长度不固定，因此需要将前缀的长度加入到地址中，用斜杠来分隔。这种标记法的被称为无类域间路由，又叫斜杠标记法。</p>
<h5 id="从地址中抽取信息"><a class="markdownIt-Anchor" href="#从地址中抽取信息"></a> 从地址中抽取信息</h5>
<p>给出块中的任意一个地址，并假设其前缀长度为n，我们可以很容易地得到这一地址所属块的如下信息：</p>
<ul>
<li>地址数目：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><msup><mn>2</mn><mrow><mn>32</mn><mo>−</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">N=2^{32-n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></li>
<li>块中的首地址：保持地址的最左n位不变，将右侧32-n位全部设为0</li>
<li>块中末地址：保持地址最左n位不变，将右侧32-n位全部设为1</li>
</ul>
<p>首末地址也可以用地址掩码来计算。地址掩码为32位数字，最左n位全部为1，最右边32-n位全部为0。</p>
<p>首地址也被称为网络地址，它相当于是网络的标识符，路由器用它将分组路由到目的端。</p>
<h5 id="块分配与子网"><a class="markdownIt-Anchor" href="#块分配与子网"></a> 块分配与子网</h5>
<p>块分配的最终责任被交给一个全球机构ICANN，但是它不向因特网个人用户分配地址。通常它给一个ISP或一个较大组织分配一大块地址，再由它们将获得的大块地址分成子网。一个子网又可以按照需求继续划分为更多的等级。</p>
<p>在分配块的时候，有两个限制条件：</p>
<ol>
<li>请求的地址数量必须是2的N次幂；</li>
<li>请求块在被分配时，地址空间中要有连续的可用地址，同时块中的首地址必须可以被块中的地址数量整除，以保证首地址前缀后面全部为0。</li>
</ol>
<p>在分配子网时，为了使其能够路由分组，需要满足如下的条件：</p>
<ul>
<li>每个子网的地址数量为2的整数次幂；</li>
<li>每个子网的起始地址可以被子网中的地址数目N<sub>sub</sub>整除，这样使得每个子网的最右侧32-n<sub>sub</sub>位为0，同时子网前缀长度也可以用32-log<sub>2</sub>N<sub>sub</sub>直接计算出来。因此在设计子网时，一般按照子网规模从大到小来分配。</li>
</ul>
<h4 id="特殊地址"><a class="markdownIt-Anchor" href="#特殊地址"></a> 特殊地址</h4>
<p>在IPv4中，有5种用于特殊目的的地址：</p>
<ul>
<li>本地主机地址：0.0.0.0/32。当主机需要发送一个IP数据报时，需要自己的地址作为源地址。但是开始时主机不知道自己的地址，便会使用本地主机地址。</li>
<li>有限广播地址：255.255.255.255/32。当路由器或主机需要向网络中的所有设备发送一个数据报时会使用到这个地址。但是网络中的路由器会阻挡目的地址为有限广播地址的分组，使其不能传递出网络。</li>
<li>回送地址：127.0.0.0/8。如果某个分组的目的地址是这个块中的某个地址，那么它不会离开主机，这个块中的地址用于测试机器中的一个软件。</li>
<li>私有地址：10.0.0.0/8、172.16.0.0/12、192.168.0.0/16和169.254.0.0/16。</li>
<li>多播地址：224.0.0.0/4。</li>
</ul>
<h2 id="动态主机配置协议dhcp"><a class="markdownIt-Anchor" href="#动态主机配置协议dhcp"></a> 动态主机配置协议（DHCP）</h2>
<h3 id="简介-4"><a class="markdownIt-Anchor" href="#简介-4"></a> 简介</h3>
<p>一个组织中的地址分配可以使用动态主机配置协议（Dynamic Host Configuration Protocol, DHCP）来完成。它是一个应用层的程序，使用客户-服务器模式，实际上帮助网络层的TCP/IP。</p>
<h3 id="报文格式"><a class="markdownIt-Anchor" href="#报文格式"></a> 报文格式</h3>
<p>下图所示为DHCP的报文格式：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132044.png" alt="DHCP报文格式" /></p>
<p>报文中的64字节选项字段有两个目的，它可以携带附加信息或是一些特定的厂商信息。</p>
<h3 id="dhcp运行"><a class="markdownIt-Anchor" href="#dhcp运行"></a> DHCP运行</h3>
<p>DHCP的运行步骤大致如下：</p>
<ol>
<li>连接主机创建一个DHCPDISCOVER报文，其中只有事务ID字段，它被设为随机数字，其他字段因为主机没有相应信息而无法被设置。这个报文被封装在UDP用户数据报中，其中源端口为68，目的端口为67。用户部分被封装在IP数据报中，源地址为0.0.0.0（本机），目的地址为255.255.255.255（广播地址），因为主机既不知道自己的地址也不知道服务器的地址。</li>
<li>DHCP服务器以DHCPOFFER报文响应，其中你的IP地址字段定义了连接主机的IP地址，服务器IP地址字段包含服务器的IP地址。这个报文也包含了主机可以拥有这个IP地址的租赁时间。报文被封装到一个用户数据报中，它带有相同的端口号，但是顺序相反。用户数据报依次被封装到服务器地址是源IP地址的数据报中，但是目的地址是广播地址，这样服务器允许其他DHCP服务器接收这个报文，并提供一个更好的IP地址。</li>
<li>连接主机收到一个或者多个DHCPOFFER报文并从中选出最好的一个。之后连接主机向这个提供最好报文的服务器发送一个DHCPREQUEST报文。其中带有已知数值的字段被设置，报文被封装在用户数据报中，其中端口号是第一个报文的端口号。用户数据被封装在IP数据报中，源地址设为新的客户地址，但是目的地址仍然为广播地址，这样使得服务器知道它们的DHCPOFFER报文没有被接受。</li>
<li>最终如果提供的IP地址有效，被选定的服务器以DHCPACK报文响应客户端。如果服务器并没有保存这个DHCPOFFER报文，就发送一个DHCPNACK报文，并且客户需要重复上述过程。同时这个报文也被广播，使得其他服务器知道请求被接收或者被拒绝。</li>
</ol>
<p>在这一过程中，有一些需要注意的细节：</p>
<ul>
<li>DHCP使用两个熟知端口号，这是因为服务器到客户的响应是广播。在多个DHCP客户同时运行时，报文可以通过事务ID进行区分，从而将响应区分开。</li>
<li>服务器并不发送连接网络的客户所需的所有信息。在DHCPACK报文中，服务器定义了文件的路径名，其中客户可以找到完整的信息如DNS服务器地址。客户之后可以使用FTP协议来获取其余所需的信息。</li>
<li>为了提供差错控制，DHCP使用两个策略：首先DHCP要求UDP使用校验和；第二，如果DHCP客户段没有接收到DHCP对请求的回应，那么它使用计时器以及重传策略。为了防止重传请求的拥塞，DHCP要求客户端使用随机数设置计时器。</li>
</ul>
<h2 id="网络地址转换nat"><a class="markdownIt-Anchor" href="#网络地址转换nat"></a> 网络地址转换（NAT）</h2>
<h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h3>
<p>如果一个ISP给一个小公司或是家庭用户分配了一个小范围地址，但是在需要更大地址范围时，ISP可能无法满足需要。网络地址转换（Network Address Translation, NAT）提供了私有地址和通用地址的映射，同时支持虚拟私有网络。这个技术允许一个站点使用一组私有地址以及一组全局因特网地址（至少一个）来与世界上其余的计算机进行通信。</p>
<h3 id="地址转换"><a class="markdownIt-Anchor" href="#地址转换"></a> 地址转换</h3>
<p>所有通过NAT路由器发出去的分组都将分组中的源地址替换为全局NAT地址；同时所有通过NAT路由器进入的分组也都将目的地址（NAT的路由器的全局地址）替换成适当的私有地址。</p>
<p>将私有地址转为全局地址是容易的，但是对于相反操作，则需要使用NAT路由器的转换表进行地址转换。一个转换表中共有5列，分别为私有地址、私有端口、外部地址、外部端口和传输协议。使用5列地址能够消除连接的二义性，让私有网络主机和外部服务器程序之间建立多对多的关系。</p>
<h2 id="ip分组的转发"><a class="markdownIt-Anchor" href="#ip分组的转发"></a> IP分组的转发</h2>
<h3 id="基于目的地址的转发"><a class="markdownIt-Anchor" href="#基于目的地址的转发"></a> 基于目的地址的转发</h3>
<h4 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h4>
<p>基于目的地址的转发要求主机或者路由器有转发表，它查看转发表来找到分组的下一跳。在转发表中，需要包含四项信息：掩码、网络地址、接口号码以及下一个路由器的IP地址。</p>
<p>转发模块的工作是一行一行地查找表。在每一行中，目的地址的最左边n位（前缀）被保留下来，然后与表中的网络地址的最左边n位进行匹配。如果匹配成功，则找到下一跳的IP地址以及接口；否则继续查找表格。通常最后一行的第一列为默认值，表示所有目的地址都无法匹配。</p>
<p>为了加快搜索速度，也可以使用其它的数据结构来取代列表，但是匹配原则保持不变。</p>
<h4 id="地址聚合"><a class="markdownIt-Anchor" href="#地址聚合"></a> 地址聚合</h4>
<p>当使用无类寻址时，由于地址空间的分割没有固定规律，因此转发表项的数量有可能会增加，这也会导致搜索表格所消耗时间的增加。因此，路由器中一些前缀相同的地址可能会被聚合成一个地址，这被称为地址聚合。</p>
<h4 id="最长掩码匹配"><a class="markdownIt-Anchor" href="#最长掩码匹配"></a> 最长掩码匹配</h4>
<p>无类寻址的路由使用最长掩码匹配原则，这个原则表明转发表需要按照最长掩码到最短掩码的顺序来存储。</p>
<h4 id="分层路由与地理路由"><a class="markdownIt-Anchor" href="#分层路由与地理路由"></a> 分层路由与地理路由</h4>
<p>为了解决转发表过大的问题，可以在路由表中创建层次结构。在无类路由选择中，只要遵循无类寻址原则，层次的级是没有限制的。</p>
<p>将地址空间分成几大块，然后分别将其分给不同的大洲，通过这样构建的分层路由也被称为地理路由。</p>
<h3 id="基于标签的转发"><a class="markdownIt-Anchor" href="#基于标签的转发"></a> 基于标签的转发</h3>
<h4 id="原理-2"><a class="markdownIt-Anchor" href="#原理-2"></a> 原理</h4>
<p>在面向连接网络中，交换机基于附加在分组上的标签来路由分组。路由通常基于对表格内容的搜索，而基于标签的转发方式中，通过使用索引访问表格即可完成交换。</p>
<h4 id="多协议标记交换"><a class="markdownIt-Anchor" href="#多协议标记交换"></a> 多协议标记交换</h4>
<p>多协议标记交换（Multi-Protocol Label Switching, MPLS）标准使得因特网中的一些传统路由器可以被MPLS路由器替代，它可以作为一台路由器和交换机的结合体来工作。也就是说，它可以基于目的地址来转发分组，也可以基于标签来转发分组。</p>
<p>MPLS位于数据链路层和网络层之间，整个IP分组作为负载被封装到一个MPLS分组中，并且加入一个MPLS头部。一个MPLS头部可能包含许多子头部，它被用来进行多级分层交换。</p>
<p>一个MPLS子头部一共32位长，包含下面4个字段：</p>
<ul>
<li>标签：长20位，定义了路由器中索引转发表的标签</li>
<li>Exp：长3位，被保留用于实验目的</li>
<li>S：长1位，定义了堆中子头部的情况，如果这个位为1则意味着这个头部是堆中的最后一个。</li>
<li>TTL：长8位，于IP数据报中的TTL字段作用类似，每个被访问的路由器都减少这个字段的值，当其变为0时，则分组被丢弃以防止形成循环。</li>
</ul>
<h2 id="icmpv4"><a class="markdownIt-Anchor" href="#icmpv4"></a> ICMPv4</h2>
<h3 id="作用-2"><a class="markdownIt-Anchor" href="#作用-2"></a> 作用</h3>
<p>IPv4没有差错报告或者差错更正机制，同时IP协议还缺少主机和管理方面的查询机制。因特网控制报文协议（Internet Control Message Protocol version 4, ICMPv4）可以用于弥补上述缺点，它是配合IP协议使用的。</p>
<p>ICMP自身是网络层协议，但是它的报文不是直接传给数据链路层，而是首先被封装到IP数据报中，并将其协议字段值设置为1，表示IP负载是一个ICMP报文。</p>
<h3 id="报文"><a class="markdownIt-Anchor" href="#报文"></a> 报文</h3>
<h4 id="报文格式-2"><a class="markdownIt-Anchor" href="#报文格式-2"></a> 报文格式</h4>
<p>ICMPv4报文分为差错报告报文和查询报文。这两种报文类型的头部格式不同，它们的报文格式如下图所示：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132113.png" alt="ICMP报文" /></p>
<h4 id="差错报告报文"><a class="markdownIt-Anchor" href="#差错报告报文"></a> 差错报告报文</h4>
<p>差错报告报文用于报告在处理一个IP数据报时可能碰到的一些问题。但是ICMP仅仅报告差错，差错的纠正留给高层协议。差错报文总是被发给源端，ICMP使用源IP地址将差错报文发送给数据报的发送方。</p>
<p>为了简化差错报告，ICMP的报告报文遵循下面的规则：</p>
<ul>
<li>对于带有多播或者特殊地址（如本机或回送地址）的数据报不会产生差错报文。</li>
<li>对于携带ICMP差错报文的数据报不再产生差错报文。</li>
<li>对于分段的数据报文，如果不是第一个分段不产生差错报文。</li>
</ul>
<p>所有的差错报文都包含一个数据部分，包含原始数据报的IP头部加上数据报中前8个字节的数据。加入原始数据报头部的目的是为了向原始的源端给出数据报本身的信息。</p>
<p>常用的差错报告报文有：</p>
<ul>
<li>目的端不可达报文（类型3）： 使用不同的代码（0~15）来定义差错报文的类型和数据报不能到达目的端的原因。</li>
<li>源端抑制报文（类型4）：通知发送端，网络出现拥塞并且数据报被丢弃。源端需要减慢发送速率。</li>
<li>重定向报文（类型5）：将报文重定向到适当的路由器，但是通知源端让其以后改变默认路由器。默认路由器的IP地址在这个报文中被发送。</li>
<li>超时报文（类型11）：当IP数据报中生存时间TTL变为0时，数据被它所访问的路由器丢弃并且发送一个代码为0的超时报文给源端。如果组成一个报文的所有分段没有在某个时限内到达主机则发生代码为1的超时报文。</li>
<li>参数问题报文（类型12）：当数据报头部出现问题（代码0）或是一些选项丢失不能被解释（代码1）时，发送这一报文。</li>
</ul>
<h4 id="查询报文"><a class="markdownIt-Anchor" href="#查询报文"></a> 查询报文</h4>
<p>查询报文可以独立使用，而与IP数据报无关，但是它需要作为负载被封装到数据报中。查询报文用来探测或检测互联网中的主机或者路由器是否处于活跃状态，也用来获取两台设备之间IP数据报的单向或往返时间，甚至用于检查两台设备之间的时钟是否同步。查询报文包括查询和回答，它们成对出现。</p>
<p>常用的查询报文有：</p>
<ul>
<li>回送请求（类型8）以及回送应答（类型0）报文：主机或路由器发送回送请求报文，来检测另一台主机或者路由器是否处于活跃状态。如果活跃，则回应一个回送应答报文。</li>
<li>时间戳请求（类型13）以及时间戳回答（类型14）报文：确定两个设备之间的往返时间或者检查两个设备之间的时钟是否同步。时间戳请求报文发送一个32位数字，表示报文被发送的时间；时间戳回答重发此数字，但是也包括一个新的32位数字以及响应被发送的时间，这个新数字即为请求被接收的时间。</li>
</ul>
<h1 id="单播路由选择"><a class="markdownIt-Anchor" href="#单播路由选择"></a> 单播路由选择</h1>
<h2 id="思想以图的形式表示因特网"><a class="markdownIt-Anchor" href="#思想以图的形式表示因特网"></a> 思想：以图的形式表示因特网</h2>
<p>为了找到最好的路由传播路径，互联网可以用图来表示。将每个路由器看作一个结点，一对路由器之间的网络看成一条边，由于每一条网络的传输具有一定的代价，因此互联网以带权图表示。</p>
<p>根据上面的描述，可以得出如下的概念：</p>
<ul>
<li>
<p>最小代价路由：由于源路由器到目的路由器之间可能有多条路由，因此从源路由器到目的路由器的最佳路由就是找到两者之间的最小代价。也就是说，源路由器在所有可能的路由中找到代价最小的那条作为到目的路由器的路由。</p>
</li>
<li>
<p>最小代价树：最小代价树以源路由器为根，访问了所有其余的结点，并且其中根和其它结点的路径是最短的。</p>
</li>
</ul>
<h2 id="路由选择算法"><a class="markdownIt-Anchor" href="#路由选择算法"></a> 路由选择算法</h2>
<h3 id="距离向量路由选择"><a class="markdownIt-Anchor" href="#距离向量路由选择"></a> 距离向量路由选择</h3>
<h4 id="信息交换"><a class="markdownIt-Anchor" href="#信息交换"></a> 信息交换</h4>
<p>在距离向量路由选择中，每个结点（路由器）要利用自身所拥有的关于相邻结点的初步信息创建最小代价树。这些不完全的树在相邻结点之间不断交换，使得树越来越完整。</p>
<h4 id="bellman-ford方程"><a class="markdownIt-Anchor" href="#bellman-ford方程"></a> Bellman-Ford方程</h4>
<p>Bellman-Ford方程用于计算源结点x到目的结点y的最小代价，而这条路径穿过了中间结点（a, b, c,……）。我们将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">D_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>记作最短距离，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">c_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>记作结点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i,j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>之间的代价，则有：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mrow><mi>x</mi><mi>y</mi></mrow></msub><mo>=</mo><munder><mo><mi>m</mi><mi>i</mi><mi>n</mi></mo><mrow><mi>i</mi><mo>=</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mo>⋯</mo></mrow></munder><mo stretchy="false">(</mo><msub><mi>c</mi><mrow><mi>x</mi><mi>i</mi></mrow></msub><mo>+</mo><msub><mi>D</mi><mrow><mi>i</mi><mi>y</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D_{xy}=\mathop{min} \limits_{i=a,b,c,\cdots}(c_{xi}+D_{iy})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.638216em;vertical-align:-0.8882159999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.65952em;"><span style="top:-2.3478920000000003em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">b</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">c</span><span class="mpunct mtight">,</span><span class="minner mtight">⋯</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathdefault">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8882159999999999em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<h4 id="距离向量"><a class="markdownIt-Anchor" href="#距离向量"></a> 距离向量</h4>
<p>距离向量路由将最小代价路由树改写为一维数组。一个距离向量的名称定义了根结点，索引定义了目的结点，而每个索引的值则对应了根结点到目的结点的最小代价。因此，一个距离向量不包含目的结点的路径。</p>
<p>当互联网中的结点启动时，它创建一个基本的距离向量，包含了可从相邻结点获得的最少信息，而未知距离的结点则被标记为无穷大。在此之后，这一结点从相邻结点接收到它们的距离向量副本，然后使用Bellman-Ford方程来更新距离向量。</p>
<p>上述的过程可以用下图来表示：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132122.png" alt="距离向量" /></p>
<p>距离向量路由的一个问题是，任何代价的减少传播的快，而代价的增加传播的慢。为了使路由协议可以正常工作，如果链路损坏，其余每个路由器应该立即意识到这件事情。但是在距离向量路由选择中这需要花费一些时间。这个问题称为计数到无穷问题，通常需要好几个更新才能使得损坏链路被所有服务器记录为无穷。</p>
<h3 id="链路状态路由选择"><a class="markdownIt-Anchor" href="#链路状态路由选择"></a> 链路状态路由选择</h3>
<h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h4>
<p>在链路状态路由选择中，使用术语链路状态来定义链路（即图中的一条边）的特征，链路代表了互联网中的网络。在这种算法中，与边相关的代价定义了链路的状态，代价低的链路比代价高的链路更好；如果链路代价无限大则对应于链路不存在或者已经被损坏。</p>
<h4 id="链路状态数据库"><a class="markdownIt-Anchor" href="#链路状态数据库"></a> 链路状态数据库</h4>
<p>所有链路状态的集合称为链路状态数据库（Link-State Database, LSDB），整个互联网只有一个LSDB，它可以用一个二维数组来表示，其中每个单元格的值对应于相应链路的代价。每个结点通过使用它可以创建最小代价树。</p>
<p>创建LSDB的过程可以通过泛洪的过程来完成。每个结点可以给其相邻结点发送问候报文，来收集每个相邻结点的结点标识以及链路代价。这两个信息的组合成为LS分组。</p>
<p>当结点从一个接口接收到LSP时，它将其与已经拥有的副本进行比较。如果新到达的LSP比拥有的副本旧，则直接丢掉；如果接收到的版本更新，则丢弃旧LSP并保存接收到的新版本。在此之后，结点向每个端口发送一份副本（不包含分组到达的端口，这样保证泛洪可以停止）。</p>
<p>这一过程可以用下图表示：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132130.png" alt="LSDB的创建" /></p>
<h4 id="最小代价树的形成"><a class="markdownIt-Anchor" href="#最小代价树的形成"></a> 最小代价树的形成</h4>
<p>为了创建最小代价树，使用共享LSDB的每个结点可以运行Dijkstra算法来生成（算法的详细过程参考CLRS）。</p>
<h3 id="路径向量路由选择"><a class="markdownIt-Anchor" href="#路径向量路由选择"></a> 路径向量路由选择</h3>
<h4 id="目标"><a class="markdownIt-Anchor" href="#目标"></a> 目标</h4>
<p>在路径向量路由选择算法中，源端可以控制路径。这种算法主要是为ISP之间的路由分组而设计。</p>
<h4 id="生成树"><a class="markdownIt-Anchor" href="#生成树"></a> 生成树</h4>
<p>在路径向量路由选择中，从源端到目的端的路径是由最佳生成树决定的。然而最佳生成树不是最小代价树，它是根据源端使用的策略生成出来的。</p>
<p>路径向量路由选择与距离向量路由选择类似，是一种异步、分布式路由选择算法。因此，生成树（路径向量）的生成方法也类似，是每个结点异步地逐步更新创建起来的。</p>
<h4 id="路径向量算法"><a class="markdownIt-Anchor" href="#路径向量算法"></a> 路径向量算法</h4>
<p>在创建初始路径向量之后，每个结点也将其发送给相邻结点。此时，每个结点都使用与Bellman-Ford类似的方程式来更新路径向量，但是结点使用自己的策略而不是寻找最小代价。</p>
<h2 id="单播路由选择协议"><a class="markdownIt-Anchor" href="#单播路由选择协议"></a> 单播路由选择协议</h2>
<h3 id="路由选择信息协议"><a class="markdownIt-Anchor" href="#路由选择信息协议"></a> 路由选择信息协议</h3>
<h4 id="概述-3"><a class="markdownIt-Anchor" href="#概述-3"></a> 概述</h4>
<p>路由选择信息协议（Routing Information Protocol, RIP）是一个在自治系统内部使用的域内路由选择协议，它基于距离向量路由选择算法实现。</p>
<h4 id="跳数"><a class="markdownIt-Anchor" href="#跳数"></a> 跳数</h4>
<p>在RIP协议中，代价的实现被简化为跳数，它表示分组从源路由器到最终目的主机所需要穿过的网络（子网）的数量。路径的最大代价是15，16则意味着无连接，因此RIP只能用于自治系统（Autonomous System, AS）。</p>
<h4 id="转发表"><a class="markdownIt-Anchor" href="#转发表"></a> 转发表</h4>
<p>RIP中的转发表是一个三列表格，第一列是目的网络的地址，第二列是分组应该被转发到的下一跳路由器的地址，第三列是到达目的网络的跳数。</p>
<p>通过在转发表中加入下一跳路由器的地址，可以利用这一信息来还原出最小代价树。</p>
<h4 id="rip实现"><a class="markdownIt-Anchor" href="#rip实现"></a> RIP实现</h4>
<h5 id="应用层程序"><a class="markdownIt-Anchor" href="#应用层程序"></a> 应用层程序</h5>
<p>RIP是使用UDP服务和熟知端口号520实现的一种进程。在BSD中，RIP是一个称为routed的守护进程。也就是说，RIP运行在应用层上，但是为网络中的IP创建转发表。</p>
<h5 id="rip报文"><a class="markdownIt-Anchor" href="#rip报文"></a> RIP报文</h5>
<p>在一个RIP报文中，表项部分可以按需重复，每个表项携带着与转发表里面某一行相关的信息，这个转发表位于发送报文的路由器中。报文格式如下：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132137.png" alt="RIP报文格式" /></p>
<p>RIP的报文分为请求和响应两种。请求报文被创建它的路由器发送，用于询问特定表项或者全部表项；而响应报文可以是请求型的或者非请求型的。请求型报文用于回答请求报文，它包含相应请求报文中指定目的端的信息，而非请求型的响应报文被周期性地发送，或是当转发表有变化时发送。</p>
<h5 id="rip算法"><a class="markdownIt-Anchor" href="#rip算法"></a> RIP算法</h5>
<p>RIP实现的算法与距离向量路由选择算法相同。为了使路由器可以更新其转发表，需要做一些修改：</p>
<ul>
<li>路由器需要在响应报文中发送转发表的全部内容，而不仅仅是距离向量。</li>
<li>接收端在每个代价上加入一跳，并且将下一跳路由器字段改为发送路由器的地址。</li>
<li>根据目的路由存储新的转发表。</li>
</ul>
<h5 id="rip计时器"><a class="markdownIt-Anchor" href="#rip计时器"></a> RIP计时器</h5>
<p>RIP中一共用到了三个计时器来支持其运行：</p>
<ul>
<li>周期计时器：控制常规更新报文的通告行为，每个路由器都有一个。</li>
<li>超时计时器：控制路由的有效性。当路由器接收到路由更新信息时，设置这条路由的超时计时器。每当这条路由新的更新到达时，计时器被重置；如果在超时计数器倒计时为0时没有收到更新，则认为路由超时，将路由的跳数设置为16。每个路由都有自己的超时计数器。</li>
<li>垃圾收集计时器：用于从转发表中清除路由。当关于路由的信息无效时，路由器不会立即将路由从表中清除。它继续将路由代价通告为16。同时，那条路由的垃圾收集计时器被设置，当计时到0时便将路由从表中清除。这个计时器允许邻居在清除路由之前，注意到路由的无效性。</li>
</ul>
<h4 id="rip性能"><a class="markdownIt-Anchor" href="#rip性能"></a> RIP性能</h4>
<ul>
<li>更新报文：更新报文仅仅发送给邻居，通常不会造成过大的网络通信量。</li>
<li>转发表的收敛：由于RIP只允许域中最多15跳，通常收敛中不会存在问题。</li>
<li>健壮性：由于每个路由器将它对整个域的了解发送给它的邻居，因此当路由失效或出错时，这个问题可以被传播给所有的路由器。</li>
</ul>
<h3 id="开放最短路径优先"><a class="markdownIt-Anchor" href="#开放最短路径优先"></a> 开放最短路径优先</h3>
<h4 id="概述-4"><a class="markdownIt-Anchor" href="#概述-4"></a> 概述</h4>
<p>开放最短路径优先（Open Shortest Path First, OSPF）是一个和RIP类似的域内路由选择协议，但是它是基于链路状态的路由选择。OSPF是一个开放协议。</p>
<h4 id="度量"><a class="markdownIt-Anchor" href="#度量"></a> 度量</h4>
<p>在OSPF协议中，每个链路（网络）可以被分配一个基于流量、往返时间和可靠性等方面的权值；同样也可以使用跳数作为代价。对于OSPF中的代价，不同服务类型可以拥有不同的权值。</p>
<h4 id="转发表-2"><a class="markdownIt-Anchor" href="#转发表-2"></a> 转发表</h4>
<p>OSPF与RIP协议中，转发表唯一的不同就在于代价值。如果OSPF中使用跳数，那么它们的转发表将会完全相同。</p>
<h4 id="区域"><a class="markdownIt-Anchor" href="#区域"></a> 区域</h4>
<p>与RIP相比，OSPF用来处理小型或大型自治系统中的路由选择，而RIP通常在小型的自治系统中使用。</p>
<p>由于在大型系统中创建全局链路状态数据库将会产生巨大的通信量，因此OSPF会将一个大型自治系统划分为多个不同的区域，每个区域在泛洪LSP中相当于小型独立域。为了使得区域中的每个路由器知道本区域和其他区域的链路状态信息，某一个区域会被指派为主干区域，它负责将其他区域连接到一起。主干区域的路由器负责将每个区域收集到的信息传递到其他区域。</p>
<h4 id="链路状态通告"><a class="markdownIt-Anchor" href="#链路状态通告"></a> 链路状态通告</h4>
<p>OSPF协议中，要求路由器向所有邻居通告其链路状态，以此形成LSDB。一共有5种不同的链路状态通告类型：</p>
<ul>
<li>路由器链路：将路由器以结点的形式进行通告。除了给出所声明路由器的地址外，这种类型的通告还可以定义如下的多种链路类型：
<ul>
<li>过渡链路：声明通向过渡网络的链路，这个网络通过一个或者多个路由器连接到网络的剩余部分。这种通告类型应该定义过渡网络地址和链路代价。</li>
<li>残桩链路：通告残桩网络的链路，这种网络不完全算是贯穿型网络。这种通告类型定义网络地址和代价。</li>
<li>点对点链路：定义点对点连线末端路由器的地址以及到达它所需要花费的代价。</li>
</ul>
</li>
<li>网络链路：将网络作为一个结点进行通告。由于网络无法通告自身，因此其中一个路由器被指派为指定路由器，并且由它进行通告。这一类LSP声明了所有路由器的IP地址。由于路由器发送路由器链路已经包含代价，因此这种通告不包含代价。</li>
<li>通向网络的汇总链路：通过区域边界路由器完成，它通告了由主干收集的通往一个区域的汇总链路，或者通告区域收集的通往主干的链路汇总。将区域连接到一起时就需要这种信息交换。</li>
<li>通向自治系统的汇总链路：通过一个AS路由器完成，它通告从其他的AS到当前AS主干区域的汇总链路，这些信息可以散播到区域中。</li>
<li>外部链路：通过AS路由器完成。它向主干区域声明AS之外存在一个单独网络，这个信息被散播到多个区域中。</li>
</ul>
<h4 id="ospf实现"><a class="markdownIt-Anchor" href="#ospf实现"></a> OSPF实现</h4>
<h5 id="概述-5"><a class="markdownIt-Anchor" href="#概述-5"></a> 概述</h5>
<p>OSPF是以网络层程序的形式实现，它使用IP服务来进行传播。IP数据报携带来自OSPF的报文，并且将协议字段的值设置为89。</p>
<h5 id="ospf报文"><a class="markdownIt-Anchor" href="#ospf报文"></a> OSPF报文</h5>
<p>OSPF共包含了5种不同类型的报文，包括：</p>
<ul>
<li>问候报文：被路由器用来向邻居介绍自己，并声明它知道的所有邻居。</li>
<li>数据库描述报文：响应问候报文，允许一个新加入的路由器获取全部的LSDB。</li>
<li>链路状态请求报文：被需要特定LS的路由器发送。</li>
<li>链路状态更新报文：是用于创建LSDB的主要OSPF报文。</li>
<li>链路状态确认报文：用来保证OSPF中的可靠性，每个接收链路状态更新报文的路由器都需要确认它。</li>
</ul>
<p>这些报文的格式如下图所示：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132244.png" alt="OSFP协议报文" /></p>
<h5 id="鉴定"><a class="markdownIt-Anchor" href="#鉴定"></a> 鉴定</h5>
<p>OSPF公共头部为报文发送端提供鉴定。这可以防止恶意实体向路由器发送OSPF报文并导致路由器成为某个路由选择系统的一部分，而实际上这个路由器根本不属于这个路由选择系统。</p>
<h5 id="ospf算法"><a class="markdownIt-Anchor" href="#ospf算法"></a> OSPF算法</h5>
<p>OSPF使用链路状态路由选择算法，但是需要在算法中加入一些改变和鉴定工作：在每个路由器创建最短路径树之后，算法需要用它来创建响应的路由选择算法；同时这个算法需要增强，使之能够发送和接收5种类型的报文。</p>
<h5 id="性能"><a class="markdownIt-Anchor" href="#性能"></a> 性能</h5>
<ul>
<li>更新报文：OSPF中的链路状态报文较复杂，它们也被泛洪到整个区域。如果区域很大，这些报文可能造成很大通信量并占用很大带宽。</li>
<li>转发表的收敛：当LSP泛洪完成，每个路由器都可以创建它自己的最短路径树和转发表，收敛较快。但是由于每个路由器都要运行Dijkstra算法，这需要花费一些时间。</li>
<li>健壮性：OSPF协议比RIP协议更加健壮。因为接收到完整的LSDB之后，每个路由器是独立的，不依赖与区域中的其他路由器。因此一个路由器的差错或失效不会严重影响其它路由器。</li>
</ul>
<h3 id="边界网关协议第四版"><a class="markdownIt-Anchor" href="#边界网关协议第四版"></a> 边界网关协议第四版</h3>
<h4 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h4>
<p>边界网关协议（Border Gateway Protocol, BGP）是当今因特网中唯一的一个域间路由选择协议。它居于之前描述的路径向量算法。</p>
<p>为了使得每个路由器都能将分组路由到互联网的任意网络上，每个边界路由器（位于每个AS的一条边上，这条边连接到另一个AS的服务器上）上需要安装外部BGP（external BGP, eBGP）。同时所有路由器上需要安装内部BGP（internal BGP, iBGP）。</p>
<p>BGP协议是一种点对点协议，当软件运行在两个路由器上时，它们使用熟知端口号179来创建一个TCP连接。运行BGP进程的两个路由器被称为BGP对等结点或BGP代言结点。</p>
<h5 id="外部bgp"><a class="markdownIt-Anchor" href="#外部bgp"></a> 外部BGP</h5>
<p>外部BGP变体允许两个建立物理连接的边界路由器形成一对eBGP代言结点并交换报文，这两个路由器位于不同的AS中。但是要实现信息交换，则需要在物理连接的基础上创建逻辑TCP连接以实现信息交换，在BGP中逻辑连接被称为会话。</p>
<h5 id="内部bgp"><a class="markdownIt-Anchor" href="#内部bgp"></a> 内部BGP</h5>
<p>iBGP协议也是在熟知端口179上使用TCP连接，但是它在自治系统中可能成对的路由器之间创建一个会话。</p>
<h5 id="域内路由选择信息插入"><a class="markdownIt-Anchor" href="#域内路由选择信息插入"></a> 域内路由选择信息插入</h5>
<p>BGP的职责是帮助AS内部的路由器增加路由选择信息。在路径表被收集并组织完成之后，它会被插入到用于路由分组的域内转发表（RIP或者OSPF）中。</p>
<h5 id="地址聚合-2"><a class="markdownIt-Anchor" href="#地址聚合-2"></a> 地址聚合</h5>
<p>由于BGP协议所获得的域间转发表在全局因特网的情况下会变得很大，因此BGP协议使用前缀作为目的标识符并且允许聚合这些前缀。</p>
<h4 id="路径属性"><a class="markdownIt-Anchor" href="#路径属性"></a> 路径属性</h4>
<p>BGP允许目的端与多达7个路径属性相关。这些路径属性分为熟知和可选，熟知属性必须被所有路由器识别，而可选属性不要求这样。</p>
<p>一个路径属性的格式如下：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132236.png" alt="BGP路径属性格式" /></p>
<p>每个属性的第一字节定义了四个属性标记，下一个字节定义了ICANN分配的属性类型，属性值长度定义了属性值字段的长度。</p>
<p>下面是每个属性的简要描述：</p>
<ul>
<li>ORIGIN（类型1）：熟知的强制属性，它定义了路由选择信息的源端。它可以定义为以下三种值：1代表路径信息从域内协议获得，2代表信息从BGP获得，3代表来自未知源端</li>
<li>AS-PATH（类型2）：熟知的强制属性，它定义了自治系统清单，穿过这些自治系统可以到达目的端。这一属性可以帮助防止循环，也可以在路由选择中使用。</li>
<li>NEXT-HOP（类型3）：熟知的强制属性，它定义了数据分组应该被转发到的下一跳路由器。</li>
<li>MULT-EXIT-DISC（类型4）：多出口鉴别器是一个可选的不可迁移属性，它鉴别通向一个目的端的多个出口路径。这个属性的数值通常被相应域内协议的度量标准定义（一个四字节无符号整型的属性数值）。</li>
<li>LOCAL-PREF（类型5）：本地偏好是熟知的可选属性，它从此由管理员设定，基于组织机构的策略。</li>
<li>ATOMIC-AGGREGATE（类型6）：熟知的可选属性，它不以聚合方式定义目的端前缀，只定义一个目的端网络。这个属性没有数值字段。</li>
<li>AGGREGATOR（类型7）：可选的可迁移属性，它强调目的端的前缀是可以聚合的。</li>
</ul>
<h4 id="路由选择"><a class="markdownIt-Anchor" href="#路由选择"></a> 路由选择</h4>
<p>BGP的路由选择过程需要考虑到一些附加其上的属性，因此过程将会更加复杂一些。通常实现所使用的流程图如下：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132205.png" alt="BGP路由选择过程" /></p>
<h4 id="报文-2"><a class="markdownIt-Anchor" href="#报文-2"></a> 报文</h4>
<p>BGP有4类报文，用于AS间和AS内部BGP代言结点的通信。所有BGP分组分享相同的公共头部。报文格式如下图所示：</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132205.png" alt="BGP报文格式" /></p>
<p>四种报文的作用如下：</p>
<ul>
<li>打开报文：为了创建邻居关系，运行BGP的路由器打开一个与邻居的TCP连接并发送一个打开报文。</li>
<li>更新报文：它是BGP协议的核心。它被路由器用来取出之前通知的目的端，以便声明通向新的目的端的路由。BGP可以取出几个之前声明的目的端，但是一个更新报文中只能声明一个新的目的端。</li>
<li>保活报文：处于运行状态的BGP对等结点周期性地交换保活报文，从而彼此告知它们处于活跃状态。</li>
<li>通知：当检查到错误情况或者路由器要关闭会话时，路由器发送通知报文。</li>
</ul>
<h4 id="性能-2"><a class="markdownIt-Anchor" href="#性能-2"></a> 性能</h4>
<p>BGP的代言结点交换很多报文来创建转发表，但是BGP没有循环和计数到无穷。RIP中关于传播失效和出错的缺点在BGP中仍然存在。</p>
<h1 id="多播路由选择"><a class="markdownIt-Anchor" href="#多播路由选择"></a> 多播路由选择</h1>
<h2 id="介绍-2"><a class="markdownIt-Anchor" href="#介绍-2"></a> 介绍</h2>
<h3 id="单播"><a class="markdownIt-Anchor" href="#单播"></a> 单播</h3>
<p>在单播中，只有一个源端和一个目的端网络。源端和目的端网络的关系是一对一的。数据报路径中的每个路由器试图将分组转发到唯一的端口上。</p>
<h3 id="多播"><a class="markdownIt-Anchor" href="#多播"></a> 多播</h3>
<p>在多播中，存在一个源端和一组目的端，其关系是一对多的。在这类通信中，源地址是一个单播地址，而目的地址是一组地址，其中存在至少一个有兴趣接收多播数据报的组成员。在多播中，多播路由器可能需要通过它的多个端口将相同数据报的副本发送出去。</p>
<p>注意，需要区分多播和多个单播这两个概念。多播从源地址开始时时单个分组，这个分组被路由器复制，每个分组中的目的地址对于所有的副本都是相同的；而在多个单播中，从源端发出多个分组。多播比多个单播效率更高，要求的带宽更小，同时由于源端只生成一个分组因此没有延迟。</p>
<p>多播有如下这些应用示例：</p>
<ul>
<li>访问分布式数据库</li>
<li>信息发布</li>
<li>电话会议</li>
<li>远程学习</li>
</ul>
<h3 id="广播"><a class="markdownIt-Anchor" href="#广播"></a> 广播</h3>
<p>广播意味着一对多的通信，一个主机向互联网中的所有主机发送分组。由于这种方式可能造成很大的通信量并占用大量带宽，因特网层次上没有提供广播功能。但是因特网中完成了部分广播，例如一些P2P应用或者受控广播。</p>
<h2 id="多播地址"><a class="markdownIt-Anchor" href="#多播地址"></a> 多播地址</h2>
<p>一个多播地址定义了一组接收者，它相当于是多播组的一个标识符。因此，如果一台主机是n个多播组的成员，那么它实际上有n+1个地址，包括一个单播地址以及n个多播地址。</p>
<p>在IPv4中，多播地址属于一大块地址，它们按此目的而特别设计。在分类寻址中，所有D类地址为多播地址；在无类寻址中，块224.0.0.0/4（即224.0.0.0到239.255.255.255）为多播地址块。</p>
<p>多播地址块中的地址数目很多，因此一个块被划分为多个子块，每个子块用于特定的多播应用。下面是一些公共子块：</p>
<ul>
<li>本地网络控制块：即子块224.0.0.0/24，它被分配给用于网络内部的多播路由选择协议，因此这个范围内目的地址的分组不能被路由器转发。其中地址224.0.0.0被保留，224.0.0.1用于将数据报发送到网络内的所有主机和路由器，224.0.0.2用于将数据报发送到网络内的所有路由器，剩余地址被分配给某些多播协议用于通信。</li>
<li>因特网控制块：即子块224.0.1.0/24，它被分配给用于整个互联网的多播路由选择协议。带有这个范围内目的地址的分组可以被路由器转发。</li>
<li>特定源多播块：即子块232.0.0.0/8，它被用于特定源多播协议。</li>
<li>团块：即子块233.0.0.0/8，它定义了可以用于自治系统内部的地址范围。</li>
<li>管理范围块：即子块239.0.0.0/8，这个块的地址用于因特网的特定区域。如果分组的目的地址属于这个范围，那么它不应该离开这个区域。</li>
</ul>
<h2 id="因特网组管理协议"><a class="markdownIt-Anchor" href="#因特网组管理协议"></a> 因特网组管理协议</h2>
<p>因特网组管理协议（Internet Group Management Protocol, IGMP）被用于收集组成员信息，从而创建多播路由的转发表。IGMP是定义在网络层的协议，它是一个辅助协议，属于IP的一部分。IGMP的报文需要封装在IP数据报中进行传播，分为查询和报告报文。</p>
<p>查询报文周期性地由路由器发送给所有连接其上的主机，让哥主机报告它们对于组内成员身份的兴趣。查询报文有三种形式：</p>
<ul>
<li>普通查询报文：查询任意组中成员身份。它被封装在数据报中，目的端地址为244.0.0.1（所有主机和路由器）。所有连接到同一个网络的路由器都接收到这个报文，并且应该抑制重发。</li>
<li>特定组查询报文：从路由器发送，查询与特定组相关的成员。当路由器没有接收到特定组的响应，并且向确定网络中哪个组没有活跃成员时，就发送这个报文。报文被封装在数据报中，目的地址为相应的多播地址。所有主机都接收这个报文，但是不感兴趣的可以丢弃它。</li>
<li>特定源和目的查询报文：当报文来自一个或多个特定源端时，这个报文可以寻找与特定组相关的成员。当路由器没有收到与一个或多个特定主机相关的特定组时，这个报文被再次发送。报文被封装在数据报中，目的地址为相应的多播地址。所有主机都接收这个报文，但是不感兴趣的可以丢弃它。</li>
</ul>
<p>报告报文是查询报文的响应。报文包含记录列表，其中每条记录给出相应组的标识符（多播地址）以及所有主机感兴趣的源地址。报文被封装在数据报中，多播地址为224.0.0.22。</p>
<h2 id="多播转发"><a class="markdownIt-Anchor" href="#多播转发"></a> 多播转发</h2>
<h3 id="与单播转发的不同"><a class="markdownIt-Anchor" href="#与单播转发的不同"></a> 与单播转发的不同</h3>
<p>在多播通信中，分组的目的端定义了一个组，因此为了到达所有的目的端，路由器可能必须从一个以上的端口发出分组。同时，多播通信的转发决定取决于分组的目的地址和源地址，这样是为了避免分组重复发送。</p>
<h3 id="基于源树方法"><a class="markdownIt-Anchor" href="#基于源树方法"></a> 基于源树方法</h3>
<p>在基于源树方法中，每个路由器需要为每个源端与组的组合创建一个单独的树。也就是说，如果互联网中有m个组和n个源端，那么路由器需要创建m*n个路由选择树。在每颗树中，相应的源端是根结点，组的成员是叶结点。</p>
<h3 id="组共享树方法"><a class="markdownIt-Anchor" href="#组共享树方法"></a> 组共享树方法</h3>
<p>在组共享树方法中，我们将一个路由器指派为每个组的伪源端。被指派的这个路由器称为核心路由器或者会合点路由器，它代表了这个组。任何源端如果要将分组发送到那个组，那么它直接将分组发送给这个核心路由器，核心路由器负责多播。</p>
<p>通过这种方法，从源端到所有组成员的多播传递分成了两部分，第一部分是从源端到核心路由器的单播传递，第二部分是从核心路由器到所有组成员的传递。这一使得路由选择树的数目大大减少，但是需要使用算法从所有路由器中选择组的核心路由器。</p>
<h2 id="域内路由选择协议"><a class="markdownIt-Anchor" href="#域内路由选择协议"></a> 域内路由选择协议</h2>
<h3 id="多播距离向量"><a class="markdownIt-Anchor" href="#多播距离向量"></a> 多播距离向量</h3>
<p>距离向量多播选择协议（Distance Vector Multicast Routing Protocol, DVMRP）是用于单播路由选择的路由选择信息协议（RIP）的拓展，它使用基于源树的方法来多播。它按照以下三步创建一个基于源端的多播树：</p>
<ol>
<li>使用逆路径转发算法来创建源端和自身之间的一部分最优基于源端的树。这种算法迫使路由器从一个特定接口转发多播分组，这个接口穿过最短路径从源端到达路由器。</li>
<li>使用逆路径广播算法创建广播（生成）树，根结点是路由器自身，叶结点是互联网中的所有网络。这一算法通过对树进行剪枝，从而防止每个网络接收一个以上的分组副本。</li>
<li>使用逆路径多播算法，对树进行剪枝，从而得到多播树。这种方法是对路由器中无法到达组中活跃成员的路径进行修剪，可以通过自底向上的方式来完成。</li>
</ol>
<h3 id="多播链路状态"><a class="markdownIt-Anchor" href="#多播链路状态"></a> 多播链路状态</h3>
<p>多播开放最短路径优先（Multicast Open Shortest Path First, MOSPF）是开放最短路径优先（OSPF）协议的扩展。它也使用基于源树的方法进行多播操作。路由器对于多播分组的转发过程如下：</p>
<ol>
<li>路由器使用Dijkstra算法创建一个最短路径树，源端为根节点，且互联网的目的端是叶结点。对于每个源端，需要创建一个不同的树。</li>
<li>路由器使用与DVMRP中描述的类似策略来修剪广播树，使其成为一棵多播树。</li>
<li>路由器只从那些相当于多播树分支的端口中转发接收到的分组。</li>
</ol>
<h3 id="协议独立多播"><a class="markdownIt-Anchor" href="#协议独立多播"></a> 协议独立多播</h3>
<p>协议独立多播（Protocol Independent Multicast, PIM）需要使用单播路由选择协议的转发表来找到去往目的端的下一跳路由器。它可以按两种模式工作：密集模式和稀疏模式，密集指的是互联网中组内活跃成员的数量较大，稀疏指的是路由器拥有组内成员的可能性低。当其在密集模式下工作时，称为PIM-DM，而在稀疏模式下工作时称为PIM-SM。</p>
<h2 id="域间路由选择协议"><a class="markdownIt-Anchor" href="#域间路由选择协议"></a> 域间路由选择协议</h2>
<p>当组的成员分布在不同域时，需要使用域间多播路由选择协议。</p>
<p>一个常见的协议为多播边界网关协议（Multicast Border Gateway Protocol, MBGP），它是BGP协议的扩展。MBGP提供了AS间的两条路径，一条用来单播，一条用来多播。它属于组共享多播路由选择协议，需要在每个AS中选定一个路由器作为会合点。MBGP协议的问题是它很难向会合点通知另一个AS中组的源端，因此引入多播源发现协议（Multicast Source Discovery Protocol, MSDP）来解决这个问题。</p>
<p>另一个替代的协议是边界网关多播协议（Border Gateway Multicast Protocol, BGMP），它允许在一个AS中建立带有一个根的组共享树。也就是说，对于每个组，只有一个组共享树，叶结点在其他的AS中，但是根节点位于其中一个AS中。</p>
<h1 id="下一代ip"><a class="markdownIt-Anchor" href="#下一代ip"></a> 下一代IP</h1>
<h2 id="简介-5"><a class="markdownIt-Anchor" href="#简介-5"></a> 简介</h2>
<p>因特网协议第六版（Internet Protocol version 6, IPv6）在增加了IPv4地址空间的同时，重新设计了IP分组的格式并修改了一些辅助协议。下面是IPv6协议的主要变化：</p>
<ul>
<li>更大的地址空间：IPv6地址为128位长</li>
<li>更好的头部格式：IPv6使用了新的头部格式，其选项与基本头部分开，如果需要可将选项插入到基本头部和上层数据之间。这样简化和加速了路由选择过程。</li>
<li>新的选项：IPv6提供了新的选项来实现附加的功能。</li>
<li>允许扩展：如果新的技术或应用需要的话，IPv6允许协议进行扩展。</li>
<li>支持资源分配：IPv6取消了服务类型字段，但是增加了流标号使得源端可以请求对分组进行特殊的处理。</li>
<li>支持更多安全性：提供了加密和鉴别选项。</li>
</ul>
<h2 id="分组格式"><a class="markdownIt-Anchor" href="#分组格式"></a> 分组格式</h2>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132213.png" alt="IPv6报文" /></p>
<p>IPv6的一个分组由基本头部和紧跟其后的有效载荷组成。头部字段的包括：</p>
<ul>
<li>版本：定义了IP版本号，对于IPv6的值为6。</li>
<li>流量类：用来区分不同传递要求的不同有效载荷，代替了IPv4中的服务类型字段。</li>
<li>流标号：一个20位的字段，用来对特殊的数据流提供专门处理。</li>
<li>有效载荷长度：一个16位字段，定义了不包括基本头部的IP数据报的总长度。</li>
<li>下一个头部：一个8位字段，定义了第一个扩展头部的类型或是数据报中跟随在基本头部之后的头部。</li>
<li>跳数限制：与IPv4中的TTL字段作用相同。</li>
<li>源地址和目的地址：用于识别数据报的源端和目的端。</li>
<li>有效载荷：开头是0个或者多个扩展头部的组合，接着是来自于其他协议的数据。每个扩展头部有两个强制字段：下一个头部和长度。</li>
</ul>
<h2 id="ipv6寻址"><a class="markdownIt-Anchor" href="#ipv6寻址"></a> IPv6寻址</h2>
<h3 id="地址格式"><a class="markdownIt-Anchor" href="#地址格式"></a> 地址格式</h3>
<p>IPv6地址一般用冒号16进制来表示，整个地址被分为8个部分，每个部分由4个十六进制数字组成，每4个数字用一个冒号隔开。由于IPv6地址很长，为了简化表示，在IPv6地址中，一个部分开头的0可以省略不写；如果有连续的部分仅仅包含0，则可以使用0压缩（一个地址只能使用一次），将所有的0移除，用两个冒号代替。</p>
<h3 id="地址类型-2"><a class="markdownIt-Anchor" href="#地址类型-2"></a> 地址类型</h3>
<p>IPv6的目的地址分为三类：单播、任播和多播。它没有定义广播，IPv6将其看作是多播的特殊情况。单播和多播与IPv4相同，任播指的是一组计算机共享一个地址，带有任播地址的分组只被传递到组中最容易到达的那个成员。</p>
<h3 id="地址空间分配"><a class="markdownIt-Anchor" href="#地址空间分配"></a> 地址空间分配</h3>
<p>IPv6的地址空间也被分成大小不同的块，其中绝大多数块是未指派的。已分配的块如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">块前缀</th>
<th style="text-align:center">块任务</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0000 0000</td>
<td style="text-align:center">特殊地址</td>
</tr>
<tr>
<td style="text-align:center">001</td>
<td style="text-align:center">全局单播</td>
</tr>
<tr>
<td style="text-align:center">1111 110</td>
<td style="text-align:center">唯一本地单播</td>
</tr>
<tr>
<td style="text-align:center">1111 1110 10</td>
<td style="text-align:center">链路本地地址</td>
</tr>
<tr>
<td style="text-align:center">1111 1111</td>
<td style="text-align:center">多播地址</td>
</tr>
</tbody>
</table>
<h3 id="特殊地址-2"><a class="markdownIt-Anchor" href="#特殊地址-2"></a> 特殊地址</h3>
<ul>
<li>未指明地址：0000::/128，在启动时使用，此时主机不知道自己的地址并想发送查询找出其地址。</li>
<li>环回地址：0000::1/128，IPv6中仅仅有这一个环回地址。</li>
<li>兼容地址：0000::/96，96个0后面紧跟32位IP地址，用于IPv4向IPv6的过渡。</li>
<li>映射地址：0000::FFFF/96，已经过渡到IPv6的计算机发送报文给使用IPv4的计算机时使用。</li>
</ul>
<h2 id="ipv4到ipv6的过渡"><a class="markdownIt-Anchor" href="#ipv4到ipv6的过渡"></a> IPv4到IPv6的过渡</h2>
<ul>
<li>双协议栈：网络层同时运行IPv4和IPv6，直到整个因特网使用IPv6。当把分组发送到目的端时，主机需要向DNS查询使用的是哪个版本。</li>
<li>隧道技术：当两台使用IPv6的计算机要进行通信，但其分组要经过使用IPv4的区域时，需要使用这种技术。进入这种区域时，IPv6分组要封装成IPv4分组，离开这个区域时再去掉封装。</li>
<li>头部转换：如果发送方使用IPv6，接收方使用IPv4时，需要使用这种技术。此时头部格式需要转换成IPv4的头部。</li>
</ul>
<h2 id="icmpv6"><a class="markdownIt-Anchor" href="#icmpv6"></a> ICMPv6</h2>
<p>ICMPv6与ICMPv4具有相同的策略和目的，但是ICMPv6中，ICMP、ARP和IGMP三个协议被整合到一起，并且加入了一些新的报文使其更加实用。</p>
<p>ICMPv6的报文分为下图所示的四种。相比于ICMPv4，差错报告报文和信息报文中的一些报文被取消，邻居发现报文完成了ARP的工作，而组成员关系报文完成了IGMP的工作。</p>
<p><img data-src="https://raw.githubusercontent.com/lyf35/blog_figures/main/img/20201227132220.png" alt="ICMPv6报文" /></p>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ol>
<li>计算机网络：自顶向下方法</li>
</ol>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Yufei Luo
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://lyf35.github.io/2020/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/" title="计算机网络-网络层">http://lyf35.github.io/2020/11/15/计算机网络-网络层/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> 计算机基础</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"><i class="fa fa-tag"></i> 计算机网络</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" rel="prev" title="计算机网络-数据链路层">
      <i class="fa fa-chevron-left"></i> 计算机网络-数据链路层
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/11/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/" rel="next" title="机器学习-集成学习">
      机器学习-集成学习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yufei Luo</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">936k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">14:11</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动
  </div>

        






<script data-pjax>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"ypNNXSdcGIIoldC5BBmViS2g-gzGzoHsz","app_key":"0TDwohU7eO4yHTn4tley8PtE","server_url":"https://leancloud.cn/dashboard/data.html?appid=ypNNXSdcGIIoldC5BBmViS2g-gzGzoHsz#/","security":false};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="//cdn.jsdelivr.net/npm/ribbon.js@1/dist/ribbon.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/next-theme/pjax@0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  
  <script data-pjax>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>









<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>


    <div class="pjax">
  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">
  <script src="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css">


  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4dcdc02d24075b0e9d3a',
      clientSecret: '53cf2cb8b89b9d4bba922bb19bda1290f0d0bf95',
      repo        : 'lyf35.github.io',
      owner       : 'lyf35',
      admin       : ['lyf35'],
      id          : 'da87d64e5262ebb960b88a0b6f3ddafa',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
