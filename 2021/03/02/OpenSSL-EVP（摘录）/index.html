<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">
  <link rel="manifest" href="/images/site.webmanifest">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Helvetica:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-flat-top.min.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lyf35.github.io","root":"/","scheme":"Pisces","version":"8.0.0-rc.5","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="注：本文内容摘自参考部分的相关资料  简介 Openssl EVP(high-level cryptographic functions[1])提供了丰富的密码学中的各种函数。Openssl 中实现了各种对称算法、摘要算法以及签名&#x2F;验签算法。EVP 函数将这些具体的算法进行了封装。 官方建议使用这些算法时最好调用EVP的上层封装，不建议单独使用某个算法。 EVP系列的函数的声明包含在”evp.h”">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenSSL-EVP（摘录）">
<meta property="og:url" content="http://lyf35.github.io/2021/03/02/OpenSSL-EVP%EF%BC%88%E6%91%98%E5%BD%95%EF%BC%89/index.html">
<meta property="og:site_name" content="Yufei Luo&#39;s Blog">
<meta property="og:description" content="注：本文内容摘自参考部分的相关资料  简介 Openssl EVP(high-level cryptographic functions[1])提供了丰富的密码学中的各种函数。Openssl 中实现了各种对称算法、摘要算法以及签名&#x2F;验签算法。EVP 函数将这些具体的算法进行了封装。 官方建议使用这些算法时最好调用EVP的上层封装，不建议单独使用某个算法。 EVP系列的函数的声明包含在”evp.h”">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-02T15:42:45.753Z">
<meta property="article:modified_time" content="2021-03-02T15:42:45.753Z">
<meta property="article:author" content="Yufei Luo">
<meta property="article:tag" content="信息安全">
<meta property="article:tag" content="OpenSSL">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://lyf35.github.io/2021/03/02/OpenSSL-EVP%EF%BC%88%E6%91%98%E5%BD%95%EF%BC%89/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>OpenSSL-EVP（摘录） | Yufei Luo's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
 <!--   <div class="headband"></div>-->

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Yufei Luo's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">But I was so much older then, I am younger than that now.</p>
      <img class="custom-logo-image" src="/images/logo.png" alt="Yufei Luo's Blog">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text"> 简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text"> 源码结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text"> 全局函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bio%E6%89%A9%E5%85%85"><span class="nav-number">2.2.</span> <span class="nav-text"> BIO扩充</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95%E5%B0%81%E8%A3%85"><span class="nav-number">2.3.</span> <span class="nav-text"> 摘要算法封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E7%AE%97%E6%B3%95%E5%B0%81%E8%A3%85"><span class="nav-number">2.4.</span> <span class="nav-text"> 对称算法封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E7%AE%97%E6%B3%95%E5%B0%81%E8%A3%85"><span class="nav-number">2.5.</span> <span class="nav-text"> 非对称算法封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%8F%A3%E4%BB%A4%E7%9A%84%E5%8A%A0%E5%AF%86"><span class="nav-number">2.6.</span> <span class="nav-text"> 基于口令的加密</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%87%BD%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text"> 主要函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.</span> <span class="nav-text"> 对称加解密函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.</span> <span class="nav-text"> 其他函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="nav-number">4.</span> <span class="nav-text"> 对称加密</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.</span> <span class="nav-text"> 基本数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#evp_cipher%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">4.1.1.</span> <span class="nav-text"> EVP_CIPHER结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#evp_cipher_ctx%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">4.1.2.</span> <span class="nav-text"> EVP_CIPHER_CTX结构体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.</span> <span class="nav-text"> 相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.1.</span> <span class="nav-text"> 核心函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.1.1.</span> <span class="nav-text"> 底层函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86"><span class="nav-number">4.2.1.2.</span> <span class="nav-text"> 加密</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%AF%86"><span class="nav-number">4.2.1.3.</span> <span class="nav-text"> 解密</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.2.</span> <span class="nav-text"> 辅助函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9Cevp_cipher_ctx%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.2.1.</span> <span class="nav-text"> 操作EVP_CIPHER_CTX的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E4%B8%8E%E8%8E%B7%E5%8F%96"><span class="nav-number">4.2.2.2.</span> <span class="nav-text"> 参数设置与获取</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.3.</span> <span class="nav-text"> 算法函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.2.3.1.</span> <span class="nav-text"> 分组加密的迭代模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="nav-number">4.2.3.2.</span> <span class="nav-text"> 加密算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">4.3.</span> <span class="nav-text"> 应用流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B"><span class="nav-number">4.4.</span> <span class="nav-text"> 程序示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%91%98%E8%A6%81"><span class="nav-number">5.</span> <span class="nav-text"> 摘要</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2"><span class="nav-number">5.1.</span> <span class="nav-text"> 基本数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#evp_md%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">5.1.1.</span> <span class="nav-text"> EVP_MD结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#evp_md_ctx%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">5.1.2.</span> <span class="nav-text"> EVP_MD_CTX结构体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-2"><span class="nav-number">5.2.</span> <span class="nav-text"> 相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0-2"><span class="nav-number">5.2.1.</span> <span class="nav-text"> 核心函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0-2"><span class="nav-number">5.2.2.</span> <span class="nav-text"> 辅助函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9Cevp_md_ctx%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.2.1.</span> <span class="nav-text"> 操作EVP_MD_CTX的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E4%B8%8E%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.2.2.</span> <span class="nav-text"> 参数设置与获取函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.2.3.</span> <span class="nav-text"> 摘要算法函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-2"><span class="nav-number">5.3.</span> <span class="nav-text"> 程序示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="nav-number">6.</span> <span class="nav-text"> 非对称加密</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3"><span class="nav-number">6.1.</span> <span class="nav-text"> 基本数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-3"><span class="nav-number">6.2.</span> <span class="nav-text"> 相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0-3"><span class="nav-number">6.2.1.</span> <span class="nav-text"> 核心函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86-2"><span class="nav-number">6.2.1.1.</span> <span class="nav-text"> 加密</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%AF%86-2"><span class="nav-number">6.2.1.2.</span> <span class="nav-text"> 解密</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0-3"><span class="nav-number">6.2.2.</span> <span class="nav-text"> 辅助函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-3"><span class="nav-number">6.3.</span> <span class="nav-text"> 程序示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">6.3.1.</span> <span class="nav-text"> 参数初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90"><span class="nav-number">6.3.2.</span> <span class="nav-text"> 密钥生成</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#base64%E7%BC%96%E8%A7%A3%E7%A0%81"><span class="nav-number">7.</span> <span class="nav-text"> BASE64编解码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">7.1.</span> <span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4"><span class="nav-number">7.2.</span> <span class="nav-text"> 基本数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-4"><span class="nav-number">7.3.</span> <span class="nav-text"> 相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0-4"><span class="nav-number">7.3.1.</span> <span class="nav-text"> 核心函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A0%81"><span class="nav-number">7.3.1.1.</span> <span class="nav-text"> 编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E7%A0%81"><span class="nav-number">7.3.1.2.</span> <span class="nav-text"> 解码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0-4"><span class="nav-number">7.3.2.</span> <span class="nav-text"> 辅助函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-4"><span class="nav-number">7.4.</span> <span class="nav-text"> 程序示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hmac"><span class="nav-number">8.</span> <span class="nav-text"> HMAC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5"><span class="nav-number">8.1.</span> <span class="nav-text"> 基本数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-5"><span class="nav-number">8.2.</span> <span class="nav-text"> 相关函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-5"><span class="nav-number">8.3.</span> <span class="nav-text"> 程序示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90"><span class="nav-number">8.3.1.</span> <span class="nav-text"> 生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81"><span class="nav-number">8.3.2.</span> <span class="nav-text"> 验证</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="nav-number">9.</span> <span class="nav-text"> 数字签名</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AD%BE%E5%90%8D"><span class="nav-number">9.1.</span> <span class="nav-text"> 签名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A4%E8%AF%81"><span class="nav-number">9.2.</span> <span class="nav-text"> 认证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%87%E6%B3%A8"><span class="nav-number">9.3.</span> <span class="nav-text"> 备注</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-6"><span class="nav-number">9.4.</span> <span class="nav-text"> 程序示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%BE%E5%90%8D-2"><span class="nav-number">9.4.1.</span> <span class="nav-text"> 签名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81-2"><span class="nav-number">9.4.2.</span> <span class="nav-text"> 验证</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E4%BF%A1%E5%B0%81"><span class="nav-number">10.</span> <span class="nav-text"> 数字信封</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E4%BF%A1"><span class="nav-number">10.1.</span> <span class="nav-text"> 写信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E4%BF%A1"><span class="nav-number">10.2.</span> <span class="nav-text"> 读信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">10.3.</span> <span class="nav-text"> 代码示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E4%BF%A1-2"><span class="nav-number">10.3.1.</span> <span class="nav-text"> 写信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E4%BF%A1-2"><span class="nav-number">10.3.2.</span> <span class="nav-text"> 读信</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">11.</span> <span class="nav-text"> 参考</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yufei Luo"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Yufei Luo</p>
  <div class="site-description" itemprop="description">一个材料专业毕业的野生程序员的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x5ZjM1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lyf35"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmx5ZjEyMzQwMDAwMDBAMTYzLmNvbQ==" title="E-Mail → mailto:lyf1234000000@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



      </section>
        <div class="back-to-top animated">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x5ZjM1" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lyf35.github.io/2021/03/02/OpenSSL-EVP%EF%BC%88%E6%91%98%E5%BD%95%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Yufei Luo">
      <meta itemprop="description" content="一个材料专业毕业的野生程序员的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yufei Luo's Blog">
    </span>

    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          OpenSSL-EVP（摘录）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-02 23:42:45" itemprop="dateCreated datePublished" datetime="2021-03-02T23:42:45+08:00">2021-03-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">信息安全</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/OpenSSL/" itemprop="url" rel="index"><span itemprop="name">OpenSSL</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/OpenSSL/%E6%91%98%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">摘录</span></a>
                </span>
            </span>

          
            <span id="/2021/03/02/OpenSSL-EVP%EF%BC%88%E6%91%98%E5%BD%95%EF%BC%89/" class="post-meta-item leancloud_visitors" data-flag-title="OpenSSL-EVP（摘录）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>42k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>38 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>注：本文内容摘自参考部分的相关资料</p>
<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<p>Openssl EVP(high-level cryptographic functions[1])提供了丰富的密码学中的各种函数。Openssl 中实现了各种对称算法、摘要算法以及签名/验签算法。EVP 函数将这些具体的算法进行了封装。 官方建议使用这些算法时最好调用EVP的上层封装，不建议单独使用某个算法。</p>
<p>EVP系列的函数的声明包含在”evp.h”里面，这是一系列封装了openssl加密库里面所有算法的函数。通过这样的统一的封装，使得只需要在初始化参数的时候做很少的改变，就可以使用相同的代码但采用不同的加密算法进行数据的加密和解密。</p>
<p>EVP系列函数主要封装了<strong>加密、摘要、编码</strong>三大类型的算法，使用算法前需要调用OpenSSL_add_all_algorithms函数。</p>
<p>其中以<strong>加密算法与摘要算法</strong>为基本，公开密钥算法是对数据加密采用了对称加密算法，对密钥采用非对称加密（公钥加密，私钥解密）。数字签名是非对称算法（私钥签名，公钥认证）。</p>
<a id="more"></a>
<p>EVP封装的功能函数有：</p>
<ul>
<li>实现了base64编解码BIO；</li>
<li>实现了加解密BIO；</li>
<li>实现了摘要BIO；</li>
<li>实现了reliable BIO；</li>
<li>封装了摘要算法；</li>
<li>封装了对称加解密算法；</li>
<li>封装了非对称密钥的加密(公钥)、解密(私钥)、签名与验证以及辅助函数；</li>
<li>基于口令的加密(PBE)；</li>
<li>对称密钥处理；</li>
<li>数字信封：数字信封用对方的公钥加密对称密钥，数据则用此对称密钥加密。发送给对方时，同时发送对称密钥密文和数据密文。接收方首先用自己的私钥解密密钥密文，得到对称密钥，然后用它解密数据。</li>
<li>其他辅助函数。</li>
</ul>
<h1 id="源码结构"><a class="markdownIt-Anchor" href="#源码结构"></a> 源码结构</h1>
<p>evp源码位于crypto/evp目录，可以分为如下几类：</p>
<h2 id="全局函数"><a class="markdownIt-Anchor" href="#全局函数"></a> 全局函数</h2>
<p>主要包括 c_allc.c、c_alld.c、c_all.c 以及names.c。他们加载openssl  支持的所有的对称算法和摘要算法，放入到哈希表中。实现了OpenSSL_add_all_digests、OpenSSL_add_all_ciphers  以及OpenSSL_add_all_algorithms(调用了前两个函数)函数。在进行计算时，用户也可以单独加载摘要函数（EVP_add_digest）和对称计算函数（EVP_add_cipher）。</p>
<h2 id="bio扩充"><a class="markdownIt-Anchor" href="#bio扩充"></a> BIO扩充</h2>
<p>包括 bio_b64.c、bio_enc.c、bio_md.c 和bio_ok.c，各自实现了BIO_METHOD方法，分别用于base64 编解码、对称加解密以及摘要。</p>
<h2 id="摘要算法封装"><a class="markdownIt-Anchor" href="#摘要算法封装"></a> 摘要算法封装</h2>
<p>由 digest.c 实现，实现过程中调用了对应摘要算法的回调函数。各个摘要算法提供了自己的EVP_MD 静态结构，对应源码为m_xxx.c。</p>
<h2 id="对称算法封装"><a class="markdownIt-Anchor" href="#对称算法封装"></a> 对称算法封装</h2>
<p>由evp_enc.c 实现，实现过程调用了具体对称算法函数，实现了Update 操作。各种对称算法都提供了一个EVP_CIPHER  静态结构，对应源码为e_xxx.c。需要注意的是，e_xxx.c  中不提供完整的加解密运算，它只提供基本的对于一个block_size数据的计算，完整的计算由evp_enc.c  来实现。</p>
<p>想实现一个自己的对称算法时，可以参考e_xxx.c 的实现方式。一般至少需要实现如下功能：</p>
<ul>
<li>构造一个新的静态的 EVP_CIPHER 结构；</li>
<li>实现 EVP_CIPHER 结构中的init 函数，该函数用于设置iv，设置加解密标记、以及根据外送密钥生成自己的内部密钥；</li>
<li>实现 do_cipher 函数，该函数仅对block_size 字节的数据进行对称运算；</li>
<li>实现 cleanup 函数，该函数主要用于清除内存中的密钥信息。</li>
</ul>
<h2 id="非对称算法封装"><a class="markdownIt-Anchor" href="#非对称算法封装"></a> 非对称算法封装</h2>
<p>主要是以 p_开头的文件。其中，p_enc.c 封装了公钥加密；p_dec.c 封装了私钥解密；p_lib.c  实现一些辅助函数；p_sign.c 封装了签名函数；p_verify.c 封装了验签函数；p_seal.c 封装了数字信封；p_open.c  封装了解数字信封。</p>
<h2 id="基于口令的加密"><a class="markdownIt-Anchor" href="#基于口令的加密"></a> 基于口令的加密</h2>
<p>包括 p5_crpt2.c、p5_crpt.c 和evp_pbe.c。</p>
<h1 id="主要函数"><a class="markdownIt-Anchor" href="#主要函数"></a> 主要函数</h1>
<h2 id="对称加解密函数"><a class="markdownIt-Anchor" href="#对称加解密函数"></a> 对称加解密函数</h2>
<ul>
<li>EVP_BytesToKey：计算密钥函数，它根据算法类型、摘要算法、salt 以及输入数据计算出一个对称密钥和初始化向量iv。</li>
<li>PKCS5_PBE_keyivgen 和PKCS5_v2_PBE_keyivgen：实现了 PKCS5 基于口令生成密钥和初始化向量的算法。</li>
<li>PKCS5_PBE_add：加载所有 openssl 实现的基于口令生成密钥的算法。</li>
<li>EVP_PBE_alg_add：添加一个 PBE 算法。</li>
</ul>
<h2 id="其他函数"><a class="markdownIt-Anchor" href="#其他函数"></a> 其他函数</h2>
<ul>
<li>EVP_add_cipher：将对称算法加入到全局变量，以供调用。</li>
<li>EVP_add_digest：将摘要算法加入到全局变量中，以供调用。</li>
<li>EVP_CIPHER_CTX_ctrl：对称算法控制函数，它调用了用户实现的ctrl 回调函数。</li>
<li>EVP_CIPHER_CTX_set_key_length：当对称算法密钥长度为可变长时，设置对称算法的密钥长度。</li>
<li>EVP_CIPHER_CTX_set_padding：设置对称算法的填充，对称算法有时候会涉及填充。加密分组长度大于一时，用户输入数据不是加密分组的整数倍时，会涉及到填充。填充在最后一个分组来完成，openssl 分组填充时，如果有n 个填充，则将最后一个分组用n 来填满。</li>
<li>EVP_CIPHER_get_asn1_iv：获取原始iv，存放在ASN1_TYPE 结构中。</li>
<li>EVP_CIPHER_param_to_asn1：设置对称算法参数，参数存放在ASN1_TYPE 类型中，它调用用户实现的回调函数set_asn1_parameters 来实现。</li>
<li>EVP_CIPHER_type：获取对称算法的类型。</li>
<li>EVP_CipherInit/EVP_CipherInit_ex：对称算法计算(加/解密)初始化函数，_ex 函数多了硬件enginge 参数，EVP_EncryptInit 和EVP_DecryptInit 函数也调用本函数。</li>
<li>EVP_CipherUpdate：对称计算（加/解密）函数，它调用了EVP_EncryptUpdate 和EVP_DecryptUpdate函数。</li>
<li>EVP_CipherFinal/EVP_CipherFinal_ex：对称计算( 加/ 解) 函数， 调用了EVP_EncryptFinal(ex) 和EVP_DecryptFinal(ex)；本函数主要用来处理最后加密分组，可能会有对称计算。</li>
<li>EVP_cleanup：清除加载的各种算法，包括对称算法、摘要算法以及PBE 算法，并清除这些算法相关的哈希表的内容。</li>
<li>EVP_get_cipherbyname：根据字串名字来获取一种对称算法(EVP_CIPHER)，本函数查询对称算法哈希表。</li>
<li>EVP_get_digestbyname：根据字串获取摘要算法(EVP_MD)，本函数查询摘要算法哈希表。</li>
<li>EVP_get_pw_prompt：获取口令提示信息字符串.</li>
<li>int EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen,<br />
ASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de)：PBE 初始化函数。本函数用口令生成对称算法的密钥和初始化向量，并作加/解密初始化操作。本函数再加上后续的EVP_CipherUpdate 以及EVP_CipherFinal_ex构成一个完整的加密过程（可参考crypto/p12_decr.c 的PKCS12_pbe_crypt 函数）.</li>
<li>EVP_PBE_cleanup：删除所有的PBE 信息，释放全局堆栈中的信息.</li>
<li>EVP_PKEY *EVP_PKCS82PKEY(PKCS8_PRIV_KEY_INFO *p8)：将PKCS8_PRIV_KEY_INFO(x509.h 中定义)中保存的私钥转换为EVP_PKEY结构。</li>
<li>EVP_PKEY2PKCS8/EVP_PKEY2PKCS8_broken：将EVP_PKEY 结构中的私钥转换为PKCS8_PRIV_KEY_INFO 数据结构存储。</li>
<li>EVP_PKEY_bits：非对称密钥大小，为比特数。</li>
<li>EVP_PKEY_cmp_parameters：比较非对称密钥的密钥参数，用于DSA 和ECC 密钥。</li>
<li>EVP_PKEY_copy_parameters：拷贝非对称密钥的密钥参数，用于DSA 和ECC 密钥。</li>
<li>EVP_PKEY_free：释放非对称密钥数据结构。</li>
<li>EVP_PKEY_get1_DH/EVP_PKEY_set1_DH：获取/设置EVP_PKEY 中的DH 密钥。</li>
<li>EVP_PKEY_get1_DSA/EVP_PKEY_set1_DSA：获取/设置EVP_PKEY 中的DSA 密钥。</li>
<li>EVP_PKEY_get1_RSA/EVP_PKEY_set1_RSA：获取/设置EVP_PKEY 中结构中的RSA 结构密钥。</li>
<li>EVP_PKEY_missing_parameters：检查非对称密钥参数是否齐全，用于DSA 和ECC 密钥。</li>
<li>EVP_PKEY_new：生成一个EVP_PKEY 结构。</li>
<li>EVP_PKEY_size：获取非对称密钥的字节大小。</li>
<li>EVP_PKEY_type：获取EVP_PKEY 中表示的非对称密钥的类型。</li>
<li>int EVP_read_pw_string(char *buf,int length,const char *prompt,int verify)：获取用户输入的口令；buf 用来存放用户输入的口令，length 为buf 长度，prompt为提示给用户的信息，如果为空，它采用内置的提示信息，verify 为0 时，不要求验证用户输入的口令，否则回要求用户输入两遍。返回0 表示成功。</li>
<li>EVP_set_pw_prompt：设置内置的提示信息，用于需要用户输入口令的场合。</li>
</ul>
<h1 id="对称加密"><a class="markdownIt-Anchor" href="#对称加密"></a> 对称加密</h1>
<h2 id="基本数据结构"><a class="markdownIt-Anchor" href="#基本数据结构"></a> 基本数据结构</h2>
<p>EVP_CIPHER与EVP_CIPHER_CTX两个基本结构，加密函数EVP_Encrypt(EVP_Cipher)一些列函数都是以这两个结构为基础实现了。文件evp_enc.c是最高层的封装实现，，而各个e_*.c文件则是真正实现了各种算法的加解密功能，当然它们其实也是一些封装函数，真正的算法实现在各个算法同名目录里面的文件实现。</p>
<p>注意:  EVP_CIPHER是、EVP_CIPHER_CTX的成员，在加密时通过指定的加密算法（其实就是加密函数），返回对应的EVP_CIPHER的指针，然后EVP_EncryptInit函数中 调用 EVP_CIPHER来初化EVP_CIPHER_CTX。</p>
<h3 id="evp_cipher结构体"><a class="markdownIt-Anchor" href="#evp_cipher结构体"></a> EVP_CIPHER结构体</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">evp_cipher_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nid; <span class="comment">//是算法类型的nid识别号，openssl里面每个对象都有一个内部唯一的识别ID</span></span><br><span class="line">    <span class="keyword">int</span> block_size;        <span class="comment">//是每次加密的数据块的长度，以字节为单位</span></span><br><span class="line">    <span class="keyword">int</span> key_len;           <span class="comment">//是每次加密的数据块的长度，以字节为单位</span></span><br><span class="line">    <span class="keyword">int</span> iv_len;            <span class="comment">//初始化向量的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;   <span class="comment">//标志位</span></span><br><span class="line">    <span class="keyword">int</span> (*init)(EVP_CIPHER_CTX *ctx, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv, <span class="keyword">int</span> enc); <span class="comment">//算法结构初始化函数，可以设置为加密模式还是解密模式</span></span><br><span class="line">    <span class="keyword">int</span> (*do_cipher)(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">unsigned</span> <span class="keyword">int</span> inl);   <span class="comment">//进行数据加密或解密的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*cleanup)(EVP_CIPHER_CTX *);   <span class="comment">//释放EVP_CIPHER_CTX结构里面的数据和设置</span></span><br><span class="line">    <span class="keyword">int</span> ctx_size;  <span class="comment">//设定ctx-&gt;cipher_data数据的长度</span></span><br><span class="line">    <span class="keyword">int</span> (*set_asn1_parameters)(EVP_CIPHER_CTX *, ASN1_TYPE *);  <span class="comment">// 在EVP_CIPHER_CTX结构中通过参数设置一个ASN1_TYPE</span></span><br><span class="line">    <span class="keyword">int</span> (*get_asn1_parameters)(EVP_CIPHER_CTX *, ASN1_TYPE *);  <span class="comment">//从一个ASN1_TYPE中取得参数</span></span><br><span class="line">    <span class="keyword">int</span> (*ctrl)(EVP_CIPHER_CTX *, <span class="keyword">int</span> type, <span class="keyword">int</span> arg, <span class="keyword">void</span> *ptr); <span class="comment">//其它各种操作函数</span></span><br><span class="line">    <span class="keyword">void</span> *app_data;  <span class="comment">//应用数据</span></span><br><span class="line">&#125;EVP_CIPHER;</span><br></pre></td></tr></table></figure>
<h3 id="evp_cipher_ctx结构体"><a class="markdownIt-Anchor" href="#evp_cipher_ctx结构体"></a> EVP_CIPHER_CTX结构体</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">evp_cipher_ctx_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> EVP_CIPHER *cipher;  <span class="comment">//是该结构相关的一个EVP_CIPHER算法结构</span></span><br><span class="line">    ENGINE *engine;            <span class="comment">//如果加密算法是ENGINE提供的，那么该成员保存了相关的函数接口</span></span><br><span class="line">    <span class="keyword">int</span> encrypt;               <span class="comment">//加密或解密的标志</span></span><br><span class="line">    <span class="keyword">int</span> buf_len;               <span class="comment">//该结构缓冲区里面当前的数据长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> oiv[EVP_MAX_IV_LENGTH];      <span class="comment">//初始的初始化向量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> iv[EVP_MAX_IV_LENGTH];       <span class="comment">//工作时候使用的初始化向量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[EVP_MAX_BLOCK_LENGTH];   <span class="comment">//保存下来的部分需要数据</span></span><br><span class="line">    <span class="keyword">int</span> num;                   <span class="comment">//在cfb/ofb模式的时候指定块长度</span></span><br><span class="line">    <span class="keyword">void</span> *app_data;            <span class="comment">//应用程序要处理数据</span></span><br><span class="line">    <span class="keyword">int</span> key_len;               <span class="comment">//密钥长度，算法不一样长度也不一样</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags; </span><br><span class="line">    <span class="keyword">void</span> *cipher_data;         <span class="comment">//加密后的数据</span></span><br><span class="line">    <span class="keyword">int</span> final_used;</span><br><span class="line">    <span class="keyword">int</span> block_mask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">final</span>[EVP_MAX_BLOCK_LENGTH];<span class="comment">//</span></span><br><span class="line">&#125; EVP_CIPHER_CTX;</span><br></pre></td></tr></table></figure>
<h2 id="相关函数"><a class="markdownIt-Anchor" href="#相关函数"></a> 相关函数</h2>
<h3 id="核心函数"><a class="markdownIt-Anchor" href="#核心函数"></a> 核心函数</h3>
<p>EVP_crypt系列函数只是对EVP_Cipher系列函数的调用，EVP_Encrypt函数相当于对EVP_Cipher函数enc参数置为1，EVP_Decrypt函数相当于对EVP_Cipher函数enc参数置为0。</p>
<h4 id="底层函数"><a class="markdownIt-Anchor" href="#底层函数"></a> 底层函数</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旧版本</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CipherInit</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">const</span> EVP_CIPHER *cipher, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv, <span class="keyword">int</span> enc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CipherUpdate</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl,<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CipherFinal</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl)</span></span></span><br><span class="line"><span class="function"><span class="comment">//新版本</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CipherInit_ex</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">const</span> EVP_CIPHER *cipher, </span></span></span><br><span class="line"><span class="function"><span class="params">ENGINE *impl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key,<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv, <span class="keyword">int</span> enc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CipherUpdate</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CipherFinal_ex</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl)</span></span></span><br></pre></td></tr></table></figure>
<p>这三个函数是更底层的函数。完成了数据的加密和解密功能。他们根据参数enc决定执行加密还是解密操作，如果enc为1，则加密；如果enc为0，则解密；如果enc是－1，则不改变数据。<strong>函数都是操作成功返回1，否则返回0。</strong></p>
<p><strong>注意</strong>：两个版本中：EVP_EncryptInit, EVP_DecryptInit和EVP_CipherInit，这三个函数的功能分别跟函数EVP_EncryptInit_ex, EVP_DecryptInit_ex和EVP_CipherInit_ex功能相同，只是他们的ctx参数不需要进行初始化，并且使用缺省的算法库。EVP_EncryptFinal,  EVP_DecryptFinal和EVP_CipherFinal，这三个函数分别跟函数EVP_EncryptFinal_ex,EVP_DecryptFinal_ex以及EVP_CipherFinal_ex函数功能相同，不过，他们的参数ctx会在调用后自动释放。</p>
<h4 id="加密"><a class="markdownIt-Anchor" href="#加密"></a> 加密</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旧版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_EncryptInit</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">const</span> EVP_CIPHER *cipher, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_EncryptUpdate</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl,<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_EncryptFinal</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl)</span></span></span><br><span class="line"><span class="function"><span class="comment">//新版本</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_EncryptInit_ex</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">const</span> EVP_CIPHER *cipher, ENGINE *impl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key,<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv)</span> <span class="comment">//采用ENGINE参数impl的算法来设置并初始化加密结构体。其中ctx参数必须在调用之前被初始化完毕。如果参数impl为NULL，那么就会使用缺省的实现算法。参数key是用来加密的对称密钥，iv参数是初始化向量（如果需要的话）。在算法中真正使用的密钥长度和初始化密钥长度是根据算法来决定的（也就是传入的key或者iv长度可以是任意的，实际使用的数据取决于算法，不足会自动补上，超过会自动舍去）。在调用该函数进行初始化的时候，除了参数cipher之外，所有其它参数可以设置为NULL，留到以后调用其它函数的时候再提供</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_EncryptUpdate</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span> <span class="comment">//该函数执行对数据的加密。该函数加密从参数in输入的长度为inl的数据，并将加密好的数据写入到参数out里面去。可以通过反复调用该函数来处理一个连续的数据块</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_EncryptFinal_ex</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl)</span> <span class="comment">//该函数处理最后（Final）的一段数据。在函数在padding功能打开的时候（缺省）才有效，这时候它将剩余的最后的所有数据进行加密处理。该算法使用标志的块padding方式（AKA PKCS padding）， PKCS 填充（padding）标准是这样定义的，在被加密的数据后面加上n个值为n的字节，使得加密后的数据长度为加密块长度的整数倍。</span></span></span><br></pre></td></tr></table></figure>
<h4 id="解密"><a class="markdownIt-Anchor" href="#解密"></a> 解密</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旧版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DecryptInit</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">const</span> EVP_CIPHER *cipher, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DecryptUpdate</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DecryptFinal</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl)</span></span></span><br><span class="line"><span class="function"><span class="comment">//新版本</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DecryptInit_ex</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">const</span> EVP_CIPHER *cipher,</span></span></span><br><span class="line"><span class="function"><span class="params">ENGINE *impl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key， <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv)</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DecryptUpdate</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span>                    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DecryptFinal_ex</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl)</span></span></span><br></pre></td></tr></table></figure>
<p>上面这些函数对应于上一节中的加密函数，函数的参数要求与相应的加密函数相同。</p>
<h3 id="辅助函数"><a class="markdownIt-Anchor" href="#辅助函数"></a> 辅助函数</h3>
<h4 id="操作evp_cipher_ctx的函数"><a class="markdownIt-Anchor" href="#操作evp_cipher_ctx的函数"></a> 操作EVP_CIPHER_CTX的函数</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CIPHER_CTX_reset</span><span class="params">(EVP_CIPHER_CTX *c)</span>    <span class="comment">//重置EVP_CIPHER_CTX</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">EVP_CIPHER_CTX *<span class="title">EVP_CIPHER_CTX_new</span><span class="params">(<span class="keyword">void</span>)</span>       <span class="comment">//开辟EVP_CIPHER_CTX</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_CIPHER_CTX_free</span><span class="params">(EVP_CIPHER_CTX *ctx)</span>  <span class="comment">//销毁之前开辟的EVP_CIPHER_CTX</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_CIPHER_CTX_init</span><span class="params">(EVP_CIPHER_CTX *a)</span></span>; <span class="comment">//初始化一个EVP_CIPHER_CTX结构体   </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CIPHER_CTX_cleanup</span><span class="params">(EVP_CIPHER_CTX *a)</span></span>; <span class="comment">//清除一个EVP_CIPHER_CTX结构体中的所有信息，并释放该结构占用的所有内存</span></span><br></pre></td></tr></table></figure>
<h4 id="参数设置与获取"><a class="markdownIt-Anchor" href="#参数设置与获取"></a> 参数设置与获取</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_MAX_IV_LENGTH 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_MAX_BOLCK_LENGTH 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_MAX_KEY_LENGTH 64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_partially_overlapping</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr1, <span class="keyword">const</span> <span class="keyword">void</span> *ptr2, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CIPHER_CTX_set_padding</span><span class="params">(EVP_CIPHER_CTX *x, <span class="keyword">int</span> padding)</span></span>; <span class="comment">//设置是否采用填充功能，默认使用。将padding设置为0代表禁止</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CIPHER_CTX_set_key_length</span><span class="params">(EVP_CIPHER_CTX *x, <span class="keyword">int</span> keylen)</span></span>; <span class="comment">//设置EVP_CIPHER_CTX密钥长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CIPHER_CTX_ctrl</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">int</span> type, <span class="keyword">int</span> arg, <span class="keyword">void</span> *ptr)</span></span>; <span class="comment">//设置不同算法特定的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*这三个函数都根据给定的参数返回一个EVP_CIPHER结构。不同的是给定的参数分别是算法名称、算法的NID和一个ASN1_OBJECT结构。具体的算法名称、NID以及ASN1_OBJECT结构请参看object/object.h文件的定义。成功返回对应的EVP_CIPHER* ，失败返回NULL*/</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_CIPHER *<span class="title">EVP_get_cipherbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_get_cipherbynid(a) EVP_get_cipherbyname(OBJ_nid2sn(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_get_cipherbyobj(a) EVP_get_cipherbynid(OBJ_obj2nid(a))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面这组函数的参数为EVP_CIPHER类型变量*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_nid(e)              ((e)-&gt;nid) <span class="comment">//返回加密算法的nid</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_block_size(e)       ((e)-&gt;block_size) <span class="comment">//返回加密块长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_key_length(e)       ((e)-&gt;key_len) <span class="comment">//返回密钥长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_iv_length(e)        ((e)-&gt;iv_len) <span class="comment">//返回初始化向量长度，如果没有使用IV则返回0</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_flags(e)            ((e)-&gt;flags) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_mode(e)             ((e)-&gt;flags) &amp; EVP_CIPH_MODE) <span class="comment">//返回相应结构算法的加密模式</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CIPHER_type</span><span class="params">(<span class="keyword">const</span> EVP_CIPHER *ctx)</span></span>; <span class="comment">//返回算法类型，返回值为算法的NID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面这组函数的返回值与EVP_CIPHER*系列函数的返回值相同，只是函数参数为EVP_CIPHER_CTX类型变量*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_CTX_cipher(e)       ((e)-&gt;cipher) <span class="comment">//返回EVP_CIPHER_CTX结构里面的EVP_CIPHER结构</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_CTX_nid(e)          ((e)-&gt;cipher-&gt;nid) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_CTX_block_size(e)   ((e)-&gt;cipher-&gt;block_size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_CTX_key_length(e)   ((e)-&gt;key_len)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_CTX_iv_length(e)    ((e)-&gt;cipher-&gt;iv_len)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_CTX_get_app_data(e) ((e)-&gt;app_data)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_CTX_set_app_data(e,d) ((e)-&gt;app_data=(char *)(d))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_CTX_type(c)         EVP_CIPHER_type(EVP_CIPHER_CTX_cipher(c)) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_CTX_flags(e)        ((e)-&gt;cipher-&gt;flags)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_CTX_mode(e)         ((e)-&gt;cipher-&gt;flags &amp; EVP_CIPH_MODE)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CIPHER_param_to_asn1</span><span class="params">(EVP_CIPHER_CTX *c, ASN1_TYPE *type)</span></span>; <span class="comment">//设置算法结构的参数，该函数必须在所设置的算法结构使用之前调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CIPHER_asn1_to_param</span><span class="params">(EVP_CIPHER_CTX *c, ASN1_TYPE *type)</span></span>; <span class="comment">//用算法结构里面的值设置参数type的结构，其设置的内容由具体的算法决定。本函数应该在算法结构的基本算法类型已经设置了但是密钥还没有设置之前调用</span></span><br></pre></td></tr></table></figure>
<h3 id="算法函数"><a class="markdownIt-Anchor" href="#算法函数"></a> 算法函数</h3>
<p>openssl对称加密算法的格式都以函数形式提供，其实该函数返回一个该算法的结构体，其形式一般如下(evp.h 、e_···.c)：<br />
     <code>EVP_CIPHER* EVP_···(···代表加密算法的名称)(void)</code><br />
在openssl中，所有提供的对称加密算法长度都是固定的，有特别说明的除外。</p>
<h4 id="分组加密的迭代模式"><a class="markdownIt-Anchor" href="#分组加密的迭代模式"></a> 分组加密的迭代模式</h4>
<ul>
<li>ecb—电子密码本（Electronic Code Book)加密方式</li>
<li>cbc—加密块链接（Cipher Block Chaining）加密方式</li>
<li>cfb——加密反馈（Cipher Feedback）加密方式</li>
<li>ofb—输出反馈（Output Feedback）加密方式</li>
<li>ede—该加密算法采用了加密、解密、加密的方式，第一个密钥和最后一个密钥是相同的</li>
<li>ede3—该加密算法采用了加密、解密、加密的方式，但是三个密钥都不相同</li>
</ul>
<h4 id="加密算法"><a class="markdownIt-Anchor" href="#加密算法"></a> 加密算法</h4>
<p><strong>注意：下面这些加密算法函数调用时返回的都是对应EVP_CIPHER结构体指针</strong></p>
<ul>
<li>NULL算法：EVP_enc_null()，该算法不作任何事情，也就是没有进行加密处理</li>
<li>DES算法：EVP_des_cbc(void), EVP_des_ecb(void), EVP_des_cfb(void), EVP_des_ofb(void)</li>
<li>使用两个密钥的3DES算法：EVP_des_ede_cbc(void), EVP_des_ede(void), EVP_des_ede_ofb(void),EVP_des_ede_cfb(void)</li>
<li>使用三个密钥的3DES算法：EVP_des_ede3_cbc(void), EVP_des_ede3(void), EVP_des_ede3_ofb(void), EVP_des_ede3_cfb(void)</li>
<li>DESX算法：EVP_desx_cbc(void)</li>
<li>RC2算法：EVP_rc2_cbc(void), EVP_rc2_ecb(void), EVP_rc2_cfb(void), EVP_rc2_ofb(void) ，该算法密钥长度可变，缺省为128位</li>
<li>定长的RC2算法：EVP_rc2_40_cbc(void), EVP_rc2_64_cbc(void)</li>
<li>RC4算法：EVP_rc4(void) ，密钥长度可变，默认为128位</li>
<li>定长的RC4算法：EVP_rc4_40(void) ，密钥长度为40位</li>
<li>RC5算法：EVP_rc5_32_12_16_cbc(void), EVP_rc5_32_12_16_ecb(void), EVP_rc5_32_12_16_cfb(void), EVP_rc5_32_12_16_ofb(void)，密钥长度可以设置，默认128位。由于RC5算法本身实现代码的限制，加密次数只能设置为8、12或16。</li>
<li>IDEA算法：EVP_idea_cbc(void)，EVP_idea_ecb(void), EVP_idea_cfb(void), EVP_idea_ofb(void)</li>
<li>Blowfish算法：EVP_bf_cbc(void), EVP_bf_ecb(void), EVP_bf_cfb(void), EVP_bf_ofb(void)，密钥长度可变</li>
<li>CAST算法：EVP_cast5_cbc(void), EVP_cast5_ecb(void), EVP_cast5_cfb(void), EVP_cast5_ofb(void)，密钥长度可变</li>
<li>AES算法：
<ul>
<li>128位：EVP_aes_128_ecb(void)，EVP_aes_128_cbc(void)，PEVP_aes_128_cfb(void)，EVP_aes_128_ofb(void)</li>
<li>192位：EVP_aes_192_ecb(void)，EVP_aes_192_cbc(void)，PEVP_aes_192_cfb(void)，EVP_aes_192_ofb(void)</li>
<li>256位：EVP_aes_256_ecb(void)，EVP_aes_256_cbc(void)，PEVP_aes_256_cfb(void)，EVP_aes_256_ofb(void)</li>
</ul>
</li>
</ul>
<h2 id="应用流程"><a class="markdownIt-Anchor" href="#应用流程"></a> 应用流程</h2>
<p>一般来说，EVP_Encrypt…系列函数的应用流程如下所描述(不失一般性，以加密算法3DES为例)：</p>
<ol>
<li>
<p>定义一些所需的变量</p>
<p>一般情况下，输出数据缓冲区大小应该大于输入数据缓冲区。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> key[EVP_MAX_KEY_LENGTH];</span><br><span class="line"><span class="keyword">char</span> iv[EVP_MAX_IV_LENGTH];</span><br><span class="line">EVP_CIPHER_CTX ctx;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> out[<span class="number">512</span>+<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> outl;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>给变量key和IV赋值</p>
<p>可以借助函数<code>EVP_BytesToKey</code>来进行，如果有别的方法设定key和IV则该函数调用不是必须的</p>
</li>
<li>
<p>初始化加密算法结构EVP_CIPHER_CTX</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVP_EncryptInit_ex(&amp;ctx, EVP_des_ede3_cbc(), <span class="literal">NULL</span>, key, iv);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>进行数据加密操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (....)</span><br><span class="line">&#123;</span><br><span class="line">	EVP_EncryptUpdate(ctx,out,&amp;outl,in,inl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：EVP库的EVP_*Update系列函数调用一次就能处理完指针in中的inl个字节数据。<strong>这里所谓的循环是用于此类情景：每次收到若干字节放入指针in指向的缓冲区中，然后对其处理；或者每次从文件中读取若干字节到指针in所指缓冲区，再对其处理。<strong>如果输入的数据不是整数倍，则会留到EVP_*_CTX 中，等待下一次Update或EVP_Final*来处理</strong>，也就是</strong>循环是用于无法一次传入所有数据的情况</strong>，其他情况不需要使用循环。</p>
</li>
<li>
<p>结束加密，输出最后一段数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVP_EncryptFinal_ex(&amp;ctx, out, &amp;outl)</span><br></pre></td></tr></table></figure>
<p>该函数会进行加密检测，如果加密过程有误会被检测出来</p>
</li>
</ol>
<p>说明：解密过程与上述过程类似，只是要使用EVP_Decrypt···系列函数</p>
<h2 id="程序示例"><a class="markdownIt-Anchor" href="#程序示例"></a> 程序示例</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/conf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleErrors</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ERR_print_errors_fp(<span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">encrypt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* plaintext, <span class="keyword">int</span> plaintext_len, <span class="keyword">unsigned</span> <span class="keyword">char</span>* key, <span class="keyword">unsigned</span> <span class="keyword">char</span>* iv, <span class="keyword">unsigned</span> <span class="keyword">char</span>* ciphertext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        EVP_CIPHER_CTX* ctx;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">int</span> ciphertext_len;</span><br><span class="line">        <span class="keyword">if</span>(!(ctx=EVP_CIPHER_CTX_new()))</span><br><span class="line">                handleErrors();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>!=EVP_EncryptInit_ex(ctx,EVP_aes_256_cbc(),<span class="literal">NULL</span>,key,iv))</span><br><span class="line">                handleErrors();</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>!=EVP_EncryptUpdate(ctx,ciphertext,&amp;len,plaintext,plaintext_len))</span><br><span class="line">                handleErrors();</span><br><span class="line">        ciphertext_len=len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>!=EVP_EncryptFinal_ex(ctx,ciphertext+len,&amp;len))</span><br><span class="line">                handleErrors();</span><br><span class="line">        ciphertext_len+=len;</span><br><span class="line"></span><br><span class="line">        EVP_CIPHER_CTX_free(ctx);</span><br><span class="line">        <span class="keyword">return</span> ciphertext_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decrypt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* ciphertext, <span class="keyword">int</span> ciphertext_len, <span class="keyword">unsigned</span> <span class="keyword">char</span>* key, <span class="keyword">unsigned</span> <span class="keyword">char</span>* iv, <span class="keyword">unsigned</span> <span class="keyword">char</span>* plainte</span></span></span><br><span class="line"><span class="function"><span class="params">xt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        EVP_CIPHER_CTX* ctx;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">int</span> plaintext_len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!(ctx=EVP_CIPHER_CTX_new()))</span><br><span class="line">                handleErrors();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>!=EVP_DecryptInit_ex(ctx,EVP_aes_256_cbc(),<span class="literal">NULL</span>,key,iv))</span><br><span class="line">                handleErrors();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>!=EVP_DecryptUpdate(ctx,plaintext,&amp;len,ciphertext,ciphertext_len))</span><br><span class="line">                handleErrors();</span><br><span class="line">        plaintext_len=len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>!=EVP_DecryptFinal_ex(ctx,plaintext+len,&amp;len))</span><br><span class="line">                handleErrors();</span><br><span class="line">        plaintext_len+=len;</span><br><span class="line"></span><br><span class="line">        EVP_CIPHER_CTX_free(ctx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> plaintext_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>* key=(<span class="keyword">unsigned</span> <span class="keyword">char</span>*) <span class="string">&quot;01234567890123456789012345678901&quot;</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>* iv=(<span class="keyword">unsigned</span> <span class="keyword">char</span>*) <span class="string">&quot;0123456789012345&quot;</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>* plaintext=(<span class="keyword">unsigned</span> <span class="keyword">char</span>*) <span class="string">&quot;Hello OpenSSL! This a demonstration program about how to use EVP&quot;</span>; <span class="comment">//cbc模式下试着修改某一个字符，则会出现雪崩效应，密文出现很大差别；但是ofb和cfb却不会。（与这三种方式的计算顺序有关）</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> ciphertext[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> decryptedtext[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span> decryptedtext_len, ciphertext_len;</span><br><span class="line">        ciphertext_len=encrypt(plaintext,<span class="built_in">strlen</span>((<span class="keyword">char</span>*)plaintext),key,iv,ciphertext);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The ciphertext is:\n&quot;</span>);</span><br><span class="line">        BIO_dump_fp(<span class="built_in">stdout</span>,(<span class="keyword">const</span> <span class="keyword">char</span>*)ciphertext,ciphertext_len);</span><br><span class="line">        decryptedtext_len=decrypt(ciphertext,ciphertext_len,key,iv,decryptedtext);</span><br><span class="line">        decryptedtext[decryptedtext_len]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Decrypted text is:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,decryptedtext);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要用认证加密（防止CCA攻击），可以参考https://wiki.openssl.org/index.php/EVP_Authenticated_Encryption_and_Decryption</p>
<h1 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h1>
<p>该系列函数封装了openssl加密库所有的信息摘要算法，通过这种EVP封装，当使用不同的信息摘要算法时，只需要对初始化参数修改一下就可以了，其它代码可以完全一样。这些算法包括MD2、MD5以及SHA等算法。</p>
<ul>
<li>函数名称：EVP_Digest*…*</li>
<li>功能描述：该系列函数封装实现了多种信息摘要算法。</li>
<li>相关文件：digest.c,m_*.c</li>
</ul>
<h2 id="基本数据结构-2"><a class="markdownIt-Anchor" href="#基本数据结构-2"></a> 基本数据结构</h2>
<h3 id="evp_md结构体"><a class="markdownIt-Anchor" href="#evp_md结构体"></a> EVP_MD结构体</h3>
<p>所有的摘要算法都维护着指向下面定义的结构体的一个指针，在此基础上实现了算法的功能。该结构EVP_MD的源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opessl/evp.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">env_md_st</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> type;     <span class="comment">//信息摘要算法的NID标识</span></span><br><span class="line">    <span class="keyword">int</span> pkey_type;<span class="comment">//是信息摘要-签名算法体制的相应NID标识，如NID_shaWithRSAEncryption</span></span><br><span class="line">    <span class="keyword">int</span> md_size;  <span class="comment">//是信息摘要算法生成的信息摘要的长度，如SHA算法是SHA_DIGEST_LENGTH，该值是20</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">int</span> (*init)(EVP_MD_CTX *ctx); <span class="comment">//指向一个特定信息摘要算法的初始化函数，如对于SHA算法，指针指向SHA_Init</span></span><br><span class="line">    <span class="keyword">int</span> (*update)(EVP_MD_CTX *ctx,<span class="keyword">const</span> <span class="keyword">void</span> *data,<span class="keyword">unsigned</span> <span class="keyword">long</span> count); <span class="comment">//指向一个真正计算摘要值的函数，例如SHA算法就是指向SHA_Update</span></span><br><span class="line">    <span class="keyword">int</span> (*<span class="keyword">final</span>)(EVP_MD_CTX *ctx,<span class="keyword">unsigned</span> <span class="keyword">char</span> *md); <span class="comment">//指向一个信息摘要值计算之后要调用的函数，该函数完成最后的一块数据的处理工作。例如SHA算法就是指向SHA_Final.</span></span><br><span class="line">    <span class="keyword">int</span> (*copy)(EVP_MD_CTX *to,<span class="keyword">const</span> EVP_MD_CTX *from); <span class="comment">//指向一个可以在两个EVP_MD_CTX结构之间拷贝参数值的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*cleanup)(EVP_MD_CTX *ctx);</span><br><span class="line">    <span class="keyword">int</span> (*sign)();   <span class="comment">//签名</span></span><br><span class="line">    <span class="keyword">int</span> (*verify)(); <span class="comment">//认证</span></span><br><span class="line">    <span class="keyword">int</span> required_pkey_type[<span class="number">5</span>]; <span class="comment">//指向一个用来签名的算法EVP_PKEY的类型，如SHA算法就指向EVP_PKEY_RSA_method</span></span><br><span class="line">    <span class="keyword">int</span> block_size;  <span class="comment">//一个用来进行信息摘要的输入块的的长度（单位是字节），如SHA算法就是SHA_CBLOCK</span></span><br><span class="line">    <span class="keyword">int</span> ctx_size;    <span class="comment">//是CTX结构的长度，在SHA算法里面应该就是sizeof(EVP_MD*)+sizeof(SHA_CTX)</span></span><br><span class="line">&#125; EVP_MD;</span><br></pre></td></tr></table></figure>
<p>如果要增加新的算法，那么可以定义这个结构，并进行必要的移植，然后就可以使用通用的函数了。</p>
<h3 id="evp_md_ctx结构体"><a class="markdownIt-Anchor" href="#evp_md_ctx结构体"></a> EVP_MD_CTX结构体</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">env_md_ctx_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> EVP_MD *digest;  <span class="comment">//digest——指向上面介绍的EVP_MD结构的指针</span></span><br><span class="line">    ENGINE *engine;        <span class="comment">//如果算法由ENGINE提供，该指针指向该ENGINE</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;   <span class="comment">//</span></span><br><span class="line">    <span class="keyword">void</span> *md_data;         <span class="comment">//信息摘要数据</span></span><br><span class="line">&#125;EVP_MD_CTX ;</span><br></pre></td></tr></table></figure>
<h2 id="相关函数-2"><a class="markdownIt-Anchor" href="#相关函数-2"></a> 相关函数</h2>
<h3 id="核心函数-2"><a class="markdownIt-Anchor" href="#核心函数-2"></a> 核心函数</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旧版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DigestInit</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">const</span> EVP_MD *type)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DigestUpdate</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DigestFinal</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *md, <span class="keyword">unsigned</span> <span class="keyword">int</span> *size)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//新版本</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DigestInit_ex</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">const</span> EVP_MD *type, ENGINE *impl)</span> <span class="comment">//使用参数impl所指向的ENGINE设置该信息摘要结构体，参数ctx在调用本函数之前必须经过初始化。参数type一般是使用像EVP_sha1这样的函数的返回值。如果impl为NULL，那么就会使用缺省实现的信息摘要函数，大多数应用程序里面impl是设置为NULL的。操作成功返回1，否则返回0。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DigestUpdate</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> count)</span> <span class="comment">//将参数d中的cnt字节数据进行信息摘要到ctx结构中去，该函数可以被调用多次，用以对更多的数据进行信息摘要。操作成功返回1，否则返回0。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DigestFinal_ex</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *md, <span class="keyword">unsigned</span> <span class="keyword">int</span> *size)</span> <span class="comment">//将ctx结构中的摘要信息数据返回到参数md中，如果参数size不是NULL，那么摘要数据的长度（字节）就会被写入到参数size中，大多数情况下写入的值是EVP_MAX_MD_SIZE。在调用本函数后，不能使用相同的ctx结构调用EVP_DigestUpdate再进行数据的信息摘要操作,但是如果调用EVP_DigestInit_ex函数重新初始化后可以进行新的信息摘要操作。操作成功返回1，否则返回0。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//高级版本</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_Digest</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> count, <span class="keyword">unsigned</span> <span class="keyword">char</span> *md, <span class="keyword">unsigned</span> <span class="keyword">int</span> *size, <span class="keyword">const</span> EVP_MD *type,ENGINE *impl)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="辅助函数-2"><a class="markdownIt-Anchor" href="#辅助函数-2"></a> 辅助函数</h3>
<h4 id="操作evp_md_ctx的函数"><a class="markdownIt-Anchor" href="#操作evp_md_ctx的函数"></a> 操作EVP_MD_CTX的函数</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_MD_CTX_reset</span><span class="params">(EVP_MD_CTX *ctx)</span></span></span><br><span class="line"><span class="function">EVP_MD_CTX *<span class="title">EVP_MD_CTX_new</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_MD_CTX_free</span><span class="params">(EVP_MD_CTX *ctx)</span></span></span><br><span class="line"><span class="function">EVP_MD_CTX *<span class="title">EVP_MD_CTX_create</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//创建一个EVP_MD_CTX结构，分配内存并进行初始化，返回该结构</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_MD_CTX_destroy</span><span class="params">(EVP_MD_CTX *ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_MD_CTX_init</span><span class="params">(EVP_MD_CTX *ctx)</span></span>; <span class="comment">//初始化一个EVP_MD_CTX结构</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">EVP_MD_CTX_cleanup</span><span class="params">(EVP_MD_CTX *ctx)</span></span>; <span class="comment">//清除一个EVP_MD_CTX结构，应该在不再需要使用之后再清除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">EVP_MD_CTX_copy</span><span class="params">(EVP_MD_CTX *out, <span class="keyword">const</span> EVP_MD_CTX *in)</span> <span class="comment">//与下面的函数作用相同，但是out不用初始化</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">EVP_MD_CTX_copy_ex</span><span class="params">(EVP_MD_CTX *out, <span class="keyword">const</span> EVP_MD_CTX *in)</span> <span class="comment">//将信息摘要数据从in结构拷贝到out结构中，out必须在调用之前被初始化</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">EVP_MD_CTX_ctrl</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">int</span> cmd, <span class="keyword">int</span> p1, <span class="keyword">void</span> *p2)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="参数设置与获取函数"><a class="markdownIt-Anchor" href="#参数设置与获取函数"></a> 参数设置与获取函数</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_MAX_MD_SIZE 64     <span class="comment">/* SHA512 */</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_MD_type</span><span class="params">(<span class="keyword">const</span> EVP_MD *md)</span></span>; <span class="comment">//返回信息摘要结构算法的NID</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_MD_pkey_type</span><span class="params">(<span class="keyword">const</span> EVP_MD *md)</span></span>; <span class="comment">//返回信息摘要结构中公钥签名算法的NID</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_MD_size</span><span class="params">(<span class="keyword">const</span> EVP_MD *md)</span></span>; <span class="comment">//返回结构里面摘要信息的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_MD_block_size</span><span class="params">(<span class="keyword">const</span> EVP_MD *md)</span></span>; <span class="comment">//返回摘要信息分块的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_MD_CTX_md</span><span class="params">(<span class="keyword">const</span> EVP_MD_CTX *ctx)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_MD_CTX_size(e)        EVP_MD_size(EVP_MD_CTX_md(e)) <span class="comment">//返回结构里面摘要信息的长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_MD_CTX_block_size(e)  EVP_MD_block_size((e)-&gt;digest) <span class="comment">//返回摘要信息分块的长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_MD_CTX_type(e)        EVP_MD_type((e)-&gt;digest) <span class="comment">//返回信息摘要结构算法的NID</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_get_digestbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; <span class="comment">//根据给定算法名称返回一个EVP_MD结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_get_digestbynid(a) EVP_get_digestbyname(OBJ_nid2sn(a)) <span class="comment">//根据算法的NID返回一个EVP_MD结构</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_get_digestbyobj(a) EVP_get_digestbynid(OBJ_obj2nid(a)) <span class="comment">//根据算法的ASN1_OBJECT结构返回一个EVP_MD结构</span></span></span><br></pre></td></tr></table></figure>
<h4 id="摘要算法函数"><a class="markdownIt-Anchor" href="#摘要算法函数"></a> 摘要算法函数</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_md_null</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_md2</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_md4</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_md5</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_sha</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_sha1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_sha224</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_sha256</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_sha384</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_sha512</span><span class="params">(<span class="keyword">void</span>)</span></span>;       </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_dss</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_dss1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_ecdsa</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_mdc2</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_ripemd160</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_whirlpool</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="程序示例-2"><a class="markdownIt-Anchor" href="#程序示例-2"></a> 程序示例</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/conf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleErrors</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ERR_print_errors_fp(<span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">digest_message</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* message, <span class="keyword">size_t</span> message_len, <span class="keyword">unsigned</span> ch</span></span></span><br><span class="line"><span class="function"><span class="params">ar** digest, <span class="keyword">unsigned</span> <span class="keyword">int</span>* digest_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        EVP_MD_CTX* mdctx;</span><br><span class="line">        <span class="keyword">if</span>((mdctx=EVP_MD_CTX_new())==<span class="literal">NULL</span>)</span><br><span class="line">                handleErrors();</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>!=EVP_DigestInit_ex(mdctx,EVP_sha256(),<span class="literal">NULL</span>))</span><br><span class="line">                handleErrors();</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>!=EVP_DigestUpdate(mdctx,message,message_len))</span><br><span class="line">                handleErrors();</span><br><span class="line">        <span class="keyword">if</span>((*digest=(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)OPENSSL_malloc(EVP_MD_size(EVP_sha256())))==N</span><br><span class="line">ULL)</span><br><span class="line">                handleErrors();</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>!=EVP_DigestFinal_ex(mdctx,*digest,digest_len))</span><br><span class="line">                handleErrors();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;(*digest_len);i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>,(*digest)[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        EVP_MD_CTX_free(mdctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* message=(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="string">&quot;01234567890123456789&quot;</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>** digest;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> digest_len;</span><br><span class="line">        digest_message(message,<span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)message),digest,&amp;digest_len);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="非对称加密"><a class="markdownIt-Anchor" href="#非对称加密"></a> 非对称加密</h1>
<p>主要是以 p_开头的文件。其中:</p>
<ul>
<li>p_enc.c 封装了公钥加密；</li>
<li>p_dec.c 封装了私钥解密；</li>
<li>p_lib.c 实现一些辅助函数；</li>
<li>p_sign.c 封装了签名函数；</li>
<li>p_verify.c 封装了验签函数；</li>
<li>p_seal.c 封装了数字信封相关的函数；</li>
<li>p_open.c 封装了解数字信封相关的函数。</li>
</ul>
<h2 id="基本数据结构-3"><a class="markdownIt-Anchor" href="#基本数据结构-3"></a> 基本数据结构</h2>
<p>该结构用来存放非对称密钥信息，可以是RSA、DSA、DH 或ECC 密钥。其中，ptr 用来存放密钥结构地址，attributes 堆栈用来存放密钥属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">evp_pkey_st</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">int</span> save_type;</span><br><span class="line">    <span class="keyword">int</span> references;</span><br><span class="line">    <span class="keyword">const</span> EVP_PKEY_ASN1_METHOD *ameth;</span><br><span class="line">    ENGINE *engine;</span><br><span class="line">    <span class="keyword">union</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *ptr;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rsa_st</span> *<span class="title">rsa</span>;</span>     <span class="comment">/* RSA */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dsa_st</span> *<span class="title">dsa</span>;</span>     <span class="comment">/* DSA */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dh_st</span> *<span class="title">dh</span>;</span>       <span class="comment">/* DH */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ec_key_st</span> *<span class="title">ec</span>;</span>   <span class="comment">/* ECC */</span></span><br><span class="line">    &#125; pkey;</span><br><span class="line">    <span class="keyword">int</span> save_parameters;</span><br><span class="line">    STACK_OF(X509_ATTRIBUTE) *attributes; <span class="comment">/* [ 0 ] */</span></span><br><span class="line">&#125;; EVP_PKEY</span><br></pre></td></tr></table></figure>
<h2 id="相关函数-3"><a class="markdownIt-Anchor" href="#相关函数-3"></a> 相关函数</h2>
<h3 id="核心函数-3"><a class="markdownIt-Anchor" href="#核心函数-3"></a> 核心函数</h3>
<h4 id="加密-2"><a class="markdownIt-Anchor" href="#加密-2"></a> 加密</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_encrypt_old</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *enc_key,<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">int</span> key_len, EVP_PKEY *pubk)</span> <span class="comment">//使用RSA公钥加密</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_encrypt_init</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>; <span class="comment">//使用密钥pkey对公钥算法的上下文进行初始化，以进行加密操作。返回1成功，0或负值失败，-2代表该公钥算法不支持此操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_encrypt</span><span class="params">(EVP_PKEY_CTX *ctx,<span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">size_t</span> *outlen, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">size_t</span> inlen)</span></span>; <span class="comment">//函数使用ctx执行公钥加密操作。使用in和inlen参数指定要加密的数据与数据长度。如果out为NULL，则输出缓冲区的最大大小写入outlen参数。如果out不为NULL，那么在调用之前，outlen参数应该包含out缓冲区的长度，如果调用成功，则将加密数据写入out，并将加密后的数据长度写入outlen。返回1成功，0或负值失败，-2表示该公钥算法不支持该操作</span></span><br></pre></td></tr></table></figure>
<h4 id="解密-2"><a class="markdownIt-Anchor" href="#解密-2"></a> 解密</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_decrypt_old</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *dec_key, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *enc_key, <span class="keyword">int</span> enc_key_len,EVP_PKEY *private_key)</span></span>;<span class="comment">//RSA私钥解密</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_decrypt_init</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>; <span class="comment">//函数使用密钥pkey初始化公钥算法的上下文以进行解密操作。返回1成功，0或负值失败，-2表示该公钥算法不支持该操作。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_decrypt</span><span class="params">(EVP_PKEY_CTX *ctx,<span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">size_t</span> *outlen, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">size_t</span> inlen)</span></span>; <span class="comment">//函数使用ctx执行公钥解操作。使用in和inlen参数指定要解密的数据与数据字长。如果out为NULL，则输出缓冲区的最大大小写入outlen参数。如果out不为NULL，那么在调用之前，outlen参数应该包含out缓冲区的长度，如果调用成功，则将解密数据写入out，并将数据写入outlen。返回1成功，0或负值失败，-2表示该公钥算法不支持该操作。</span></span><br></pre></td></tr></table></figure>
<h3 id="辅助函数-3"><a class="markdownIt-Anchor" href="#辅助函数-3"></a> 辅助函数</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="function">EVP_PKEY_CTX *<span class="title">EVP_PKEY_CTX_new</span><span class="params">(EVP_PKEY *pkey, ENGINE *e)</span></span>; <span class="comment">//使用pkey和ENGINE e中指定的算法分配公钥算法上下文，返回新分配的EVP_PKEY_CTX结构，如果出现错误返回NULL</span></span><br><span class="line"><span class="function">EVP_PKEY_CTX *<span class="title">EVP_PKEY_CTX_new_id</span><span class="params">(<span class="keyword">int</span> id, ENGINE *e)</span></span>; <span class="comment">//使用由id和e指定的算法分配公钥算法上下文，返回新分配的EVP_PKEY_CTX结构，如果出现错误返回NULL</span></span><br><span class="line"><span class="function">EVP_PKEY_CTX *<span class="title">EVP_PKEY_CTX_dup</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>; <span class="comment">//复制上下文ctx，返回新分配的EVP_PKEY_CTX结构，如果出现错误返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_PKEY_CTX_free</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>; <span class="comment">//释放上下文ctx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_ctrl</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">int</span> keytype, <span class="keyword">int</span> optype,<span class="keyword">int</span> cmd, <span class="keyword">int</span> p1, <span class="keyword">void</span> *p2)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_ctrl_str</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *type,<span class="keyword">const</span> <span class="keyword">char</span> *value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/rsa.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_set_signature_md</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">const</span> EVP_MD *md)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_set_rsa_padding</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">int</span> pad)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_set_rsa_pss_saltlen</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_set_rsa_rsa_keygen_bits</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">int</span> mbits)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_set_rsa_keygen_pubexp</span><span class="params">(EVP_PKEY_CTX *ctx, BIGNUM *pubexp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/dsa.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_set_dsa_paramgen_bits</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">int</span> nbits)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/dh.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_set_dh_paramgen_prime_len</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_set_dh_paramgen_generator</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">int</span> gen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/ec.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_set_ec_paramgen_curve_nid</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">int</span> nid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_PKEY_CTX_set_cb</span><span class="params">(EVP_PKEY_CTX *ctx, EVP_PKEY_gen_cb *cb)</span></span>;</span><br><span class="line"><span class="function">EVP_PKEY_gen_cb *<span class="title">EVP_PKEY_CTX_get_cb</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="comment">//将pkey所指的EVP_PKEY的密钥设置为key所指的密钥，成功返回1，失败返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_set1_RSA</span><span class="params">(EVP_PKEY *pkey,RSA *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_set1_DSA</span><span class="params">(EVP_PKEY *pkey,DSA *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_set1_DH</span><span class="params">(EVP_PKEY *pkey,DH *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_set1_EC_KEY</span><span class="params">(EVP_PKEY *pkey,EC_KEY *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从pkey所指的EVP_PKEY中获取对应的密钥，失败返回NULL </span></span><br><span class="line"><span class="function">RSA *<span class="title">EVP_PKEY_get1_RSA</span><span class="params">(EVP_PKEY *pkey)</span></span>;</span><br><span class="line"><span class="function">DSA *<span class="title">EVP_PKEY_get1_DSA</span><span class="params">(EVP_PKEY *pkey)</span></span>;</span><br><span class="line"><span class="function">DH *<span class="title">EVP_PKEY_get1_DH</span><span class="params">(EVP_PKEY *pkey)</span></span>;</span><br><span class="line"><span class="function">EC_KEY *<span class="title">EVP_PKEY_get1_EC_KEY</span><span class="params">(EVP_PKEY *pkey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将pkey所指的EVP_PKEY的密钥设置为key所指的密钥，但pkey释放时，key也会被释放成功返回1，失败返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_assign</span><span class="params">(EVP_PKEY,<span class="keyword">int</span> type ,<span class="keyword">void</span> *key)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_assign_RSA</span><span class="params">(EVP_PKEY *pkey,RSA *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_assign_DSA</span><span class="params">(EVP_PKEY *pkey,DSA *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_assign_DH</span><span class="params">(EVP_PKEY *pkey,DH *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_assign_EC_KEY</span><span class="params">(EVP_PKEY *pkey,EC_KEY *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回与type匹配的密钥的类型，EVP_PKEY_RSA, EVP_PKEY_DSA, EVP_PKEY_DH or EVP_PKEY_EC或者NID_undef</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_type</span><span class="params">(<span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_missing_parameters</span><span class="params">(<span class="keyword">const</span> EVP_PKEY *pkey)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_copy_parameters</span><span class="params">(EVP_PKEY *to, <span class="keyword">const</span> EVP_PKEY *from)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_cmp_parameters</span><span class="params">(<span class="keyword">const</span> EVP_PKEY *a, <span class="keyword">const</span> EVP_PKEY *b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_cmp</span><span class="params">(<span class="keyword">const</span> EVP_PKEY *a, <span class="keyword">const</span> EVP_PKEY *b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_derive_init</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_derive_set_peer</span><span class="params">(EVP_PKEY_CTX *ctx, EVP_PKEY *peer)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_derive</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">size_t</span> *keylen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_get_default_digest_nid</span><span class="params">(EVP_PKEY *pkey, <span class="keyword">int</span> *pnid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_keygen_init</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_keygen</span><span class="params">(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_paramgen_init</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_paramgen</span><span class="params">(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="title">EVP_PKEY_gen_cb</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_get_keygen_info</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">int</span> idx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_PKEY_CTX_set_app_data</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">EVP_PKEY_CTX_get_app_data</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">EVP_PKEY *<span class="title">EVP_PKEY_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_PKEY_free</span><span class="params">(EVP_PKEY *key)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_print_public</span><span class="params">(BIO *out, <span class="keyword">const</span> EVP_PKEY *pkey,<span class="keyword">int</span> indent, ASN1_PCTX *pctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_print_private</span><span class="params">(BIO *out, <span class="keyword">const</span> EVP_PKEY *pkey,<span class="keyword">int</span> indent, ASN1_PCTX *pctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_print_params</span><span class="params">(BIO *out, <span class="keyword">const</span> EVP_PKEY *pkey,<span class="keyword">int</span> indent, ASN1_PCTX *pctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_sign_init</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_sign</span><span class="params">(EVP_PKEY_CTX *ctx,<span class="keyword">unsigned</span> <span class="keyword">char</span> *sig, <span class="keyword">size_t</span> *siglen, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *tbs, <span class="keyword">size_t</span> tbslen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_verify_init</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_verify</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *sig, <span class="keyword">size_t</span> siglen, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *tbs, <span class="keyword">size_t</span> tbslen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_verify_recover_init</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_verify_recover</span><span class="params">(EVP_PKEY_CTX *ctx,<span class="keyword">unsigned</span> <span class="keyword">char</span> *rout, <span class="keyword">size_t</span> *routlen, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *sig, <span class="keyword">size_t</span> siglen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_get_default_digest_nid</span><span class="params">(EVP_PKEY *pkey, <span class="keyword">int</span> *pnid)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="程序示例-3"><a class="markdownIt-Anchor" href="#程序示例-3"></a> 程序示例</h2>
<h3 id="参数初始化"><a class="markdownIt-Anchor" href="#参数初始化"></a> 参数初始化</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create the context for generating the parameters */</span></span><br><span class="line"><span class="keyword">if</span>(!(pctx = EVP_PKEY_CTX_new_id(type, <span class="literal">NULL</span>))) <span class="keyword">goto</span> err;</span><br><span class="line"><span class="keyword">if</span>(!EVP_PKEY_paramgen_init(pctx)) <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the paramgen parameters according to the type */</span></span><br><span class="line"><span class="keyword">switch</span>(type)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> EVP_PKEY_EC:</span><br><span class="line">  <span class="comment">/* Use the NID_X9_62_prime256v1 named curve - defined in obj_mac.h */</span></span><br><span class="line">  <span class="keyword">if</span>(!EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx, NID_X9_62_prime256v1)) <span class="keyword">goto</span> err;		</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EVP_PKEY_DSA:</span><br><span class="line">  <span class="comment">/* Set a bit length of 2048 */</span></span><br><span class="line">  <span class="keyword">if</span>(!EVP_PKEY_CTX_set_dsa_paramgen_bits(pctx, <span class="number">2048</span>)) <span class="keyword">goto</span> err;		</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EVP_PKEY_DH:</span><br><span class="line">  <span class="comment">/* Set a prime length of 2048 */</span></span><br><span class="line">  <span class="keyword">if</span>(!EVP_PKEY_CTX_set_dh_paramgen_prime_len(pctx, <span class="number">2048</span>)) <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Generate parameters */</span></span><br><span class="line"><span class="keyword">if</span> (!EVP_PKEY_paramgen(pctx, &amp;params)) <span class="keyword">goto</span> err;</span><br></pre></td></tr></table></figure>
<h3 id="密钥生成"><a class="markdownIt-Anchor" href="#密钥生成"></a> 密钥生成</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(*params != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!(kctx = EVP_PKEY_CTX_new(params, <span class="literal">NULL</span>))) <span class="keyword">goto</span> err; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Create context for the key generation */</span></span><br><span class="line">  <span class="keyword">if</span>(!(kctx = EVP_PKEY_CTX_new_id(type, <span class="literal">NULL</span>))) <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!EVP_PKEY_keygen_init(kctx)) <span class="keyword">goto</span> err; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* RSA keys set the key length during key generation rather than parameter generation! */</span></span><br><span class="line"><span class="keyword">if</span>(type == EVP_PKEY_RSA)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!EVP_PKEY_CTX_set_rsa_keygen_bits(kctx, <span class="number">2048</span>)) <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Generate the key */</span></span><br><span class="line"><span class="keyword">if</span> (!EVP_PKEY_keygen(kctx, &amp;key)) <span class="keyword">goto</span> err;</span><br></pre></td></tr></table></figure>
<h1 id="base64编解码"><a class="markdownIt-Anchor" href="#base64编解码"></a> BASE64编解码</h1>
<h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2>
<p>Base 64编码将二进制数据转换为使用字符 A-Z，a-z，0-9，“+”和“/”表示来数据的可打印形式。每3个字节的二进制数据，编码为上述字符表示的4字节数据。如果输入数据长度不是3的倍数，则输出数据将使用“=”字符在最后填充。</p>
<p>步骤：首先将每三个字节原始二进制数据在一起展开； 然后6bit分为一个小组，每个小组前面补两个0，成为一个字节；把新编码的每个字节转为十进制，根据base64标准转换表，找到对应的字符。 如果多了一个字节，则剩余两个字节用“=”填充，如果多了两个字节，则剩余一个字节用“=”填充。</p>
<h2 id="基本数据结构-4"><a class="markdownIt-Anchor" href="#基本数据结构-4"></a> 基本数据结构</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">evp_Encode_Ctx_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="comment">/* number saved in a partial encode/decode */</span></span><br><span class="line">     <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* The length is either the output line length (in input bytes) or the shortest input line length that is ok.  Once decoding begins, the length is adjusted up each time a longer line is decoded */</span></span><br><span class="line">     <span class="keyword">int</span> length;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> enc_data[<span class="number">80</span>];    <span class="comment">//待编码的数据</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> line_num;   <span class="comment">/* number read on current line */</span></span><br><span class="line">     <span class="keyword">int</span> expect_nl;</span><br><span class="line">&#125; EVP_ENCODE_CTX;  </span><br></pre></td></tr></table></figure>
<h2 id="相关函数-4"><a class="markdownIt-Anchor" href="#相关函数-4"></a> 相关函数</h2>
<h3 id="核心函数-4"><a class="markdownIt-Anchor" href="#核心函数-4"></a> 核心函数</h3>
<h4 id="编码"><a class="markdownIt-Anchor" href="#编码"></a> 编码</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_EncodeInit</span><span class="params">(EVP_ENCODE_CTX *ctx)</span></span>; <span class="comment">//初始化ctx以启动新的编码操作，无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_EncodeUpdate</span><span class="params">(EVP_ENCODE_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span></span>; <span class="comment">//编码in指向的缓冲区中的inl字节数据。输出存储在缓冲区out中，输出的字节数存储在outl中。调用者必须确保out指向的缓冲区足够大以容纳输出数据。只有完整的数据块（48字节）可以被直接编码完后并通过函数输出。任何剩余的字节都保存在ctx对象中，并通过后续调用EVP_EncodeUpdate（）EVP_EncodeFinal（）来处理。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_EncodeFinal</span><span class="params">(EVP_ENCODE_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl)</span></span>; <span class="comment">//必须在编码操作结束时调用EVP_EncodeFinal（）。它将处理ctx对象中剩余的任何部分数据块。输出数据将被存储在out，输出的数据长度将存储在* outl中，包含了’\n’。无返回值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">EVP_EncodeBlock</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *t, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *f, <span class="keyword">int</span> n)</span></span>; <span class="comment">//对f中的输入数据进行编码，并将其存储在t中。对于每3字节的输入，将产生4字节的输出数据。如果n不能被3整除，则块被当做最后的数据块来编码，并且被填充，使得它总是可被除以4。另外还将添加‘\0’终结符字符。</span></span><br></pre></td></tr></table></figure>
<h4 id="解码"><a class="markdownIt-Anchor" href="#解码"></a> 解码</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_DecodeInit</span><span class="params">(EVP_ENCODE_CTX *ctx)</span></span>; <span class="comment">//初始化ctx以开始新的解码操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">EVP_DecodeUpdate</span><span class="params">(EVP_ENCODE_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span></span>; <span class="comment">//解码in指向的缓冲区中inl字节的数据。输出存储在缓冲区中out，输出的字节数存储在* outl中。调用者有责任确保out指向的缓冲区足够大以容纳输出数据。该功能将尝试在4字节块中尽可能多地解码数据。任何空格，换行符或回车符都将被忽略。任何保留在结尾的未处理数据（1,2或3个字节）的部分块将保留在ctx对象中，并由后续调用EVP_DecodeUpdate（）处理。如果遇到非法的base64字符，或者如果在数据中间遇到base64填充字符“=”，则函数返回-1表示错误。返回值为0或1表示数据成功处理。返回值0表示处理的最后输入数据字符包括base64填充字符“=”，预期不会再处理非填充字符数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">EVP_DecodeFinal</span><span class="params">(EVP_ENCODE_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl)</span></span>; <span class="comment">//必须在解码操作结束时调用，如果仍然存在任何未处理的数据，那么输入数据不能是4的倍数。成功返回1，失败返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">EVP_DecodeBlock</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *t, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *f, <span class="keyword">int</span> n)</span></span>; <span class="comment">//解码f中包含的基本64个数据的n个字节的块，并将结果存储在t中。任何前导空格，以及任何尾随的空格，换行符，回车符或EOF字符将被修剪。返回解码的数据长度，出错返回-1。</span></span><br></pre></td></tr></table></figure>
<h3 id="辅助函数-4"><a class="markdownIt-Anchor" href="#辅助函数-4"></a> 辅助函数</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EVP_ENCODE_CTX *<span class="title">EVP_ENCODE_CTX_new</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//分配，初始化并返回要用于encode / decode函数的上下文。成功返回地址，失败返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_ENCODE_CTX_free</span><span class="params">(EVP_ENCODE_CTX *ctx)</span></span>; <span class="comment">//清理编码/解码上下文ctx并释放分配给它的空间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_ENCODE_CTX_copy</span><span class="params">(EVP_ENCODE_CTX *dctx, EVP_ENCODE_CTX *sctx)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_ENCODE_CTX_num</span><span class="params">(EVP_ENCODE_CTX *ctx)</span></span>; <span class="comment">//返回在ctx对象中待处理的尚未编码或解码的字节数</span></span><br></pre></td></tr></table></figure>
<h2 id="程序示例-4"><a class="markdownIt-Anchor" href="#程序示例-4"></a> 程序示例</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>	<span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EVP_ENCODE_CTX ectx,dctx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> in[<span class="number">500</span>],out[<span class="number">800</span>],d[<span class="number">500</span>];</span><br><span class="line">    <span class="keyword">int</span>	inl,outl,i,total,ret,total2;</span><br><span class="line"></span><br><span class="line">    EVP_EncodeInit(&amp;ectx);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">500</span>;i++)</span><br><span class="line">        <span class="built_in">memset</span>(&amp;in[i],i,<span class="number">1</span>);</span><br><span class="line">    inl=<span class="number">500</span>;</span><br><span class="line">    total=<span class="number">0</span>;</span><br><span class="line">    EVP_EncodeUpdate(&amp;ectx,out,&amp;outl,in,inl);</span><br><span class="line">    total+=outl;</span><br><span class="line">    EVP_EncodeFinal(&amp;ectx,out+total,&amp;outl);</span><br><span class="line">    total+=outl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,out);</span><br><span class="line"></span><br><span class="line">    EVP_DecodeInit(&amp;dctx);</span><br><span class="line">    outl=<span class="number">500</span>;</span><br><span class="line">    total2=<span class="number">0</span>;</span><br><span class="line">    ret=EVP_DecodeUpdate(&amp;dctx,d,&amp;outl,out,total);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EVP_DecodeUpdate err!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    total2+=outl;</span><br><span class="line">    ret=EVP_DecodeFinal(&amp;dctx,d,&amp;outl);</span><br><span class="line">    total2+=outl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="hmac"><a class="markdownIt-Anchor" href="#hmac"></a> HMAC</h1>
<p>HMAC是基于散列函数的MAC（消息认证码），即用于消息认证的密钥哈希函数。</p>
<h2 id="基本数据结构-5"><a class="markdownIt-Anchor" href="#基本数据结构-5"></a> 基本数据结构</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hmac_ctx_st</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> EVP_MD *md;</span><br><span class="line">    EVP_MD_CTX md_ctx;</span><br><span class="line">    EVP_MD_CTX i_ctx;</span><br><span class="line">    EVP_MD_CTX o_ctx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> key_length;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> key[HMAC_MAX_MD_CBLOCK];</span><br><span class="line">&#125;<span class="comment">/* HMAC_CTX*/</span>;</span><br></pre></td></tr></table></figure>
<h2 id="相关函数-5"><a class="markdownIt-Anchor" href="#相关函数-5"></a> 相关函数</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">HMAC</span><span class="params">(<span class="keyword">const</span> EVP_MD *evp_md, <span class="keyword">const</span> <span class="keyword">void</span> *key,<span class="keyword">int</span> key_len, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *d, <span class="keyword">int</span> n,<span class="keyword">unsigned</span> <span class="keyword">char</span> *md, <span class="keyword">unsigned</span> <span class="keyword">int</span> *md_len)</span></span>; <span class="comment">//使用哈希函数evp_md和key_len字节长的密钥键计算d字节的消息认证码。它将结果放在md（它必须有空格的哈希函数的输出，不超过EVP_MAX_MD_SIZE字节）。如果md为NULL，则将摘要放置在静态数组中。输出的大小放在md_len中，除非它为空。evp_md可以为EVP_sha1()等</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> HMAC_MAX_MD_CBLOCK      128<span class="comment">/* largest known is SHA512 */</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> HMAC_size(e)    (EVP_MD_size((e)-&gt;md)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HMAC_CTX_init</span><span class="params">(HMAC_CTX *ctx)</span></span>; <span class="comment">//HMAC_CTX_init()在首次使用前初始化HMAC_CTX。必须调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HMAC_CTX_cleanup</span><span class="params">(HMAC_CTX *ctx)</span></span>; <span class="comment">//HMAC_CTX_cleanup()从HMAC_CTX中删除密钥和其他数据，并释放任何关联的资源。当不再需要HMAC_CTX时，必须调用它</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">HMAC_size</span><span class="params">(<span class="keyword">const</span> HMAC_CTX *e)</span></span>;</span><br><span class="line"><span class="function">HMAC_CTX *<span class="title">HMAC_CTX_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HMAC_CTX_reset</span><span class="params">(HMAC_CTX *ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HMAC_CTX_free</span><span class="params">(HMAC_CTX *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果消息没有完全存储在内存中，可能会使用以下功能：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HMAC_Init_ex</span><span class="params">(HMAC_CTX *ctx, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> key_len,<span class="keyword">const</span> EVP_MD *md, ENGINE *impl)</span></span>; <span class="comment">//初始化或重用HMAC_CTX结构以使用函数evp_md和key，key可以是NULL，在这种情况下，现有的一个将被重用。 HMAC_CTX_init()必须在此功能首次使用HMAC_CTX之前被调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HMAC_Update</span><span class="params">(HMAC_CTX *ctx, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> len)</span></span>; <span class="comment">//可以重复调用消息的大小块进行身份验证（数据中为len个字节）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HMAC_Final</span><span class="params">(HMAC_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *md, <span class="keyword">unsigned</span> <span class="keyword">int</span> *len)</span></span>; <span class="comment">//将消息认证码放在md中，它必须具有用于散列函数输出的空间</span></span><br></pre></td></tr></table></figure>
<h2 id="程序示例-5"><a class="markdownIt-Anchor" href="#程序示例-5"></a> 程序示例</h2>
<h3 id="生成"><a class="markdownIt-Anchor" href="#生成"></a> 生成</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hmac_it</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *msg, <span class="keyword">size_t</span> mlen, <span class="keyword">unsigned</span> <span class="keyword">char</span> **val, <span class="keyword">size_t</span> *vlen, EVP_PKEY *pkey)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Returned to caller */</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    EVP_MD_CTX* ctx = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> req = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!msg || !mlen || !val || !pkey)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    *val = <span class="literal">NULL</span>;</span><br><span class="line">    *vlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ctx = EVP_MD_CTX_new();</span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EVP_MD_CTX_create failed, error 0x%lx\n&quot;</span>, ERR_get_error());</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rc = EVP_DigestSignInit(ctx, <span class="literal">NULL</span>, EVP_sha256(), <span class="literal">NULL</span>, pkey);</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EVP_DigestSignInit failed, error 0x%lx\n&quot;</span>, ERR_get_error());</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rc = EVP_DigestSignUpdate(ctx, msg, mlen);</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EVP_DigestSignUpdate failed, error 0x%lx\n&quot;</span>, ERR_get_error());</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rc = EVP_DigestSignFinal(ctx, <span class="literal">NULL</span>, &amp;req);</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EVP_DigestSignFinal failed (1), error 0x%lx\n&quot;</span>, ERR_get_error());</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *val = OPENSSL_malloc(req);</span><br><span class="line">    <span class="keyword">if</span> (*val == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OPENSSL_malloc failed, error 0x%lx\n&quot;</span>, ERR_get_error());</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *vlen = req;</span><br><span class="line">    rc = EVP_DigestSignFinal(ctx, *val, vlen);</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EVP_DigestSignFinal failed (3), return code %d, error 0x%lx\n&quot;</span>, rc, ERR_get_error());</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line"> err:</span><br><span class="line">    EVP_MD_CTX_free(ctx);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        OPENSSL_free(*val);</span><br><span class="line">        *val = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="验证"><a class="markdownIt-Anchor" href="#验证"></a> 验证</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">verify_it</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *msg, <span class="keyword">size_t</span> mlen, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *val, <span class="keyword">size_t</span> vlen, EVP_PKEY *pkey)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Returned to caller */</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    EVP_MD_CTX* ctx = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buff[EVP_MAX_MD_SIZE];</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!msg || !mlen || !val || !vlen || !pkey)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ctx = EVP_MD_CTX_new();</span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EVP_MD_CTX_create failed, error 0x%lx\n&quot;</span>, ERR_get_error());</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rc = EVP_DigestSignInit(ctx, <span class="literal">NULL</span>, EVP_sha256(), <span class="literal">NULL</span>, pkey);</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EVP_DigestSignInit failed, error 0x%lx\n&quot;</span>, ERR_get_error());</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rc = EVP_DigestSignUpdate(ctx, msg, mlen);</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EVP_DigestSignUpdate failed, error 0x%lx\n&quot;</span>, ERR_get_error());</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    size = <span class="keyword">sizeof</span>(buff);</span><br><span class="line">    rc = EVP_DigestSignFinal(ctx, buff, &amp;size);</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EVP_DigestSignFinal failed, error 0x%lx\n&quot;</span>, ERR_get_error());</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result = (vlen == size) &amp;&amp; (CRYPTO_memcmp(val, buff, size) == <span class="number">0</span>);</span><br><span class="line"> err:</span><br><span class="line">    EVP_MD_CTX_free(ctx);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数字签名"><a class="markdownIt-Anchor" href="#数字签名"></a> 数字签名</h1>
<h2 id="签名"><a class="markdownIt-Anchor" href="#签名"></a> 签名</h2>
<p><strong>EVP_Sign系列函数</strong>使用的基础结构跟信息摘要算法使用的基础结构是一样的，而且，其前面的两个操作步骤初始化和数据操作（信息摘要）也跟信息摘要算法是一样的，唯一不一样的是最后一步操作，本系列函数做了签名的工作。本系列函数定义的如下(openssl/evp.h)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_SignInit_ex(a,b,c) EVP_DigestInit_ex(a,b,c)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_SignInit_ex</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">const</span> EVP_MD *type, ENGINE *impl)</span></span>; <span class="comment">//使用ENGINE参数impl所代表的实现函数功能来设置结构ctx。在调用本函数前，参数ctx一定要经过EVP_MD_CTX_init函数初始化。成功返回1，失败返回0。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_SignUpdate(a,b,c) EVP_DigestUpdate(a,b,c)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_SignUpdate</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">const</span> <span class="keyword">void</span> *d, <span class="keyword">unsigned</span> <span class="keyword">int</span> cnt)</span></span>; <span class="comment">//将一个cnt字节的数据经过信息摘要运算存储到结构ctx中，该函数可以在一个相同的ctx中调用多次来实现对更多数据的信息摘要工作。成功返回1，失败返回0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_SignFinal</span><span class="params">(EVP_MD_CTX *ctx,<span class="keyword">unsigned</span> <span class="keyword">char</span> *sig,<span class="keyword">unsigned</span> <span class="keyword">int</span> *s, EVP_PKEY *pkey)</span></span>; <span class="comment">//该函数是将签名操作的信息摘要结构先调用EVP_MD_CTX_copy_ex函数拷贝一份，然后调用EVP_DigestFinal_ex完成信息摘要工作，然后开始对摘要信息用私钥pkey调用EVP_PKEY_sign_init 和EVP_PKEY_sign进行签名,并将签名信息保存在参数sig里面。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_SignInit(a,b) EVP_DigestInit(a,b)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_SignInit</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">const</span> EVP_MD *type)</span></span>; <span class="comment">//使用缺省实现的算法初始化算法结构ctx</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_size</span><span class="params">(EVP_PKEY *pkey)</span></span>; <span class="comment">//返回一个签名信息的最大长度（单位字节）。实际签名信息的长度则由上述的函数EVP_SignFinal返回，有可能比它小</span></span><br></pre></td></tr></table></figure>
<h2 id="认证"><a class="markdownIt-Anchor" href="#认证"></a> 认证</h2>
<p>与EVP_Sign系列函数一样，EVP_Verify系列函数的前两步（初始化和信息摘要处理）和信息摘要算法是一样的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_VerifyInit_ex(a,b,c) EVP_DigestInit_ex(a,b,c)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_VerifyInit_ex</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">const</span> EVP_MD *type, ENGINE *impl)</span></span>; <span class="comment">//该函数使用参数impl所提供的算法库对验证结构ctx进行设置。在调用本函数之前，参数ctx必须经过调用EVP_MD_CTX_init进行初始化。成功返回1，失败返回0。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_VerifyUpdate(a,b,c) EVP_DigestUpdate(a,b,c)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_VerifyUpdate</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">const</span> <span class="keyword">void</span> *d, <span class="keyword">unsigned</span> <span class="keyword">int</span> cnt)</span></span>; <span class="comment">//该函数将参数d中的cnt字节数据经过信息摘要计算后保存到ctx中，该函数可以进行多次调用，以处理更多的数据。成功调用返回1，失败返回0。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_VerifyFinal</span><span class="params">(EVP_MD_CTX *ctx,<span class="keyword">unsigned</span> <span class="keyword">char</span> *sigbuf, <span class="keyword">unsigned</span> <span class="keyword">int</span> siglen,EVP_PKEY *pkey)</span></span>; <span class="comment">//该函数先调用EVP_MD_CTX_copy_ex函数将原来的ctx拷贝一份，然后调用EVP_DigestFinal_ex函数完成拷贝的ctx的信息摘要计算，最后才使用公钥pkey调用EVP_PKEY_verify_init 和EVP_PKEY_verify_进行签名的验证工作</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_VerifyInit(a,b) EVP_DigestInit(a,b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_VerifyInit</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">const</span> EVP_MD *type)</span></span>; <span class="comment">//使用默认实现对ctx结构进行初始化</span></span><br></pre></td></tr></table></figure>
<h2 id="备注"><a class="markdownIt-Anchor" href="#备注"></a> 备注</h2>
<p>在新版的OpenSSL中定义了<code>EVP_DigestSign*</code> 和 <code>EVP_DigestVerify*</code> 这两个系列的函数，将计算摘要和数字签名操作合在一起。这一系列函数的用法与不带Digest的系列函数类似，但是函数的参数稍有不同。</p>
<h2 id="程序示例-6"><a class="markdownIt-Anchor" href="#程序示例-6"></a> 程序示例</h2>
<h3 id="签名-2"><a class="markdownIt-Anchor" href="#签名-2"></a> 签名</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">EVP_MD_CTX *mdctx = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">*sig = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Create the Message Digest Context */</span></span><br><span class="line"><span class="keyword">if</span>(!(mdctx = EVP_MD_CTX_create())) <span class="keyword">goto</span> err;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Initialise the DigestSign operation - SHA-256 has been selected as the message digest function in this example */</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> != EVP_DigestSignInit(mdctx, <span class="literal">NULL</span>, EVP_sha256(), <span class="literal">NULL</span>, key)) <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Call update with the message */</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> != EVP_DigestSignUpdate(mdctx, msg, <span class="built_in">strlen</span>(msg))) <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Finalise the DigestSign operation */</span></span><br><span class="line"><span class="comment">/* First call EVP_DigestSignFinal with a NULL sig parameter to obtain the length of the</span></span><br><span class="line"><span class="comment">* signature. Length is returned in slen */</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> != EVP_DigestSignFinal(mdctx, <span class="literal">NULL</span>, slen)) <span class="keyword">goto</span> err;</span><br><span class="line"><span class="comment">/* Allocate memory for the signature based on size in slen */</span></span><br><span class="line"><span class="keyword">if</span>(!(*sig = OPENSSL_malloc(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>) * (*slen)))) <span class="keyword">goto</span> err;</span><br><span class="line"><span class="comment">/* Obtain the signature */</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> != EVP_DigestSignFinal(mdctx, *sig, slen)) <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Success */</span></span><br><span class="line">ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Do some error handling */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Clean up */</span></span><br><span class="line"><span class="keyword">if</span>(*sig &amp;&amp; !ret) OPENSSL_free(*sig);</span><br><span class="line"><span class="keyword">if</span>(mdctx) EVP_MD_CTX_destroy(mdctx);</span><br></pre></td></tr></table></figure>
<h3 id="验证-2"><a class="markdownIt-Anchor" href="#验证-2"></a> 验证</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initialize `key` with a public key */</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> != EVP_DigestVerifyInit(mdctx, <span class="literal">NULL</span>, EVP_sha256(), <span class="literal">NULL</span>, key)) <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize `key` with a public key */</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> != EVP_DigestVerifyUpdate(mdctx, msg, <span class="built_in">strlen</span>(msg))) <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> == EVP_DigestVerifyFinal(mdctx, sig, slen))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Success */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Failure */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数字信封"><a class="markdownIt-Anchor" href="#数字信封"></a> 数字信封</h1>
<h2 id="写信"><a class="markdownIt-Anchor" href="#写信"></a> 写信</h2>
<p>seal系列函数是相当于完成一个电子信封的功能，它产生一个随机密钥，然后使用一个公钥对该密钥进行封装，数据可以使用该随机密钥进行对称加密。</p>
<p>信封加密在进行大量数据传输的时候是必须经常要用到的，因为公开密钥算法的加解密速度很慢，但对称算法就快多了。所以一般用公开密钥算法对产生的随机密钥加密，而真正进行数据加密则使用该随机密钥进行对称加密，然后将加密后的密钥与数据一起发送。</p>
<p>其定义的函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_SealInit</span><span class="params">(EVP_CIPHER_CTX *ctx, EVP_CIPHER *type, <span class="keyword">unsigned</span> <span class="keyword">char</span> **ek, <span class="keyword">int</span> *ekl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv,EVP_PKEY **pubk, <span class="keyword">int</span> npubk)</span></span>;<span class="comment">//该函数初始化一个加密算法结构EVP_CIPHER_CTX，采用了指定的加密算法，使用一个随机密钥和初始化向量IV。事实上，该函数调用EVP_EncryptInit_ex函数两次完成了ctx结构的初始化工作；参数type是算法类型，参数ek是一个缓存序列，可以存放多个被公钥加密后的密钥的信息，所以每个缓存空间都应该足够大；参数pubk是一个公钥陈列，可以包含多个公钥。函数成功执行返回npubk，失败返回0。 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_SealUpdate(a,b,c,d,e) EVP_EncryptUpdate(a,b,c,d,e)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_SealUpdate</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span></span>; <span class="comment">//其完成的功能和使用方法跟EVP_EncryptUpdate函数是一样的。成功执行返回1，否则返回0。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_SealFinal</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out,<span class="keyword">int</span> *outl)</span></span>; <span class="comment">//简单调用EVP_EncryptFinal_ex完成其功能。该函数还调用EVP_EncryptInit_ex(ctx,NULL,NULL,NULL,NULL)函数对ctx结构再次进行了初始化。成功返回1，否则返回0。</span></span><br></pre></td></tr></table></figure>
<h2 id="读信"><a class="markdownIt-Anchor" href="#读信"></a> 读信</h2>
<p>本系列函数将公钥加密了的密钥加密出来，然后进行数据的解密。其定义的函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_OpenInit</span><span class="params">(EVP_CIPHER_CTX *ctx,EVP_CIPHER *type,<span class="keyword">unsigned</span> <span class="keyword">char</span> *ek, <span class="keyword">int</span> ekl,<span class="keyword">unsigned</span> <span class="keyword">char</span> *iv,EVP_PKEY *priv)</span></span>; <span class="comment">//该函数初始化一个用来加密数据的ctx结构。它首先使用参数priv指定的私钥解密参数ek里面长度为ekl字节的加密密钥。然后用此密钥与参数iv指定的初始化向量初始化EVP_CIPHER_CTX。如果参数type设定的加密算法长度是可变的，那么密钥长度就会被设置为解密得到的密钥的长度；如果加密算法长度是固定的，那么得到的解密密钥的长度就必须跟固定算法长度相同才行。成功执行返回密钥的长度，否则返回0。 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_OpenUpdate(a,b,c,d,e) EVP_DecryptUpdate(a,b,c,d,e)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_OpenUpdate</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span></span>; <span class="comment">//功能和使用方法与EVP_DecryptUpdate相同</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_OpenFinal</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out,<span class="keyword">int</span> *outl)</span></span>; <span class="comment">//调用EVP_DecryptFinal_ex完成了其功能，本函数还调用EVP_DecryptInit_ex(ctx,NULL,NULL,NULL,NULL)再次进行了初始化工作。成功执行返回1，否则返回0。</span></span><br></pre></td></tr></table></figure>
<h2 id="代码示例"><a class="markdownIt-Anchor" href="#代码示例"></a> 代码示例</h2>
<h3 id="写信-2"><a class="markdownIt-Anchor" href="#写信-2"></a> 写信</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">envelope_seal</span><span class="params">(EVP_PKEY **pub_key, <span class="keyword">unsigned</span> <span class="keyword">char</span> *plaintext, <span class="keyword">int</span> plaintext_len,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> <span class="keyword">char</span> **encrypted_key, <span class="keyword">int</span> *encrypted_key_len, <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *ciphertext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	EVP_CIPHER_CTX *ctx;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ciphertext_len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Create and initialise the context */</span></span><br><span class="line">	<span class="keyword">if</span>(!(ctx = EVP_CIPHER_CTX_new())) handleErrors();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialise the envelope seal operation. This operation generates</span></span><br><span class="line"><span class="comment">	 * a key for the provided cipher, and then encrypts that key a number</span></span><br><span class="line"><span class="comment">	 * of times (one for each public key provided in the pub_key array). In</span></span><br><span class="line"><span class="comment">	 * this example the array size is just one. This operation also</span></span><br><span class="line"><span class="comment">	 * generates an IV and places it in iv. */</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span> != EVP_SealInit(ctx, EVP_aes_256_cbc(), encrypted_key,</span><br><span class="line">		encrypted_key_len, iv, pub_key, <span class="number">1</span>))</span><br><span class="line">		handleErrors();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Provide the message to be encrypted, and obtain the encrypted output.</span></span><br><span class="line"><span class="comment">	 * EVP_SealUpdate can be called multiple times if necessary</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span> != EVP_SealUpdate(ctx, ciphertext, &amp;len, plaintext, plaintext_len))</span><br><span class="line">		handleErrors();</span><br><span class="line">	ciphertext_len = len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Finalise the encryption. Further ciphertext bytes may be written at</span></span><br><span class="line"><span class="comment">	 * this stage.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span> != EVP_SealFinal(ctx, ciphertext + len, &amp;len)) handleErrors();</span><br><span class="line">	ciphertext_len += len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Clean up */</span></span><br><span class="line">	EVP_CIPHER_CTX_free(ctx);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ciphertext_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读信-2"><a class="markdownIt-Anchor" href="#读信-2"></a> 读信</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">envelope_open</span><span class="params">(EVP_PKEY *priv_key, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ciphertext, <span class="keyword">int</span> ciphertext_len,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *encrypted_key, <span class="keyword">int</span> encrypted_key_len, <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *plaintext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	EVP_CIPHER_CTX *ctx;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> plaintext_len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Create and initialise the context */</span></span><br><span class="line">	<span class="keyword">if</span>(!(ctx = EVP_CIPHER_CTX_new())) handleErrors();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialise the decryption operation. The asymmetric private key is</span></span><br><span class="line"><span class="comment">	 * provided and priv_key, whilst the encrypted session key is held in</span></span><br><span class="line"><span class="comment">	 * encrypted_key */</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span> != EVP_OpenInit(ctx, EVP_aes_256_cbc(), encrypted_key,</span><br><span class="line">		encrypted_key_len, iv, priv_key))</span><br><span class="line">		handleErrors();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Provide the message to be decrypted, and obtain the plaintext output.</span></span><br><span class="line"><span class="comment">	 * EVP_OpenUpdate can be called multiple times if necessary</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span> != EVP_OpenUpdate(ctx, plaintext, &amp;len, ciphertext, ciphertext_len))</span><br><span class="line">		handleErrors();</span><br><span class="line">	plaintext_len = len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Finalise the decryption. Further plaintext bytes may be written at</span></span><br><span class="line"><span class="comment">	 * this stage.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span> != EVP_OpenFinal(ctx, plaintext + len, &amp;len)) handleErrors();</span><br><span class="line">	plaintext_len += len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Clean up */</span></span><br><span class="line">	EVP_CIPHER_CTX_free(ctx);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> plaintext_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW8yMDA4MTIyOC9hcnRpY2xlL2RldGFpbHMvNzYyODU4OTY=">https://blog.csdn.net/liao20081228/article/details/76285896<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93aWtpLm9wZW5zc2wub3JnL2luZGV4LnBocC9FVlA=">https://wiki.openssl.org/index.php/EVP<i class="fa fa-external-link-alt"></i></span></li>
<li>OpenSSL编程 赵春平</li>
</ol>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Yufei Luo
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://lyf35.github.io/2021/03/02/OpenSSL-EVP%EF%BC%88%E6%91%98%E5%BD%95%EF%BC%89/" title="OpenSSL-EVP（摘录）">http://lyf35.github.io/2021/03/02/OpenSSL-EVP（摘录）/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/" rel="tag"><i class="fa fa-tag"></i> 信息安全</a>
              <a href="/tags/OpenSSL/" rel="tag"><i class="fa fa-tag"></i> OpenSSL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/02/OpenSSL-BIO%EF%BC%88%E6%91%98%E5%BD%95%EF%BC%89/" rel="prev" title="OpenSSL-BIO（摘录）">
      <i class="fa fa-chevron-left"></i> OpenSSL-BIO（摘录）
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/02/%E5%AF%86%E7%A0%81%E5%AD%A6-%E6%B6%88%E6%81%AF%E9%AA%8C%E8%AF%81%E7%A0%81/" rel="next" title="密码学-消息验证码">
      密码学-消息验证码 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yufei Luo</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">702k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">10:38</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动
  </div>

        






<script data-pjax>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"ypNNXSdcGIIoldC5BBmViS2g-gzGzoHsz","app_key":"0TDwohU7eO4yHTn4tley8PtE","server_url":"https://leancloud.cn/dashboard/data.html?appid=ypNNXSdcGIIoldC5BBmViS2g-gzGzoHsz#/","security":false};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="//cdn.jsdelivr.net/npm/ribbon.js@1/dist/ribbon.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/next-theme/pjax@0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  
  <script data-pjax>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>









<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>


    <div class="pjax">
  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">
  <script src="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css">


  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4dcdc02d24075b0e9d3a',
      clientSecret: '53cf2cb8b89b9d4bba922bb19bda1290f0d0bf95',
      repo        : 'lyf35.github.io',
      owner       : 'lyf35',
      admin       : ['lyf35'],
      id          : '608fff21d2b5a91418d4236bf721afb7',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
