<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">
  <link rel="manifest" href="/images/site.webmanifest">
  <meta name="msapplication-config" content="/images/browserconfig.xml">
  <meta name="msvalidate.01" content="<meta name="msvalidate.01" content="5D3796A5DDB32CC875380613FB613833" />">
  <meta name="baidu-site-verification" content="<meta name="baidu-site-verification" content="kewHZtFYQk" />">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Helvetica:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-flat-top.min.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lyf35.github.io","root":"/","scheme":"Pisces","version":"8.0.0-rc.5","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="简介 OpenSSL是一个C语言实现的，功能丰富且自包含的安全工具箱，提供的主要功能包括SSL协议实现、加密解密算法、非对称算法的密钥生成、数字证书验证等。 OpenSSL Manual: https:&#x2F;&#x2F;www.openssl.org&#x2F;docs&#x2F;man1.1.1&#x2F;man7&#x2F;  安装与使用 在linux系统下面，可以使用apt-get命令安装OpenSSL和libssl-dev（这个必须安装，包">
<meta property="og:type" content="article">
<meta property="og:title" content="信息安全-OpenSSL的基本使用（摘录）">
<meta property="og:url" content="http://lyf35.github.io/2020/10/15/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8-OpenSSL%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E6%91%98%E5%BD%95%EF%BC%89/index.html">
<meta property="og:site_name" content="Yufei Luo&#39;s Blog">
<meta property="og:description" content="简介 OpenSSL是一个C语言实现的，功能丰富且自包含的安全工具箱，提供的主要功能包括SSL协议实现、加密解密算法、非对称算法的密钥生成、数字证书验证等。 OpenSSL Manual: https:&#x2F;&#x2F;www.openssl.org&#x2F;docs&#x2F;man1.1.1&#x2F;man7&#x2F;  安装与使用 在linux系统下面，可以使用apt-get命令安装OpenSSL和libssl-dev（这个必须安装，包">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdn.net/20170815180254544?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlhbzIwMDgxMjI4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="article:published_time" content="2020-10-15T05:20:36.000Z">
<meta property="article:modified_time" content="2021-01-05T14:14:05.000Z">
<meta property="article:author" content="Yufei Luo">
<meta property="article:tag" content="信息安全">
<meta property="article:tag" content="OpenSSL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdn.net/20170815180254544?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlhbzIwMDgxMjI4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">

<link rel="canonical" href="http://lyf35.github.io/2020/10/15/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8-OpenSSL%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E6%91%98%E5%BD%95%EF%BC%89/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>信息安全-OpenSSL的基本使用（摘录） | Yufei Luo's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
 <!--   <div class="headband"></div>-->

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Yufei Luo's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">But I was so much older then, I am younger than that now.</p>
      <img class="custom-logo-image" src="/images/logo.png" alt="Yufei Luo's Blog">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-计算机基础">

    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80" rel="section"><i class="fa fa-tags fa-fw"></i>计算机基础</a>

  </li>
        <li class="menu-item menu-item-机器学习">

    <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0" rel="section"><i class="fa fa-tags fa-fw"></i>机器学习</a>

  </li>
        <li class="menu-item menu-item-深度学习">

    <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0" rel="section"><i class="fa fa-tags fa-fw"></i>深度学习</a>

  </li>
        <li class="menu-item menu-item-工程实践">

    <a href="/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5" rel="section"><i class="fa fa-tags fa-fw"></i>工程实践</a>

  </li>
        <li class="menu-item menu-item-论文笔记">

    <a href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0" rel="section"><i class="fa fa-tags fa-fw"></i>论文笔记</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text"> 简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text"> 安装与使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#bash%E5%91%BD%E4%BB%A4"><span class="nav-number">3.</span> <span class="nav-text"> Bash命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8Bopenssl%E6%98%AF%E4%BB%80%E4%B9%88%E7%89%88%E6%9C%AC"><span class="nav-number">3.1.</span> <span class="nav-text"> 查看OpenSSL是什么版本？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9"><span class="nav-number">3.2.</span> <span class="nav-text"> 查看有哪些命令选项？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E7%AE%97%E6%B3%95"><span class="nav-number">3.3.</span> <span class="nav-text"> 查看支持哪些算法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="nav-number">3.4.</span> <span class="nav-text"> 性能测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E7%AE%97%E6%80%A7%E8%83%BD"><span class="nav-number">3.4.1.</span> <span class="nav-text"> 如何测试当前系统的运算性能？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%80%97%E6%97%B6"><span class="nav-number">3.4.2.</span> <span class="nav-text"> 如何测试远程连接的耗时？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%81%E4%B9%A6"><span class="nav-number">3.5.</span> <span class="nav-text"> 证书</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8D%E7%9A%84%E8%AF%81%E4%B9%A6"><span class="nav-number">3.5.1.</span> <span class="nav-text"> 如何生成自签名的证书？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90verisign%E7%9A%84%E8%AF%81%E4%B9%A6%E8%AF%B7%E6%B1%82"><span class="nav-number">3.5.2.</span> <span class="nav-text"> 如何生成VeriSign的证书请求？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%AA%E6%96%B0%E8%AF%81%E4%B9%A6"><span class="nav-number">3.5.3.</span> <span class="nav-text"> 如何测试一个新证书？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BApkcs12%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AF%81%E4%B9%A6"><span class="nav-number">3.5.4.</span> <span class="nav-text"> 如何导入／导出PKCS#12格式的证书？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81"><span class="nav-number">3.6.</span> <span class="nav-text"> 证书验证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E8%AF%81%E4%B9%A6"><span class="nav-number">3.6.1.</span> <span class="nav-text"> 如何验证证书？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#openssl%E9%83%BD%E8%AE%A4%E5%8F%AF%E5%93%AA%E4%BA%9B%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84"><span class="nav-number">3.6.2.</span> <span class="nav-text"> OpenSSL都认可哪些证书颁发机构？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9openssl%E4%BF%A1%E4%BB%BB%E6%9F%90%E4%B8%AA%E8%AF%81%E4%B9%A6"><span class="nav-number">3.6.3.</span> <span class="nav-text"> 如何让OpenSSL信任某个证书？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="nav-number">3.7.</span> <span class="nav-text"> 命令行客户端和服务端</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%B8%8Esmtp%E6%9C%8D%E5%8A%A1%E5%BB%BA%E7%AB%8B%E5%AE%89%E5%85%A8%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.7.1.</span> <span class="nav-text"> 如何与SMTP服务建立安全连接？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%85%B6%E5%AE%83%E6%9C%8D%E5%8A%A1%E5%BB%BA%E7%AB%8B%E5%AE%89%E5%85%A8%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.7.2.</span> <span class="nav-text"> 如何其它服务建立安全连接？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAssl%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="nav-number">3.7.3.</span> <span class="nav-text"> 如何使用命令行搭建一个SSL服务端？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%BF%90%E7%AE%97"><span class="nav-number">3.8.</span> <span class="nav-text"> 哈希运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84md5%E6%88%96sha1%E5%93%88%E5%B8%8C%E5%80%BC"><span class="nav-number">3.8.1.</span> <span class="nav-text"> 如何计算一个文件的MD5或SHA1哈希值？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%AD%BE%E5%90%8D%E4%B8%80%E4%B8%AA%E5%93%88%E5%B8%8C%E5%80%BC"><span class="nav-number">3.8.2.</span> <span class="nav-text"> 如何签名一个哈希值？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E4%B8%80%E4%B8%AA%E7%AD%BE%E5%90%8D%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC"><span class="nav-number">3.8.3.</span> <span class="nav-text"> 如何验证一个签名的哈希值？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%AC%A6%E5%90%88apache%E8%A6%81%E6%B1%82%E7%9A%84%E8%AE%A4%E8%AF%81%E4%BF%A1%E6%81%AF"><span class="nav-number">3.8.4.</span> <span class="nav-text"> 如何创建符合Apache要求的认证信息？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E7%94%A8%E7%9A%84%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="nav-number">3.8.5.</span> <span class="nav-text"> 都有哪些可用的哈希算法？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86"><span class="nav-number">3.9.</span> <span class="nav-text"> 加密／解密</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8base64%E7%BC%96%E7%A0%81"><span class="nav-number">3.9.1.</span> <span class="nav-text"> 如何使用base64编码？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%AE%80%E5%8D%95%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="nav-number">3.9.2.</span> <span class="nav-text"> 如何简单的加密一个文件？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF"><span class="nav-number">3.10.</span> <span class="nav-text"> 错误</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BA%86%E8%A7%A3ssl%E7%9A%84%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF"><span class="nav-number">3.10.1.</span> <span class="nav-text"> 如何了解SSL的错误消息？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%86%E9%92%A5"><span class="nav-number">3.11.</span> <span class="nav-text"> 密钥</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90rsa%E7%A7%81%E9%92%A5"><span class="nav-number">3.11.1.</span> <span class="nav-text"> 如何生成RSA私钥？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90rsa%E5%85%AC%E9%92%A5"><span class="nav-number">3.11.2.</span> <span class="nav-text"> 如何生成RSA公钥？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90dsa%E5%AF%86%E9%92%A5"><span class="nav-number">3.11.3.</span> <span class="nav-text"> 如何生成DSA密钥？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E9%92%A5"><span class="nav-number">3.11.4.</span> <span class="nav-text"> 如何生成椭圆曲线密钥？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%AF%86%E5%AF%86%E9%92%A5"><span class="nav-number">3.11.5.</span> <span class="nav-text"> 如何解密密钥？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%86%E7%A0%81%E5%93%88%E5%B8%8C"><span class="nav-number">3.12.</span> <span class="nav-text"> 密码哈希</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%8A%A0%E5%AF%86%E9%A3%8E%E6%A0%BCcrypt-style%E7%9A%84%E5%AF%86%E7%A0%81%E5%93%88%E5%B8%8C%E5%80%BC"><span class="nav-number">3.12.1.</span> <span class="nav-text"> 如何生成加密风格(crypt-style)的密码哈希值？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E9%98%B4%E5%BD%B1%E9%A3%8E%E6%A0%BCshadow-style%E7%9A%84%E5%AF%86%E7%A0%81%E5%93%88%E5%B8%8C%E5%80%BC"><span class="nav-number">3.12.2.</span> <span class="nav-text"> 如何生成阴影风格(shadow-style)的密码哈希值？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A0%E6%95%B0"><span class="nav-number">3.13.</span> <span class="nav-text"> 素数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%AA%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA%E7%B4%A0%E6%95%B0"><span class="nav-number">3.13.1.</span> <span class="nav-text"> 如何测试一个数是否为素数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E4%B8%80%E7%BB%84%E7%B4%A0%E6%95%B0"><span class="nav-number">3.13.2.</span> <span class="nav-text"> 如何生成一组素数？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="nav-number">3.14.</span> <span class="nav-text"> 随机数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="nav-number">3.14.1.</span> <span class="nav-text"> 如何生成随机数？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#smime"><span class="nav-number">3.15.</span> <span class="nav-text"> S&#x2F;MIME</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E7%AD%BE%E5%90%8D%E8%BF%87%E7%9A%84smime%E6%B6%88%E6%81%AF"><span class="nav-number">3.15.1.</span> <span class="nav-text"> 如何验证签名过的S&#x2F;MIME消息？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%8A%A0%E5%AF%86smime%E6%B6%88%E6%81%AF"><span class="nav-number">3.15.2.</span> <span class="nav-text"> 如何加密S&#x2F;MIME消息？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9smime%E6%B6%88%E6%81%AF%E7%AD%BE%E5%90%8D"><span class="nav-number">3.15.3.</span> <span class="nav-text"> 如何对S&#x2F;MIME消息签名？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#bio%E6%A8%A1%E5%9D%97"><span class="nav-number">4.</span> <span class="nav-text"> BIO模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#bio%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">4.1.</span> <span class="nav-text"> BIO结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bio_method"><span class="nav-number">4.2.</span> <span class="nav-text"> BIO_METHOD</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bio%E7%9A%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">4.3.</span> <span class="nav-text"> BIO的相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bio%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="nav-number">4.3.1.</span> <span class="nav-text"> BIO的声明与释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bio%E7%9A%84%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0"><span class="nav-number">4.3.2.</span> <span class="nav-text"> BIO的控制函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bio%E7%9A%84io%E6%93%8D%E4%BD%9C"><span class="nav-number">4.3.3.</span> <span class="nav-text"> BIO的I&#x2F;O操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bio%E5%AF%B9"><span class="nav-number">4.3.4.</span> <span class="nav-text"> BIO对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bio%E9%93%BE%E6%93%8D%E4%BD%9C"><span class="nav-number">4.3.5.</span> <span class="nav-text"> BIO链操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bio%E5%88%86%E7%B1%BB"><span class="nav-number">4.4.</span> <span class="nav-text"> BIO分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sourcesink%E7%B1%BB%E5%9E%8Bbio"><span class="nav-number">4.4.1.</span> <span class="nav-text"> Source&#x2F;Sink类型BIO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8Bbio"><span class="nav-number">4.4.1.1.</span> <span class="nav-text"> 文件指针类型BIO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%B1%BB%E5%9E%8Bbio"><span class="nav-number">4.4.1.2.</span> <span class="nav-text"> 文件描述符类型BIO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#socket%E7%B1%BB%E5%9E%8Bbio"><span class="nav-number">4.4.1.3.</span> <span class="nav-text"> Socket类型BIO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#null%E5%9E%8Bbio"><span class="nav-number">4.4.1.4.</span> <span class="nav-text"> NULL型BIO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%B1%BB%E5%9E%8Bbio"><span class="nav-number">4.4.1.5.</span> <span class="nav-text"> 内存类型BIO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bio%E5%AF%B9-2"><span class="nav-number">4.4.1.6.</span> <span class="nav-text"> BIO对</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E7%B1%BB%E5%9E%8Bbio"><span class="nav-number">4.4.1.7.</span> <span class="nav-text"> 连接类型BIO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%97%E7%B1%BB%E5%9E%8Bbio"><span class="nav-number">4.4.1.8.</span> <span class="nav-text"> 接受类型BIO</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#filter%E7%B1%BB%E5%9E%8Bbio"><span class="nav-number">4.4.2.</span> <span class="nav-text"> Filter类型BIO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#null%E5%9E%8B%E8%BF%87%E6%BB%A4bio"><span class="nav-number">4.4.2.1.</span> <span class="nav-text"> NULL型过滤BIO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E7%B1%BB%E5%9E%8Bbio"><span class="nav-number">4.4.2.2.</span> <span class="nav-text"> 缓冲类型BIO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#base64%E7%B1%BB%E5%9E%8Bbio"><span class="nav-number">4.4.2.3.</span> <span class="nav-text"> Base64类型BIO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cipher%E7%B1%BB%E5%9E%8Bbio"><span class="nav-number">4.4.2.4.</span> <span class="nav-text"> Cipher类型BIO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#md%E7%B1%BB%E5%9E%8Bbio"><span class="nav-number">4.4.2.5.</span> <span class="nav-text"> MD类型BIO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ssl%E7%B1%BB%E5%9E%8Bbio"><span class="nav-number">4.4.2.6.</span> <span class="nav-text"> SSL类型BIO</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#evp%E6%A8%A1%E5%9D%97"><span class="nav-number">5.</span> <span class="nav-text"> EVP模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="nav-number">5.1.</span> <span class="nav-text"> 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84"><span class="nav-number">5.2.</span> <span class="nav-text"> 源码结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.1.</span> <span class="nav-text"> 全局函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bio%E6%89%A9%E5%85%85"><span class="nav-number">5.2.2.</span> <span class="nav-text"> BIO扩充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95%E5%B0%81%E8%A3%85"><span class="nav-number">5.2.3.</span> <span class="nav-text"> 摘要算法封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E7%AE%97%E6%B3%95%E5%B0%81%E8%A3%85"><span class="nav-number">5.2.4.</span> <span class="nav-text"> 对称算法封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E7%AE%97%E6%B3%95%E5%B0%81%E8%A3%85"><span class="nav-number">5.2.5.</span> <span class="nav-text"> 非对称算法封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%8F%A3%E4%BB%A4%E7%9A%84%E5%8A%A0%E5%AF%86"><span class="nav-number">5.2.6.</span> <span class="nav-text"> 基于口令的加密</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.</span> <span class="nav-text"> 主要函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.1.</span> <span class="nav-text"> 对称加解密函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.2.</span> <span class="nav-text"> 其他函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="nav-number">5.4.</span> <span class="nav-text"> 对称加密</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">5.4.1.</span> <span class="nav-text"> 基本数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#evp_cipher%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">5.4.1.1.</span> <span class="nav-text"> EVP_CIPHER结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#evp_cipher_ctx%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">5.4.1.2.</span> <span class="nav-text"> EVP_CIPHER_CTX结构体</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.2.</span> <span class="nav-text"> 相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.2.1.</span> <span class="nav-text"> 核心函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.2.1.1.</span> <span class="nav-text"> 底层函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86"><span class="nav-number">5.4.2.1.2.</span> <span class="nav-text"> 加密</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E5%AF%86"><span class="nav-number">5.4.2.1.3.</span> <span class="nav-text"> 解密</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.2.2.</span> <span class="nav-text"> 辅助函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%93%8D%E4%BD%9Cevp_cipher_ctx%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.2.2.1.</span> <span class="nav-text"> 操作EVP_CIPHER_CTX的函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E4%B8%8E%E8%8E%B7%E5%8F%96"><span class="nav-number">5.4.2.2.2.</span> <span class="nav-text"> 参数设置与获取</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.2.3.</span> <span class="nav-text"> 算法函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.4.2.3.1.</span> <span class="nav-text"> 分组加密的迭代模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="nav-number">5.4.2.3.2.</span> <span class="nav-text"> 加密算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">5.4.3.</span> <span class="nav-text"> 应用流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B"><span class="nav-number">5.4.4.</span> <span class="nav-text"> 程序示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%91%98%E8%A6%81"><span class="nav-number">5.5.</span> <span class="nav-text"> 摘要</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2"><span class="nav-number">5.5.1.</span> <span class="nav-text"> 基本数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#evp_md%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">5.5.1.1.</span> <span class="nav-text"> EVP_MD结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#evp_md_ctx%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">5.5.1.2.</span> <span class="nav-text"> EVP_MD_CTX结构体</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-2"><span class="nav-number">5.5.2.</span> <span class="nav-text"> 相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0-2"><span class="nav-number">5.5.2.1.</span> <span class="nav-text"> 核心函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0-2"><span class="nav-number">5.5.2.2.</span> <span class="nav-text"> 辅助函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%93%8D%E4%BD%9Cevp_md_ctx%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.2.2.1.</span> <span class="nav-text"> 操作EVP_MD_CTX的函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E4%B8%8E%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.2.2.2.</span> <span class="nav-text"> 参数设置与获取函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.2.2.3.</span> <span class="nav-text"> 摘要算法函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-2"><span class="nav-number">5.5.3.</span> <span class="nav-text"> 程序示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="nav-number">5.6.</span> <span class="nav-text"> 非对称加密</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3"><span class="nav-number">5.6.1.</span> <span class="nav-text"> 基本数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-3"><span class="nav-number">5.6.2.</span> <span class="nav-text"> 相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0-3"><span class="nav-number">5.6.2.1.</span> <span class="nav-text"> 核心函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86-2"><span class="nav-number">5.6.2.1.1.</span> <span class="nav-text"> 加密</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E5%AF%86-2"><span class="nav-number">5.6.2.1.2.</span> <span class="nav-text"> 解密</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0-3"><span class="nav-number">5.6.2.2.</span> <span class="nav-text"> 辅助函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-3"><span class="nav-number">5.6.3.</span> <span class="nav-text"> 程序示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">5.6.3.1.</span> <span class="nav-text"> 参数初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90"><span class="nav-number">5.6.3.2.</span> <span class="nav-text"> 密钥生成</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#base64%E7%BC%96%E8%A7%A3%E7%A0%81"><span class="nav-number">5.7.</span> <span class="nav-text"> BASE64编解码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">5.7.1.</span> <span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4"><span class="nav-number">5.7.2.</span> <span class="nav-text"> 基本数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-4"><span class="nav-number">5.7.3.</span> <span class="nav-text"> 相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0-4"><span class="nav-number">5.7.3.1.</span> <span class="nav-text"> 核心函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E7%A0%81"><span class="nav-number">5.7.3.1.1.</span> <span class="nav-text"> 编码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E7%A0%81"><span class="nav-number">5.7.3.1.2.</span> <span class="nav-text"> 解码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0-4"><span class="nav-number">5.7.3.2.</span> <span class="nav-text"> 辅助函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-4"><span class="nav-number">5.7.4.</span> <span class="nav-text"> 程序示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hmac"><span class="nav-number">5.8.</span> <span class="nav-text"> HMAC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5"><span class="nav-number">5.8.1.</span> <span class="nav-text"> 基本数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-5"><span class="nav-number">5.8.2.</span> <span class="nav-text"> 相关函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-5"><span class="nav-number">5.8.3.</span> <span class="nav-text"> 程序示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E6%88%90"><span class="nav-number">5.8.3.1.</span> <span class="nav-text"> 生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81"><span class="nav-number">5.8.3.2.</span> <span class="nav-text"> 验证</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="nav-number">5.9.</span> <span class="nav-text"> 数字签名</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%BE%E5%90%8D"><span class="nav-number">5.9.1.</span> <span class="nav-text"> 签名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A4%E8%AF%81"><span class="nav-number">5.9.2.</span> <span class="nav-text"> 认证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%87%E6%B3%A8"><span class="nav-number">5.9.3.</span> <span class="nav-text"> 备注</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B-6"><span class="nav-number">5.9.4.</span> <span class="nav-text"> 程序示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%BE%E5%90%8D-2"><span class="nav-number">5.9.4.1.</span> <span class="nav-text"> 签名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81-2"><span class="nav-number">5.9.4.2.</span> <span class="nav-text"> 验证</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E4%BF%A1%E5%B0%81"><span class="nav-number">5.10.</span> <span class="nav-text"> 数字信封</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E4%BF%A1"><span class="nav-number">5.10.1.</span> <span class="nav-text"> 写信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E4%BF%A1"><span class="nav-number">5.10.2.</span> <span class="nav-text"> 读信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">5.10.3.</span> <span class="nav-text"> 代码示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E4%BF%A1-2"><span class="nav-number">5.10.3.1.</span> <span class="nav-text"> 写信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E4%BF%A1-2"><span class="nav-number">5.10.3.2.</span> <span class="nav-text"> 读信</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ssl%E9%80%9A%E4%BF%A1"><span class="nav-number">6.</span> <span class="nav-text"> SSL通信</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%84%E5%BD%95"><span class="nav-number">7.</span> <span class="nav-text"> 附录</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">8.</span> <span class="nav-text"> 参考</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yufei Luo"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Yufei Luo</p>
  <div class="site-description" itemprop="description">哪怕什么真理无穷，进一寸有进一寸的欢喜</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">89</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x5ZjM1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lyf35"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmx5ZjEyMzQwMDAwMDBAMTYzLmNvbQ==" title="E-Mail → mailto:lyf1234000000@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



      </section>
        <div class="back-to-top animated">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x5ZjM1" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lyf35.github.io/2020/10/15/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8-OpenSSL%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E6%91%98%E5%BD%95%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Yufei Luo">
      <meta itemprop="description" content="哪怕什么真理无穷，进一寸有进一寸的欢喜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yufei Luo's Blog">
    </span>

    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          信息安全-OpenSSL的基本使用（摘录）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-15 13:20:36" itemprop="dateCreated datePublished" datetime="2020-10-15T13:20:36+08:00">2020-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-05 22:14:05" itemprop="dateModified" datetime="2021-01-05T22:14:05+08:00">2021-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/" itemprop="url" rel="index"><span itemprop="name">工程实践</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">信息安全</span></a>
                </span>
            </span>

          
            <span id="/2020/10/15/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8-OpenSSL%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E6%91%98%E5%BD%95%EF%BC%89/" class="post-meta-item leancloud_visitors" data-flag-title="信息安全-OpenSSL的基本使用（摘录）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>100k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:31</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<p>OpenSSL是一个C语言实现的，功能丰富且自包含的安全工具箱，提供的主要功能包括SSL协议实现、加密解密算法、非对称算法的密钥生成、数字证书验证等。</p>
<p>OpenSSL Manual: <span class="exturl" data-url="aHR0cHM6Ly93d3cub3BlbnNzbC5vcmcvZG9jcy9tYW4xLjEuMS9tYW43Lw==">https://www.openssl.org/docs/man1.1.1/man7/<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="安装与使用"><a class="markdownIt-Anchor" href="#安装与使用"></a> 安装与使用</h1>
<p>在linux系统下面，可以使用apt-get命令安装OpenSSL和libssl-dev（这个必须安装，包含了lib和header等信息，安装之后才能在c/cpp程序中使用OpenSSL的函数）。</p>
<p>如果是简单地对文件做一些加密或者哈希等操作，只需要在命令行中执行openssl ……就可以，结果会直接打印在命令行内。</p>
<p>如果在c/cpp程序中使用了OpenSSL函数，编译的时候使用这一命令：g++ test.cpp -lssl -lcrypto，后两个编译选项是为了在编译的时候将OpenSSL的函数库链接进去。</p>
<a id="more"></a>
<h1 id="bash命令"><a class="markdownIt-Anchor" href="#bash命令"></a> Bash命令</h1>
<p>注：本文的Bash命令部分来自于https://github.com/theno/openssl-examples/blob/master/links.md</p>
<h2 id="查看openssl是什么版本"><a class="markdownIt-Anchor" href="#查看openssl是什么版本"></a> 查看OpenSSL是什么版本？</h2>
<p>使用version选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ openssl version</span><br><span class="line">OpenSSL 0.9.8zh 14 Jan 2016</span><br></pre></td></tr></table></figure>
<p>跟上-a选项能得到更多的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ openssl versoin -a</span><br><span class="line">OpenSSL 0.9.8zh 14 Jan 2016</span><br><span class="line">built on: May 15 2016</span><br><span class="line">platform: darwin64-x86_64-llvm</span><br><span class="line">options:  bn(64,64) md2(int) rc4(ptr,char) des(idx,cisc,16,int) blowfish(idx)</span><br><span class="line">compiler: -arch x86_64 -fmessage-length&#x3D;0 -pipe -Wno-trigraphs -fpascal-strings -fasm-blocks -O3 -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -DL_ENDIAN -DMD32_REG_T&#x3D;int -DOPENSSL_NO_IDEA -DOPENSSL_PIC -DOPENSSL_THREADS -DZLIB -mmacosx-version-min&#x3D;10.6</span><br><span class="line">OPENSSLDIR: &quot;&#x2F;System&#x2F;Library&#x2F;OpenSSL&quot;</span><br></pre></td></tr></table></figure>
<h2 id="查看有哪些命令选项"><a class="markdownIt-Anchor" href="#查看有哪些命令选项"></a> 查看有哪些命令选项？</h2>
<p>内置的查看命令(比如openssl list-standard-commands)只能查出一组，有个技巧是加上一个无效的选项(比如help或-h)，就可以得到所有的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ openssl help</span><br><span class="line">openssl:Error: &#39;help&#39; is an invalid command.</span><br><span class="line"></span><br><span class="line">Standard commands</span><br><span class="line">asn1parse      ca             ciphers        crl            crl2pkcs7</span><br><span class="line">dgst           dh             dhparam        dsa            dsaparam</span><br><span class="line">ec             ecparam        enc            engine         errstr</span><br><span class="line">gendh          gendsa         genrsa         nseq           ocsp</span><br><span class="line">passwd         pkcs12         pkcs7          pkcs8          prime</span><br><span class="line">rand           req            rsa            rsautl         s_client</span><br><span class="line">s_server       s_time         sess_id        smime          speed</span><br><span class="line">spkac          verify         version        x509</span><br><span class="line"></span><br><span class="line">Message Digest commands (see the &#96;dgst&#39; command for more details)</span><br><span class="line">md2            md4            md5            mdc2           rmd160</span><br><span class="line">sha            sha1</span><br><span class="line"></span><br><span class="line">Cipher commands (see the &#96;enc&#39; command for more details)</span><br><span class="line">aes-128-cbc    aes-128-ecb    aes-192-cbc    aes-192-ecb    aes-256-cbc</span><br><span class="line">aes-256-ecb    base64         bf             bf-cbc         bf-cfb</span><br><span class="line">bf-ecb         bf-ofb         cast           cast-cbc       cast5-cbc</span><br><span class="line">cast5-cfb      cast5-ecb      cast5-ofb      des            des-cbc</span><br><span class="line">des-cfb        des-ecb        des-ede        des-ede-cbc    des-ede-cfb</span><br><span class="line">des-ede-ofb    des-ede3       des-ede3-cbc   des-ede3-cfb   des-ede3-ofb</span><br><span class="line">des-ofb        des3           desx           rc2            rc2-40-cbc</span><br><span class="line">rc2-64-cbc     rc2-cbc        rc2-cfb        rc2-ecb        rc2-ofb</span><br><span class="line">rc4            rc4-40         seed           seed-cbc       seed-cfb</span><br><span class="line">seed-ecb       seed-ofb</span><br></pre></td></tr></table></figure>
<p>所谓“Standard commands”就是openssl后跟的第一个命令选项，可以使用同样的技巧查看有哪些可执行的子选项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ openssl dgst -h</span><br><span class="line">unknown option &#39;-h&#39;</span><br><span class="line">options are</span><br><span class="line">-c              to output the digest with separating colons</span><br><span class="line">-d              to output debug info</span><br><span class="line">-hex            output as hex dump</span><br><span class="line">-binary         output in binary form</span><br><span class="line">-sign   file    sign digest using private key in file</span><br><span class="line">-verify file    verify a signature using public key in file</span><br><span class="line">-prverify file  verify a signature using private key in file</span><br><span class="line">-keyform arg    key file format (PEM or ENGINE)</span><br><span class="line">-signature file signature to verify</span><br><span class="line">-binary         output in binary form</span><br><span class="line">-hmac key       create hashed MAC with key</span><br><span class="line">-engine e       use engine e, possibly a hardware device.</span><br><span class="line">-md5            to use the md5 message digest algorithm (default)</span><br><span class="line">-md4            to use the md4 message digest algorithm</span><br><span class="line">-md2            to use the md2 message digest algorithm</span><br><span class="line">-sha1           to use the sha1 message digest algorithm</span><br><span class="line">-sha            to use the sha message digest algorithm</span><br><span class="line">-sha224         to use the sha224 message digest algorithm</span><br><span class="line">-sha256         to use the sha256 message digest algorithm</span><br><span class="line">-sha384         to use the sha384 message digest algorithm</span><br><span class="line">-sha512         to use the sha512 message digest algorithm</span><br><span class="line">-mdc2           to use the mdc2 message digest algorithm</span><br><span class="line">-ripemd160      to use the ripemd160 message digest algorithm</span><br></pre></td></tr></table></figure>
<p>你也可是使用man openssl查看详细。</p>
<h2 id="查看支持哪些算法"><a class="markdownIt-Anchor" href="#查看支持哪些算法"></a> 查看支持哪些算法？</h2>
<p>使用ciphers选项，更多用法参见<span class="exturl" data-url="aHR0cHM6Ly93d3cub3BlbnNzbC5vcmcvZG9jcy9tYW5tYXN0ZXIvYXBwcy9jaXBoZXJzLmh0bWw=">ciphers的说明文档<i class="fa fa-external-link-alt"></i></span>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有可用的算法</span><br><span class="line">openssl ciphers -v</span><br><span class="line"></span><br><span class="line"># 列出符合TLSv1协议的算法</span><br><span class="line">openssl ciphers -v -tls1</span><br><span class="line"></span><br><span class="line"># 列出高级别加密的算法(密钥长度大于128位)</span><br><span class="line">openssl ciphers -v &#39;HIGH&#39;</span><br><span class="line"></span><br><span class="line"># 列出使用了AES的高级别加密算法</span><br><span class="line">openssl ciphers -v &#39;AES+HIGH&#39;</span><br></pre></td></tr></table></figure>
<h2 id="性能测试"><a class="markdownIt-Anchor" href="#性能测试"></a> 性能测试</h2>
<h3 id="如何测试当前系统的运算性能"><a class="markdownIt-Anchor" href="#如何测试当前系统的运算性能"></a> 如何测试当前系统的运算性能？</h3>
<p>OpenSSL的开发者在库里内置了测性能的套件，通过speed命令选项来使用。它测试在给定的时间内可以进行多少运算，而不是指定的运算需要多少时间。这样处理是很合理的，因此测试程序在性能好坏的系统上运行的时间不会相差太多。<br />
只使用speed选项，测试所有算法的性能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl speed</span><br></pre></td></tr></table></figure>
<p>有两组结果，第一组表示指定的算法每秒可以处理多少字节的数据，第二组表示一次签名／验证花费的时间。<br />
下面是在2.7GHZ Intel Xeon E5处理器上的测试结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">The &#39;numbers&#39; are in 1000s of bytes per second processed.</span><br><span class="line">type             16 bytes     64 bytes    256 bytes   1024 	bytes   8192 bytes</span><br><span class="line">md2               2540.48k     5184.66k     6989.57k     7651.67k     7872.51k</span><br><span class="line">mdc2                 0.00         0.00         0.00         0.00         0.00</span><br><span class="line">md4              83248.41k   261068.18k   624212.82k   940529.32k  1128846.68k</span><br><span class="line">md5              62411.57k   184768.36k   408835.75k   586930.52k   678061.98k</span><br><span class="line">hmac(md5)        48713.62k   148265.56k   359626.67k   563050.68k   670255.79k</span><br><span class="line">sha1             68829.72k   195087.40k   431001.51k   623344.42k   729505.79k</span><br><span class="line">rmd160           38598.59k    96226.86k   183336.45k   235962.71k   257526.44k</span><br><span class="line">rc4             480093.57k   678565.35k   783765.42k   818297.51k   838205.99k</span><br><span class="line">des cbc          69500.17k    71184.75k    71491.50k    71641.77k    72010.15k</span><br><span class="line">des ede3         26433.63k    26717.01k    26772.99k    26788.18k    26907.57k</span><br><span class="line">idea cbc         95690.28k    99334.17k   100835.40k   100787.54k   100900.86k</span><br><span class="line">seed cbc         76871.40k    77238.46k    77736.50k    77452.97k    77545.47k</span><br><span class="line">rc2 cbc          48984.63k    49589.03k    50188.07k    50103.98k    50066.77k</span><br><span class="line">rc5-32&#x2F;12 cbc        0.00         0.00         0.00         0.00         0.00</span><br><span class="line">blowfish cbc    122583.30k   129550.92k   130876.67k   131111.94k   131394.22k</span><br><span class="line">cast cbc        109471.38k   114523.31k   115934.46k   116200.45k   116331.86k</span><br><span class="line">aes-128 cbc     128352.23k   138604.76k   141173.42k   142832.25k   142682.79k</span><br><span class="line">aes-192 cbc     107703.93k   114456.79k   117716.65k   118847.36k   118784.00k</span><br><span class="line">aes-256 cbc      93374.87k    99521.51k   101198.51k   101382.49k   101635.41k</span><br><span class="line">camellia-128 cbc    99270.57k   150412.42k   170346.33k   176311.91k   177913.86k</span><br><span class="line">camellia-192 cbc    85896.60k   117356.52k   128556.97k   132759.72k   133425.83k</span><br><span class="line">camellia-256 cbc    87351.27k   117695.15k   128972.03k   132130.47k   133455.87k</span><br><span class="line">sha256           52372.61k   117766.12k   204825.69k   249974.10k   270914.90k</span><br><span class="line">sha512           41278.19k   165820.37k   258298.69k   365981.70k   419864.58k</span><br><span class="line">whirlpool        24803.02k    53047.07k    87593.90k   104570.54k   111159.98k</span><br><span class="line">aes-128 ige     128441.31k   132981.88k   133269.08k   133738.15k   133966.51k</span><br><span class="line">aes-192 ige     107831.37k   111507.07k   111800.66k   112156.67k   112219.48k</span><br><span class="line">aes-256 ige      94382.07k    96351.17k    96750.68k    96958.46k    97446.44k</span><br><span class="line">ghash           888644.92k  1452788.80k  1696788.74k  1763055.96k  1799086.49k</span><br><span class="line">              	sign    verify    sign&#x2F;s verify&#x2F;s</span><br><span class="line">rsa  512 bits 0.000049s 0.000004s  20547.1 248266.2</span><br><span class="line">rsa 1024 bits 0.000194s 0.000011s   5146.0  90735.4</span><br><span class="line">rsa 2048 bits 0.001194s 0.000037s    837.3  27277.1</span><br><span class="line">rsa 4096 bits 0.008560s 0.000137s    116.8   7324.5</span><br><span class="line">              	sign    verify    sign&#x2F;s verify&#x2F;s</span><br><span class="line">dsa  512 bits 0.000048s 0.000046s  20667.7  21701.8</span><br><span class="line">dsa 1024 bits 0.000113s 0.000126s   8831.9   7951.8</span><br><span class="line">dsa 2048 bits 0.000362s 0.000430s   2762.0   2322.9</span><br><span class="line">                          	sign    verify    sign&#x2F;s verify&#x2F;s</span><br><span class="line">256 bit ecdsa (nistp256)   0.0001s   0.0004s   9856.1   2524.4</span><br><span class="line">384 bit ecdsa (nistp384)   0.0002s   0.0008s   5103.6   1191.7</span><br><span class="line">521 bit ecdsa (nistp521)   0.0004s   0.0018s   2679.0    550.3</span><br><span class="line">                          	op      op&#x2F;s</span><br><span class="line">256 bit ecdh (nistp256)   0.0003s   3063.8</span><br><span class="line">384 bit ecdh (nistp384)   0.0007s   1447.3</span><br><span class="line">521 bit ecdh (nistp521)   0.0015s    666.2</span><br></pre></td></tr></table></figure>
<p>也可以只测试指定的算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 测试RSA的速度</span><br><span class="line">openssl speed rsa</span><br><span class="line"></span><br><span class="line"># 在多核系统中并行两组测试</span><br><span class="line">openssl speed rsa -multi 2</span><br></pre></td></tr></table></figure>
<h3 id="如何测试远程连接的耗时"><a class="markdownIt-Anchor" href="#如何测试远程连接的耗时"></a> 如何测试远程连接的耗时？</h3>
<p>使用s_time选项可以测试连接性能，直接调用会运行30秒，使用任意的加密算法，统计每秒钟通过SSL握手建立的连接数，结果分为新会话和重用会话两组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl s_time -connect romete.host:443</span><br><span class="line"># 译者注：可以拿百度来测试</span><br><span class="line">openssl s_time -connect baidu.com:443</span><br></pre></td></tr></table></figure>
<p>除了直接调用外，s_time选项也提供了很多测试的子选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">＃ 只通过新会话获取远端test.html页面</span><br><span class="line">openssl s_time -connect remote.host:443 -www &#x2F;test.html -new</span><br><span class="line"></span><br><span class="line"># 使用SSL v3和高级别加密算法</span><br><span class="line">openssl s_time \</span><br><span class="line">	-connect remote.hot:443 -www &#x2F;test.html -new \</span><br><span class="line">	-ssl3 -cipher HIGH</span><br><span class="line">	</span><br><span class="line"># 测试不同加密算法的性能，每种算法测试10秒</span><br><span class="line">IFS&#x3D;&quot;:&quot;</span><br><span class="line">for c in $(openssl ciphers -ssl3 RSA); do</span><br><span class="line">	echo $C</span><br><span class="line">	openssl s_time -connect remote.host:443 \</span><br><span class="line">		-www &#x2F; -new -time 10 -cipher $c 2&gt;&amp;1 | \</span><br><span class="line">		grep bytes</span><br><span class="line">	echo</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>如果你没有可测的启用SSL的服务端，可以使用s_server选项来创建一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">＃ 在一台主机上创建服务端，默认使用4433端口</span><br><span class="line">openssl s_server -cert mycert.pem -www</span><br><span class="line"></span><br><span class="line"># 在另一台主机上(可以跟服务端同一台)，运行s_time</span><br><span class="line">openssl s_time -connect myhost:4433 -www &#x2F; -new -ssl3</span><br></pre></td></tr></table></figure>
<h2 id="证书"><a class="markdownIt-Anchor" href="#证书"></a> 证书</h2>
<h3 id="如何生成自签名的证书"><a class="markdownIt-Anchor" href="#如何生成自签名的证书"></a> 如何生成自签名的证书？</h3>
<p>首先考虑是否要对私钥进行加密。<br />
加密私钥的好处是更加安全，有人拿走了也无法使用。坏处是需要把密码保存在某个文件或每次启动服务时手动输入。<br />
我个人倾向不加密私钥，这样不用每次手动输入。（当你厌烦输入时，要知道去除密码保护也是可以的。）<br />
下面的例子会生成一个mycert.pem证书文件，其中证书的有效期是365天，私钥不加密(-ndoes决定的)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl req \</span><br><span class="line">	-x509 -nodes -days 365 -sha256 \</span><br><span class="line">	-newkey rsa:2048 -keyout mycert.pem -out mycert.pem</span><br></pre></td></tr></table></figure>
<p>这个文件中有两部分信息：RSA私钥和证书。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat mycert.pem</span><br><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">...</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">...</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure>
<p>证书部分包含公钥。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -in mycert.pem -pubkey -noout</span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">...</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure>
<p>使用这个指令后，会要求你回答一系列的问题：国家，省市，公司，职位等等。当回答“Common  Name”这个问题要注意点，你可能会填写主机名或域名，<span class="exturl" data-url="aHR0cDovL3huLS1teWJveC1rODZodDl0enRiZWVxNHYxdGdyMTBia21jZ3RjczQxaTQ5Yi5teWRvbWFpbi5jb20=">如果服务器的真实地址是mybox.mydomain.com<i class="fa fa-external-link-alt"></i></span>，但用户是通过www.mydomain.com来访问的，那么你应填写用户访问的地址。<br />
可以通过-subj选项来直接写入这些回答，对生成证书来说惟一有用的就是Common Name(CN)字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl req \</span><br><span class="line">	-x509 -nodes -days 365 -sha256 \</span><br><span class="line">	-subj &#39;&#x2F;C&#x3D;US&#x2F;ST&#x3D;Oregon&#x2F;L&#x3D;Portland&#x2F;CN&#x3D;www.madboa.com&#39; \</span><br><span class="line">	-newkey rsa:2048 -keyout mycert.pem -out mycert.pem</span><br></pre></td></tr></table></figure>
<h3 id="如何生成verisign的证书请求"><a class="markdownIt-Anchor" href="#如何生成verisign的证书请求"></a> 如何生成VeriSign的证书请求？</h3>
<p>向认证机构(比如VeriSign)申请签名证书是相当繁杂和官僚的，在创建证书请求前要先准备好需要的书面文件(营业执照等)。<br />
上一节说到，你需要考虑是否加密私钥，下面的例子假设不加密，最后会得到两个文件：私钥文件mykey.pem，证书请求文件myreq.pem。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl req \</span><br><span class="line">	-new -sha256 -newkey rsa:2048 -nodes \</span><br><span class="line">	-keyout mykey.pem -out myreq.pem</span><br></pre></td></tr></table></figure>
<p>如果是使用已有的私钥文件生成证书请求，语法更简单点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key mykey.pem -out myreq.pem</span><br></pre></td></tr></table></figure>
<p>同样的，你也可以在命令中直接写入要回答的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl req \</span><br><span class="line">	-new -sha256 -newkey rsa:2048 -nodes \</span><br><span class="line">	-subj &#39;&#x2F;CN&#x3D;www.mydom.com&#x2F;O&#x3D;My Dom. Inc.&#x2F;C&#x3D;US&#x2F;ST&#x3D;Oregon&#x2F;L&#x3D;Portland&#39; \</span><br><span class="line">	-keyout mykey.pem -out myreq.pem</span><br></pre></td></tr></table></figure>
<p>在跟像VeriSign这样的机构打交道时，要特别注意在创建证书请求时填写的信息。根据我个人的经验，比如填写组织名字时用and代替&amp;，都会造成申请不通过。<br />
需要仔细确认证书请求中的签名、组织等信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 验证签名</span><br><span class="line">openssl req -in myreq.pem -noout -verify -key mykey.pem</span><br><span class="line"># 检查信息</span><br><span class="line">openssl req -in myreq.pem -noout -text</span><br></pre></td></tr></table></figure>
<p>将私钥文件保存在安全的地方，要使用VeriSign发回给你证书必须要用到它。证书请求一般是通过VeriSign的线上表单提交。</p>
<h3 id="如何测试一个新证书"><a class="markdownIt-Anchor" href="#如何测试一个新证书"></a> 如何测试一个新证书？</h3>
<p>s_server选项提供了一个简单有效的测试方法。下面的例子假设你已经把私钥和证书合并为一个文件(也可以是上面生成的自签名证书)：mycert.pem。<br />
首先启动测试服务端，默认使用4433端口，可以使用-accept选项修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl s_server -cert mycert.pem -www</span><br></pre></td></tr></table></figure>
<p>如果服务端正常启动，没有报错信息，说明证书就可以使用了。<br />
可以在浏览器里访问测试服务器https://yourserver:4433/。注意是https，打开这个界面可以看到可用的加密算法以及连接相关的统计。如果是自签名的证书，浏览器会提示你是否相信此证书。<br />
怎么得到远端的证书？<br />
只要配合使用openssl和sed命令，就能取到远端的证书信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">#</span><br><span class="line"># usage: retrieve-cert.sh remote.host.name [port]</span><br><span class="line">#</span><br><span class="line">REMHOST&#x3D;$1</span><br><span class="line">REMPORT&#x3D;$&#123;2:-443&#125;</span><br><span class="line"></span><br><span class="line">echo |\</span><br><span class="line">openssl s_client -connect $&#123;REMHOST&#125;:$&#123;REMPORT&#125; 2&gt;&amp;1 |\</span><br><span class="line">sed -ne &#39;&#x2F;-BEGIN CERTIFICATE-&#x2F;,&#x2F;-END CERTIFICATE-&#x2F;p&#39;</span><br></pre></td></tr></table></figure>
<p>也可以把得到信息再交给openssl处理，比如检查证书的日期：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">#</span><br><span class="line">for CERT in \</span><br><span class="line">	www.yourdomain.com:443 \</span><br><span class="line">	ldap.yourdomain.com:636 \</span><br><span class="line">	imap.yourdomain.com:993</span><br><span class="line">do</span><br><span class="line">	echo |\</span><br><span class="line">	openssl s_client -connect $&#123;CERT&#125; 2&gt;&#x2F;dev&#x2F;null |\</span><br><span class="line">	sed -ne &#39;&#x2F;-BEGIN CERTIFICATE-&#x2F;,&#x2F;-END CERTIFICATE-&#x2F;p&#39; |\</span><br><span class="line">	openssl x509 -noout -subject -dates</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>怎么查看证书中的信息？<br />
一个SSL证书包含很多信息：颁发者，有效期，持有者，算法，公钥等。使用x509选项可以查看这些信息，下面的例子假设有一个名为cert.pem的证书文件。<br />
使用-text选项能同时以可读文本的形式展示信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -text -in cert.pem</span><br></pre></td></tr></table></figure>
<p>还有一些选项可以指定展示某项信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 查看颁发者</span><br><span class="line">openssl x509 -noout -in cert.pem -issuer</span><br><span class="line"></span><br><span class="line"># 查看持有者</span><br><span class="line">openssl x509 -noout -in cert.pem -subject</span><br><span class="line"></span><br><span class="line"># 有效期</span><br><span class="line">openssl x509 -noout -in cert.pem -dates</span><br><span class="line"></span><br><span class="line"># 以上全部</span><br><span class="line">openssl x509 -noout -in cert.pem -issuer -subject -dates</span><br><span class="line"></span><br><span class="line"># 哈希值</span><br><span class="line">openssl x509 -noout -in cert.pem -hash</span><br><span class="line"></span><br><span class="line"># MD5指纹</span><br><span class="line">openssl x509 -noout -in cert.pem -fingerprint</span><br></pre></td></tr></table></figure>
<h3 id="如何导入导出pkcs12格式的证书"><a class="markdownIt-Anchor" href="#如何导入导出pkcs12格式的证书"></a> 如何导入／导出PKCS#12格式的证书？</h3>
<p>PKCS#12格式的证书被许多程序使用，比如微软的IIS，这种证书文件的后缀通常是.pfx。<br />
创建PKCS#12格式的证书，需要私钥和证书。转换时，你会被要求输入密码(可以为空)来对证书进行加密。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个包含私钥的自签名证书</span><br><span class="line">openssl req \</span><br><span class="line">	-x509 -sha256 -nodes -days 365 \</span><br><span class="line">	-newkey rsa:2048 -keyout mycert.pem -out mycert.pem</span><br><span class="line">	</span><br><span class="line"># 将mycert.pem导出为PKCS#12格式的证书，mycert.pfx</span><br><span class="line">openssl pkcs12 -export \</span><br><span class="line">	-out mycert.pfx -in mycert.pem \</span><br><span class="line">	-name &quot;My Certificate&quot;</span><br></pre></td></tr></table></figure>
<p>如果你拿到PKCS#12格式的证书和它的密码(如果有的话)，可以把它导出为标准的PEM格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 无密码情况下</span><br><span class="line">openssl pkcs12 -in mycert.pfx -out mycert.pem -nodes</span><br><span class="line"></span><br><span class="line"># 有密码情况下</span><br><span class="line">openssl pkcs12 -in mycert.pfx -out mycert.pem</span><br></pre></td></tr></table></figure>
<h2 id="证书验证"><a class="markdownIt-Anchor" href="#证书验证"></a> 证书验证</h2>
<p>使用OpenSSL库可以验证授权机构颁发的证书</p>
<h3 id="如何验证证书"><a class="markdownIt-Anchor" href="#如何验证证书"></a> 如何验证证书？</h3>
<p>使用verify选项来验证证书。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl verify cert.pem</span><br></pre></td></tr></table></figure>
<p>验证成功，会返回“OK”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ openssl verify mycert.pem</span><br><span class="line">mycert.pem: &#x2F;C&#x3D;CN&#x2F;ST&#x3D;JS&#x2F;L&#x3D;WX&#x2F;O&#x3D;Internet Widgits Pty Ltd&#x2F;CN&#x3D;Calle Zhang</span><br><span class="line">error 18 at 0 depth lookup:self signed certificate</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>如果异常会看到错误消息，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">证书过期，通常证书都是有有效期的，一般是一年：</span><br><span class="line">error 10 at 0 depth lookup:certificate has expired</span><br><span class="line"></span><br><span class="line">自签名证书：</span><br><span class="line">error 18 at 0 depth lookup:self signed certificate</span><br></pre></td></tr></table></figure>
<h3 id="openssl都认可哪些证书颁发机构"><a class="markdownIt-Anchor" href="#openssl都认可哪些证书颁发机构"></a> OpenSSL都认可哪些证书颁发机构？</h3>
<p>在编译OpenSSL库时需要制定OpenSSL的文件目录(–openssldir参数指定)，这个目录保存着认可的证书颁发机构信息。<br />
默认的目录是/usr/local/ssl，很多操作系统会把它放到别处，比如/usr/share/ssl(Red  Hat/Fedora)，/etc/ssl(Gentoo)，/usr/lib/ssl(Debian)，/System/Library/OpenSSL(Macintosh OS X)。<br />
使用version选项加上-d查看目录在什么位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl version -d</span><br></pre></td></tr></table></figure>
<p>这个目录下有个certs子目录，在certs里可能会有三种类型的文件：</p>
<ol>
<li>
<p>有一个名为cert.pem的大文件，里面包含了许多认可机构(比如VeriSign，Thawte)的证书。</p>
</li>
<li>
<p>一些以.pem为后缀的小文件，每个文件包含一个认可机构的一个证书。</p>
</li>
<li>
<p>一些奇怪名字的链接文件，比如052eae11.0，通常是指向.pem文件。这个文件名字的第一部分其实是.pem文件里证书的hash值，后缀是序列号，因为多个链接文件可以指向同一证书。以我的Gentoo系统为例，有个指向vsignss.pem的链接文件叫f73e89fd.0，可以肯定里面证书的哈希值就是这个文件名：</p>
<p>$ openssl x509 -noout -hash -in vsingss.pem f73e89fd 当OpenSSL要验证一个证书，它会查看cert.pem里面是否包含这个证书，如果没有再查看这个目录下是否存在以证书哈希值为名的文件，如果存在就验证通过。有意思的是，有些程序(比如Sendmail)会在运行时让你指定你信任证书的存储位置。</p>
</li>
</ol>
<h3 id="如何让openssl信任某个证书"><a class="markdownIt-Anchor" href="#如何让openssl信任某个证书"></a> 如何让OpenSSL信任某个证书？</h3>
<p>把这个证书放入上文说的certs目录下，然后创建一个以哈希值命名的链接文件，下面的脚本可以完成这样的任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">#</span><br><span class="line"># usage: certlink.sh filename [filename ...]</span><br><span class="line"></span><br><span class="line">for CERTFILE in $*; do</span><br><span class="line">	# make sure file exists and is a valid cert</span><br><span class="line">	test -f &quot;$CERTFILE&quot; || continue</span><br><span class="line">	HASH&#x3D;$(openssl x509 -noout -hash -in &quot;$CERTFILE&quot;)</span><br><span class="line">	test -n &quot;$HASH&quot; || continue</span><br><span class="line"></span><br><span class="line">	# use lowest available iterator for symlink</span><br><span class="line">	for ITER in 0 1 2 3 4 5 6 7 8 9; do</span><br><span class="line">		test -f &quot;$&#123;HASH&#125;.$&#123;ITER&#125;&quot; &amp;&amp; continue</span><br><span class="line">		ln -s &quot;$CERTFILE&quot; &quot;$&#123;HASH&#125;.$&#123;ITER&#125;&quot;</span><br><span class="line">		test -L &quot;$&#123;HASH&#125;.$&#123;ITER&#125;&quot; &amp;&amp; break</span><br><span class="line">	done</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="命令行客户端和服务端"><a class="markdownIt-Anchor" href="#命令行客户端和服务端"></a> 命令行客户端和服务端</h2>
<p>s_client和s_server选项可以启动使用了SSL的命令行客户端和服务端。<br />
这部分，假设你已经熟悉这些常见的协议：SMTP，HTTP等。</p>
<h3 id="如何与smtp服务建立安全连接"><a class="markdownIt-Anchor" href="#如何与smtp服务建立安全连接"></a> 如何与SMTP服务建立安全连接？</h3>
<p>你可以通过s_client选项测试甚至使用一个使用SSL的SMTP服务端。<br />
SMTP服务的安全连接使用3个端口：25(TLS)，465(SSL)和587(TLS)。OpenSSL大概是在0.9.7版本之后提供了-starttls选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 25(TLS)端口，587(TLS)端口也是一样的</span><br><span class="line">openssl s_client -connect remote.host:25 -starttls smtp</span><br><span class="line"></span><br><span class="line"># 465(SSL)端口</span><br><span class="line">openssl s_client -connect remote.host:456</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMDgyMS50eHQ=">RFC821<i class="fa fa-external-link-alt"></i></span>建议使用作为行结束符。虽然大多数的邮件服务都是以或作为行结束符的，但Qmail就不是。如果你想遵从RFC821或是要与Qmail通信，可以使用-crlf选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl s_client -connect remote.host:25 -crlf -starttls smtp</span><br></pre></td></tr></table></figure>
<h3 id="如何其它服务建立安全连接"><a class="markdownIt-Anchor" href="#如何其它服务建立安全连接"></a> 如何其它服务建立安全连接？</h3>
<p>与其它服务建立安全连接本质上与上文是相同的操作。截止本文的写作日期，OpenSSL只支持命令行通过TLS连接SMTP服务，如果想连接其它服务，就只能直接使用SSL连接了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># HTTPS</span><br><span class="line">openssl s_client -connect remote.host:443</span><br><span class="line"></span><br><span class="line"># LDAPS</span><br><span class="line">openssl s_client -connect remote.host:636</span><br><span class="line"></span><br><span class="line"># IMAPS</span><br><span class="line">openssl s_client -connect remote.host:993</span><br><span class="line"></span><br><span class="line"># POP3S</span><br><span class="line">openssl s_client -connect remote.host:995</span><br></pre></td></tr></table></figure>
<h3 id="如何使用命令行搭建一个ssl服务端"><a class="markdownIt-Anchor" href="#如何使用命令行搭建一个ssl服务端"></a> 如何使用命令行搭建一个SSL服务端？</h3>
<p>s_server选项可以搭建一个SSL服务端，仅限测试、调试时使用，如果要在生产环境启用安全连接，可以考虑使用<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3R1bm5lbC5vcmc=">Stunnel<i class="fa fa-external-link-alt"></i></span>。<br />
有证书后就可以通过s_server选项搭建服务了，可以搭建多个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># -www选项表示，服务端返回一个OpenSSL运行状态的HTML页面</span><br><span class="line">openssl s_server -cert mycert.pem -www</span><br><span class="line"></span><br><span class="line"># 使用-WWW选项，可以访问当前目录下的文件。指定了443端口(默认4433端口)。</span><br><span class="line">openssl s_server -accept 443 -cert mycert.pem -WWW</span><br></pre></td></tr></table></figure>
<h2 id="哈希运算"><a class="markdownIt-Anchor" href="#哈希运算"></a> 哈希运算</h2>
<p>在OpenSSL库中，计算哈希通过dgst选项来操作。哈希运算十分常见，都有专门计算哈希的工具。</p>
<h3 id="如何计算一个文件的md5或sha1哈希值"><a class="markdownIt-Anchor" href="#如何计算一个文件的md5或sha1哈希值"></a> 如何计算一个文件的MD5或SHA1哈希值？</h3>
<p>使用dgst选项，先使用openssl dgst -h命令来查看有哪些可用的哈希算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># MD5</span><br><span class="line">openssl dgst -md5 filename</span><br><span class="line"></span><br><span class="line"># SHA1</span><br><span class="line">openssl dgst -sha1 filename</span><br><span class="line"></span><br><span class="line"># SHA256</span><br><span class="line">openssl dgst -sha256 filename</span><br></pre></td></tr></table></figure>
<h3 id="如何签名一个哈希值"><a class="markdownIt-Anchor" href="#如何签名一个哈希值"></a> 如何签名一个哈希值？</h3>
<p>如果想确保得到的哈希值不被篡改，可以使用私钥对这个哈希值签名。下面的例子展示对foo-1.23.tar.gz这个文件的SHA256值进行签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 签名过的哈希值是f00-1.23.tar.gz.sha1</span><br><span class="line">openssl dgst -sha256 \</span><br><span class="line">	-sign mykey.pem \</span><br><span class="line">	-out foo-1.23.tar.gz.sha1 \</span><br><span class="line">	foo-1.23.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="如何验证一个签名的哈希值"><a class="markdownIt-Anchor" href="#如何验证一个签名的哈希值"></a> 如何验证一个签名的哈希值？</h3>
<p>验证一个签名的哈希值需要原始文件以及签名者的公钥(openssl rsa -in mycert.pem -pubout -out pubkey.pem)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用foo-1.23.tar.gz.sha1和pubkey.pem验证foo-1.23.tar.gz</span><br><span class="line">openssl dgst -sha256 \</span><br><span class="line">	-verify pubkey.pem \</span><br><span class="line">	-signature foo-1.23.tar.gz.sha1 \</span><br><span class="line">	foo-1.23.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="如何创建符合apache要求的认证信息"><a class="markdownIt-Anchor" href="#如何创建符合apache要求的认证信息"></a> 如何创建符合Apache要求的认证信息？</h3>
<p>Apache的HTTP哈希认证需要指定的密码格式。Apache提供有htdigest工具，但只能将结果输出到文件。我们可以手动的往本地密码数据库添加认证信息。<br />
密码数据库的数据格式是比较简单的，有三部分：用户名，授权名，用户名加授权名加密码的MD5值，三部分以冒号分割。下面的脚本使用OpenSSL的dgst选项输出符合Apache要求的认证信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">echo &quot;Create an Apache-friendly Digest Password Entry&quot;</span><br><span class="line">echo &quot;-----------------------------------------------&quot;</span><br><span class="line"></span><br><span class="line"># get user input, disabling tty echoing for password</span><br><span class="line">read -p &quot;Enter username: &quot; UNAME</span><br><span class="line">read -p &quot;Enter Apache AuthName: &quot; AUTHNAME</span><br><span class="line">read -s -p &quot;Enter password: &quot; PWORD; echo</span><br><span class="line"></span><br><span class="line">printf &quot;\n%s:%s:%s\n&quot; \</span><br><span class="line">	&quot;$UNAME&quot; \</span><br><span class="line">	&quot;$AUTHNAME&quot; \</span><br><span class="line">	$(printf &quot;$&#123;UNAME&#125;:$&#123;AUTHNAME&#125;:$&#123;PWORD&#125;&quot; | openssl dgst -md5)</span><br></pre></td></tr></table></figure>
<h3 id="都有哪些可用的哈希算法"><a class="markdownIt-Anchor" href="#都有哪些可用的哈希算法"></a> 都有哪些可用的哈希算法？</h3>
<p>可以使用内置的list-message-digest-commands选项列出可用的哈希算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl list-message-digest-commands</span><br></pre></td></tr></table></figure>
<p>注意列出的结果可能是过时的。(还是通过openssl dgst -h查看吧)</p>
<h2 id="加密解密"><a class="markdownIt-Anchor" href="#加密解密"></a> 加密／解密</h2>
<h3 id="如何使用base64编码"><a class="markdownIt-Anchor" href="#如何使用base64编码"></a> 如何使用base64编码？</h3>
<p>使用enc -base64选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 对文件file.txt里的内容进行base64编码</span><br><span class="line">openssl enc -base64 -in file.txt</span><br><span class="line"></span><br><span class="line"># 将编码结果输出到file.txt.enc</span><br><span class="line">openssl enc -base64 -in file.txt -out file.txt.enc</span><br></pre></td></tr></table></figure>
<p>通过命令行编码指定的字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;encode me&quot; | openssl enc -base64</span><br><span class="line">ZW5jb2RlIG1lCg&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
<p>注意echo会在字符串结尾添加一个换行符，可以使用-n选项去除。当你对一些认证信息编码时，这点很重要。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo -n &quot;encode me&quot; | openssl enc -base64</span><br><span class="line">ZW5jb2RlIG1l</span><br></pre></td></tr></table></figure>
<p>使用-d选项可以解码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;ZW5jb2RlIG1lCg&#x3D;&#x3D;&quot; | openssl enc -base64 -d</span><br><span class="line">encode me</span><br></pre></td></tr></table></figure>
<h3 id="如何简单的加密一个文件"><a class="markdownIt-Anchor" href="#如何简单的加密一个文件"></a> 如何简单的加密一个文件？</h3>
<p>有时候我们只是想简单的通过密码加密一个文件，不想使用专业的工具，也不想创建私钥／证书之类的。<br />
这是很简单，你需要记住密码以及使用的加密算法。<br />
首先选一个加密算法，可以通过下面的方法列出可用的算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ‘Cipher commands’下的列表</span><br><span class="line">openssl -h</span><br><span class="line"></span><br><span class="line"># 算法列表，每行一个</span><br><span class="line">openssl list-cipher-commands</span><br></pre></td></tr></table></figure>
<p>选完加密算法后，还要决定是否对加密后数据进行base64编码，base64编码后数据方便查看，不编码就是二进制的形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用256位AES算法CBC模式，加密file.txt为file.enc。</span><br><span class="line">openssl enc -aes-256-cbc -salt -in file.txt -out file.enc</span><br><span class="line"></span><br><span class="line"># 对加密后数据进行base64编码(-a或-base64)</span><br><span class="line">openssl enc -aes-256-cbc -a -salt -in file.txt -out file.enc</span><br></pre></td></tr></table></figure>
<p>解密file.enc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 解密二进制file.enc</span><br><span class="line">openssl enc -d -aes-256-cbc -in file.enc</span><br><span class="line"></span><br><span class="line"># 解密base64格式的</span><br><span class="line">openssl enc -d -aes-256-cbc -a -in file.enc</span><br></pre></td></tr></table></figure>
<p>如果你不想每次加解密时都输入密码，可以直接在命令中提供：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 在命令行提供密码</span><br><span class="line">openssl enc -aes-256-cbc -salt -in file.txt \</span><br><span class="line">	-out file.enc -pass pass:mySillyPassword</span><br><span class="line"></span><br><span class="line"># 在一个文件中提供密码</span><br><span class="line">openssl enc -aes-256-cbc -salt -in file.txt \</span><br><span class="line">	-out file.enc -pass file:&#x2F;path&#x2F;to&#x2F;secret&#x2F;password.txt</span><br></pre></td></tr></table></figure>
<h2 id="错误"><a class="markdownIt-Anchor" href="#错误"></a> 错误</h2>
<h3 id="如何了解ssl的错误消息"><a class="markdownIt-Anchor" href="#如何了解ssl的错误消息"></a> 如何了解SSL的错误消息？</h3>
<p>查看系统日志，可能会看到一些明显跟OpenSSL或加密有关的错误消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sshd[31784]: error: RSA_public_decrypt failed: error:0407006A:lib(4):func(112):reason(106)</span><br><span class="line">sshd[770]: error: RSA_public_decrypt failed: error:0407006A:lib(4):func(112):reason(106)</span><br></pre></td></tr></table></figure>
<p>了解错误消息的第一步，使用errstr选项解释错误码，错误码在error:和:lib之间，上面的示例是0407006A。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ openssl errstr 0407006A</span><br><span class="line">error:0407006A:rsa routines:RSA_padding_check_PKCS1_type_1:block type is not 01</span><br></pre></td></tr></table></figure>
<p>如果你完整的安装了OpenSSL，可以在开发文档里找到相关信息。</p>
<h2 id="密钥"><a class="markdownIt-Anchor" href="#密钥"></a> 密钥</h2>
<h3 id="如何生成rsa私钥"><a class="markdownIt-Anchor" href="#如何生成rsa私钥"></a> 如何生成RSA私钥？</h3>
<p>使用genrsa选项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 默认1024位密钥，输出到控制台</span><br><span class="line">openssl genrsa</span><br><span class="line"></span><br><span class="line"># 2048位密钥，保存到mykey.pem</span><br><span class="line">openssl genrsa -out mykey.pem 2048</span><br><span class="line"></span><br><span class="line"># 对密钥进行加密</span><br><span class="line">openssl genrsa -des3 -out mykey.pem 2048</span><br></pre></td></tr></table></figure>
<h3 id="如何生成rsa公钥"><a class="markdownIt-Anchor" href="#如何生成rsa公钥"></a> 如何生成RSA公钥？</h3>
<p>使用rsa选项根据私钥生产公钥。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in mykey.pem -pubout</span><br></pre></td></tr></table></figure>
<h3 id="如何生成dsa密钥"><a class="markdownIt-Anchor" href="#如何生成dsa密钥"></a> 如何生成DSA密钥？</h3>
<p>创建DSA密钥需要一个参数文件，并且DSA的验证操作同等情况下比RSA慢。所以没有RSA使用的广泛。<br />
如果只想创建一个DSA密钥，可以通过dsaparam选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 私钥保存在dsakey.pem中</span><br><span class="line">openssl dsaparam -noout -out dsakey.pem -genkey 1024</span><br></pre></td></tr></table></figure>
<p>如果想创建多个密钥，可以先创建一个参数文件，创建参数有点耗时，但创建后再生成密钥就很快了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建参数保存在dsaparam.pem中</span><br><span class="line">openssl dsaparam -out dsaparam.pem 1024</span><br><span class="line"></span><br><span class="line"># 创建第一个key</span><br><span class="line">openssl gendsa -out key1.pem dsaparam.pem</span><br><span class="line"></span><br><span class="line"># 第二个...</span><br><span class="line">openssl gendsa -out key2.pem dsaparam.pem</span><br></pre></td></tr></table></figure>
<h3 id="如何生成椭圆曲线密钥"><a class="markdownIt-Anchor" href="#如何生成椭圆曲线密钥"></a> 如何生成椭圆曲线密钥？</h3>
<p>椭圆曲线加密在OpenSSL 0.9.8版本加入。通过ecparam选项生成密钥。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl ecparam -out key.pem -name prime256v1 -genkey</span><br><span class="line"></span><br><span class="line"># -name后支持的选项列表</span><br><span class="line">openssl ecparam -list_curves</span><br></pre></td></tr></table></figure>
<h3 id="如何解密密钥"><a class="markdownIt-Anchor" href="#如何解密密钥"></a> 如何解密密钥？</h3>
<p>也许对每次都输入密码厌烦了，你可以对密钥解密，使用rsa或dsa选项，取决于使用了哪种加密算法。<br />
如果你有一个加密的RSA密钥文件key.pem，下面的例子是将解密后的密钥存在文件newkey.pem中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 需要输入密钥的密码</span><br><span class="line">openssl rsa -in key.pem -out newkey.pem</span><br></pre></td></tr></table></figure>
<p>通常情况是在一个文件里存储私钥和公共证书，假如这个文件是mycert.pem，通过以下两步生成不加密的版本newcert.pem</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 需要输入密钥的密码</span><br><span class="line">openssl rsa -in mycert.pem -out newcert.pem</span><br><span class="line">openssl x509 -in mycert.pem &gt;&gt;newcert.pem</span><br></pre></td></tr></table></figure>
<h2 id="密码哈希"><a class="markdownIt-Anchor" href="#密码哈希"></a> 密码哈希</h2>
<p>使用passwd选项，可以生成不同格式的密码哈希值。</p>
<h3 id="如何生成加密风格crypt-style的密码哈希值"><a class="markdownIt-Anchor" href="#如何生成加密风格crypt-style的密码哈希值"></a> 如何生成加密风格(crypt-style)的密码哈希值？</h3>
<p>生成一个新的哈希值非常简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ openssl passwd MySecret</span><br><span class="line">8E4vqBR4UOYF.</span><br></pre></td></tr></table></figure>
<p>如果知道密码以及运算时用的盐(salt)，就能重现这个哈希值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ openssl passwd -salt 8E MySecret</span><br><span class="line">8E4vqBR4UOYF.</span><br></pre></td></tr></table></figure>
<h3 id="如何生成阴影风格shadow-style的密码哈希值"><a class="markdownIt-Anchor" href="#如何生成阴影风格shadow-style的密码哈希值"></a> 如何生成阴影风格(shadow-style)的密码哈希值？</h3>
<p>最近的Unix系统开始使用更加安全的哈希策略，基于MD5运算，并且使用8个字符作为盐(传统的加密风格使用2个字符作为盐)。<br />
加上-1选项，就能生成这样的哈希值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ openssl passwd -1 MySecret</span><br><span class="line">$1$sXiKzkus$haDZ9JpVrRHBznY5OxB82.</span><br></pre></td></tr></table></figure>
<p>这个风格的哈希值，盐位于第二个和第三个$符之间，上面例子的盐值是sXiKzkus。知道密码和盐值后可以重现这个哈希值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ openssl passwd -1 -salt sXiKzkus MySecret</span><br><span class="line">$1$sXiKzkus$haDZ9JpVrRHBznY5OxB82.</span><br></pre></td></tr></table></figure>
<h2 id="素数"><a class="markdownIt-Anchor" href="#素数"></a> 素数</h2>
<p>当前的加密技术很大程度上是依赖素数的生成和检验。难怪OpenSSL库提供大量的操作来处理素数。应该是从0.9.7e版本开始，加入了prime选项。</p>
<h3 id="如何测试一个数是否为素数"><a class="markdownIt-Anchor" href="#如何测试一个数是否为素数"></a> 如何测试一个数是否为素数？</h3>
<p>使用prime选项，后面跟要测试的数字。注意OpenSSL的返回数字是十六进制的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ openssl prime 119054759245460753</span><br><span class="line">1A6F7AC39A53511 is not prime</span><br></pre></td></tr></table></figure>
<p>也可以直接传入十六进制的数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ openssl prime -hex 2f</span><br><span class="line">2F is prime</span><br></pre></td></tr></table></figure>
<h3 id="如何生成一组素数"><a class="markdownIt-Anchor" href="#如何生成一组素数"></a> 如何生成一组素数？</h3>
<p>从OpenSSL 1.0版本开始，可以生成指定长度的素数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ openssl prime -generate -bits 64</span><br><span class="line">16148891040401035823</span><br><span class="line">$ openssl prime -generate -bits 64 -hex</span><br><span class="line">E207F23B9AE52181</span><br></pre></td></tr></table></figure>
<p>1.0之前的版本，就得传入一个范围的数判断哪个符合要求了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># define start and ending points</span><br><span class="line">AQUO&#x3D;10000</span><br><span class="line">ADQUEM&#x3D;10100</span><br><span class="line">for N in $(seq $AQUO $ADQUEM); do</span><br><span class="line">	# use bc to convert hex to decimal</span><br><span class="line">	openssl prime $N | awk &#39;&#x2F;is prime&#x2F; &#123;print &quot;ibase&#x3D;16;&quot;$1&#125;&#39; | bc</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="随机数"><a class="markdownIt-Anchor" href="#随机数"></a> 随机数</h2>
<h3 id="如何生成随机数"><a class="markdownIt-Anchor" href="#如何生成随机数"></a> 如何生成随机数？</h3>
<p>使用rand选项可以生成二进制或base64格式的随机数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 直接在控制台输出128位base64格式的随机数</span><br><span class="line">openssl rand -base64 128</span><br><span class="line"></span><br><span class="line"># 在指定的文件中输出1024位二进制随机数</span><br><span class="line">openssl rand -out random-data.bin 1024</span><br><span class="line"></span><br><span class="line"># 从浏览器缓存取到半随机子节数据作为种子来生成随机数</span><br><span class="line">cd $(find ~&#x2F;.mozilla&#x2F;firefox -type d -name Cache)</span><br><span class="line">openssl rand -rand $(find . -type f -printf &#39;%f:&#39;) -base64 1024</span><br></pre></td></tr></table></figure>
<p>在类Unix系统中有个/dev/urandom的设备以及GNU的head工具，或者最近版本BSD的head，使用它们可以更有效的生成随机数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 取得32位随机数，以base64编码显示</span><br><span class="line">head -c 32 &#x2F;dev&#x2F;urandom | openssl enc -base64</span><br></pre></td></tr></table></figure>
<p>可以利用strings工具得到比Base64使用更多字符的随机结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 取得32位随机数，取得可打印的字符，去除空格，替换掉换行符</span><br><span class="line">echo $(head -c 32 &#x2F;dev&#x2F;random | strings -1) | sed &#39;s&#x2F;[[:space:]]&#x2F;&#x2F;g&#39;</span><br></pre></td></tr></table></figure>
<p>在某些极端情况下，请确保了解使用random和urandom的优劣之处。可以在Linux和BSD系统的random(4)的man页面，Solaris的random(7D)的man页面查到更多的信息。</p>
<h2 id="smime"><a class="markdownIt-Anchor" href="#smime"></a> S/MIME</h2>
<p>S/MIME表示安全的发送和接收MIME数据，尤其是自e-mail消息中。已经有相当部分e-mail客户端默认支持S/MIME了，OpenSSL通过smime选项提供命令行S/MIME服务。<br />
注意<span class="exturl" data-url="aHR0cHM6Ly93d3cub3BlbnNzbC5vcmcvZG9jcy9tYW5tYXN0ZXIvYXBwcy9zbWltZS5odG1s">smime的man页面<i class="fa fa-external-link-alt"></i></span>包含了一些特别好的示例。</p>
<h3 id="如何验证签名过的smime消息"><a class="markdownIt-Anchor" href="#如何验证签名过的smime消息"></a> 如何验证签名过的S/MIME消息？</h3>
<p>使用mail客户端将签名过的S/MIME消息保存为msg.txt。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl smime -verify -in msg.txt</span><br></pre></td></tr></table></figure>
<p>如果发送者的证书是被你的OpenSSL所认可的授权机构签名的，你就能看到mail的头信息，正文以及一行提示Verification successful。<br />
如果消息被篡改过，会输出错误消息指明哈希值或者签名不匹配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Verification failure</span><br><span class="line">23016:error:21071065:PKCS7 routines:PKCS7_signatureVerify:digest</span><br><span class="line">failure:pk7_doit.c:804:</span><br><span class="line">23016:error:21075069:PKCS7 routines:PKCS7_verify:signature</span><br><span class="line">failure:pk7_smime.c:265:</span><br></pre></td></tr></table></figure>
<p>同样，如果发送者的证书验证失败，会输出类似的错误消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Verification failure</span><br><span class="line">9544:error:21075075:PKCS7 routines:PKCS7_verify:certificate verify</span><br><span class="line">error:pk7_smime.c:222:Verify error:self signed certificate</span><br></pre></td></tr></table></figure>
<p>多数e-mail客户端会再消息的签名中发送公共证书。在命令行中你可以查看这证书的数据。可以使用smime -pk7out选线导出PKCS#7证书，然后再使用pkcs7选项。这方法虽然笨但确实可用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl smime -pk7out -in msg.txt | \</span><br><span class="line">openssl pkcs7 -text -noout -print_certs</span><br></pre></td></tr></table></figure>
<p>也可以将对方的证书保存为指定的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl smime -pk7out -in msg.txt -out her-cert.pem</span><br></pre></td></tr></table></figure>
<p>这时可以把这个证书加入你的OpenSSL信任组中或存在别处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl smime -verify -in msg.txt -CAfile &#x2F;path&#x2F;to&#x2F;her-cert.pem</span><br></pre></td></tr></table></figure>
<h3 id="如何加密smime消息"><a class="markdownIt-Anchor" href="#如何加密smime消息"></a> 如何加密S/MIME消息？</h3>
<p>加入有人发给你她的公共证书，并要求你发送加密过消息给她。她的证书存为her-cert.pem，你要发的消息存为message.txt。<br />
默认使用比较弱的RC2-40加密方案，只要告诉OpenSSL消息和证书的地址就行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl smime her-cert.pem -encrypt -in my-message.txt</span><br></pre></td></tr></table></figure>
<p>如果你确定对方有处理SSL的能力，可以指定更安全的算法，比如DES3。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl smime her-cert.pem -encrypt -des3 -in my-message.txt</span><br></pre></td></tr></table></figure>
<p>默认情况下，加密过消息以及mail头信息输出到了控制台。可以使用-out选项输出到文件中。甚至可以利用sendmail直接发送出去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">openssl smime her-cert.pem \</span><br><span class="line">	-encrypt \</span><br><span class="line">	-des3 \</span><br><span class="line">	-in my-message.txt \</span><br><span class="line">	-from &#39;Your Fullname &lt;you@youraddress.com&gt;&#39; \</span><br><span class="line">	-to &#39;Her Fullname &lt;her@heraddress.com&gt;&#39; \</span><br><span class="line">	-subject &#39;My encrypted reply&#39; |\</span><br><span class="line">sendmail her@heraddress.com</span><br></pre></td></tr></table></figure>
<h3 id="如何对smime消息签名"><a class="markdownIt-Anchor" href="#如何对smime消息签名"></a> 如何对S/MIME消息签名？</h3>
<p>如果你不需要加密整个消息，只是想对消息做个签名，这样对方可以确定消息的完整性。处理方法跟加密类似，主要的不同是你需要自己的私钥和证书，因为你不可能拿对方的证书去签名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">openssl smime \</span><br><span class="line">	-sign \</span><br><span class="line">	-signer &#x2F;path&#x2F;to&#x2F;your-cert.pem \</span><br><span class="line">	-in my-message.txt \</span><br><span class="line">	-from &#39;Your Fullname &lt;you@youraddress.com&gt;&#39; \</span><br><span class="line">	-to &#39;Her Fullname &lt;her@heraddress.com&gt;&#39; \</span><br><span class="line">	-subject &#39;My signed reply&#39; |\</span><br><span class="line">sendmail her@heraddress.com</span><br></pre></td></tr></table></figure>
<h1 id="bio模块"><a class="markdownIt-Anchor" href="#bio模块"></a> BIO模块</h1>
<p>OpenSSL抽象I/O(Basic I/O abstraction，即BIO)是OpenSSL对于I/O类型的抽象封装，包括内存、文件、日志、标准输入输出、socket、加解密、摘要和ssl通道等。OpenSSL BIO通过回调函数为用户隐藏了底层的实现细节，所有类型的BIO调用大体类似。BIO中的数据能从一个BIO传递给另一个BIO或是应用程序。</p>
<h2 id="bio结构体"><a class="markdownIt-Anchor" href="#bio结构体"></a> BIO结构体</h2>
<p>BIO的结构体的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bio_st</span> <span class="title">BIO</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	BIO_METHOD *method; <span class="comment">//BIO方法结构，是决定BIO类型和行为的重要参数，各种BIO的不同之处主要也正在于此项。</span></span><br><span class="line">	<span class="comment">/* bio, mode, argp, argi, argl, ret */</span></span><br><span class="line">	<span class="keyword">long</span> (*callback)(struct bio_st *,<span class="keyword">int</span>,<span class="keyword">const</span> <span class="keyword">char</span> *,<span class="keyword">int</span>, <span class="keyword">long</span>, <span class="keyword">long</span>);</span><br><span class="line">	<span class="keyword">char</span> *cb_arg; <span class="comment">/* first argument for the callback */</span></span><br><span class="line">	<span class="keyword">int</span> init; <span class="comment">//具体句柄初始化标记，初始化之后为1</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">shutdown</span>; <span class="comment">//BIO关闭标记，当该值不为0时释放资源，数值修改可以通过控制函数来设置</span></span><br><span class="line">	<span class="keyword">int</span> flags; <span class="comment">//用于控制各个函数的行为</span></span><br><span class="line">	<span class="keyword">int</span> retry_reason; <span class="comment">//重试原因，主要用在socket和ssl BIO的异步阻塞</span></span><br><span class="line">	<span class="keyword">int</span> num; <span class="comment">//因具体BIO而异</span></span><br><span class="line">	<span class="keyword">void</span> *ptr; <span class="comment">//具体bio有不同含义。比如文件BIO中它用来存放文件句柄；mem bio中它用来存放内存地址；connect bio中它用来存放BIO_CONNECT数据，accept bio中它用来存放BIO_ACCEPT数据。</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bio_st</span> *<span class="title">next_bio</span>;</span>	<span class="comment">/*下一个BIO地址，used by filter BIOs*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bio_st</span> *<span class="title">prev_bio</span>;</span>	<span class="comment">/*上一个BIO地址，used by filter BIOs*/</span></span><br><span class="line">	<span class="keyword">int</span> references; <span class="comment">//被引用数量</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> num_read; <span class="comment">//已读入字节数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> num_write; <span class="comment">//已写入字节数</span></span><br><span class="line">	CRYPTO_EX_DATA ex_data; <span class="comment">//存放额外数据</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<p>在BIO的成员中，method是最关键的一个，它决定了BIO的类型。在定义一个新的BIO结构时，使用下面的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BIO* <span class="title">BIO_new</span><span class="params">(BIO_METHOD *type)</span></span>;</span><br></pre></td></tr></table></figure>
<p>BIO_new函数除了给一些初始变量赋值之外，主要就是把type中的各个变量赋值给BIO结构中的method成员。一般type参数是通过一个返回值为BIO_METHOD类型的函数来提供的，这样的函数有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【source/sink型】</span></span><br><span class="line"><span class="function">BIO_METHOD* <span class="title">BIO_s_accept</span><span class="params">()</span>   <span class="comment">//一个封装了类似TCP/IP socket Accept规则的接口，并且使TCP/IP操作对于BIO接口透明。</span></span></span><br><span class="line"><span class="function">BIO_METHOD* <span class="title">BIO_s_connect</span><span class="params">()</span>  <span class="comment">//一个封装了类似TCP/IP socket Connect规则的接口，并且使TCP/IP操作对于BIO接口透明</span></span></span><br><span class="line"><span class="function">BIO_METHOD* <span class="title">BIO_s_socket</span><span class="params">()</span>   <span class="comment">//封装了socket接口的BIO类型</span></span></span><br><span class="line"><span class="function">BIO_METHOD* <span class="title">BIO_s_bio</span><span class="params">()</span>      <span class="comment">//封装了一个BIO对，数据从其中一个BIO写入，从另外一个BIO读出</span></span></span><br><span class="line"><span class="function">BIO_METHOD* <span class="title">BIO_s_fd</span><span class="params">()</span>       <span class="comment">//是一个封装了文件描述符的BIO接口，提供类似文件读写操作的功能</span></span></span><br><span class="line"><span class="function">BIO_METHOD* <span class="title">BIO_s_file</span><span class="params">()</span>     <span class="comment">//封装了标准的文件接口的BIO，包括标准的输入输出设备如stdin等</span></span></span><br><span class="line"><span class="function">BIO_METHOD* <span class="title">BIO_s_mem</span><span class="params">()</span>      <span class="comment">//封装了内存操作的BIO接口，包括了对内存的读写操作</span></span></span><br><span class="line"><span class="function">BIO_METHOD* <span class="title">BIO_s_null</span><span class="params">()</span>     <span class="comment">//返回空的sink型BIO接口，写入这种接口的所有数据读被丢弃，读的时候总是返回EOF</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//【filter型】</span></span></span><br><span class="line"><span class="function">BIO_METHOD* <span class="title">BIO_f_base64</span><span class="params">()</span>   <span class="comment">//封装了base64编码方法的BIO,写的时候进行编码，读的时候解码 </span></span></span><br><span class="line"><span class="function">BIO_METHOD* <span class="title">BIO_f_cipher</span><span class="params">()</span>   <span class="comment">//封装了加解密方法的BIO，写的时候加密，读的时候解密</span></span></span><br><span class="line"><span class="function">BIO_METHOD* <span class="title">BIO_f_md</span><span class="params">()</span>       <span class="comment">//封装了信息摘要方法的BIO，通过该接口读写的数据都是已经经过摘要的。</span></span></span><br><span class="line"><span class="function">BIO_METHOD* <span class="title">BIO_f_ssl</span><span class="params">()</span>      <span class="comment">//封装了openssl 的SSL协议的BIO类型，也就是为SSL协议增加了一些BIO操作方法。</span></span></span><br><span class="line"><span class="function">BIO_METHOD* <span class="title">BIO_f_null</span><span class="params">()</span>     <span class="comment">//一个不作任何事情的BIO，对它的操作都简单传到下一个BIO去了，相当于不存在。</span></span></span><br><span class="line"><span class="function">BIO_METHOD* <span class="title">BIO_f_buffer</span><span class="params">()</span>   <span class="comment">//封装了缓冲区操作的BIO，写入该接口的数据一般是准备传入下一个BIO接口的，从该接口读出的数据一般也是从另一个BIO传过来的。</span></span></span><br></pre></td></tr></table></figure>
<h2 id="bio_method"><a class="markdownIt-Anchor" href="#bio_method"></a> BIO_METHOD</h2>
<p>一个BIO_METHOD类型的结构体包含如下这些成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bio_method_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> type; <span class="comment">//BIO类型，type取值对应的BIO_METHOD类型见附录</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">//BIO的名字</span></span><br><span class="line">	<span class="keyword">int</span> (*bwrite)(BIO *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>); <span class="comment">//写操作回调函数</span></span><br><span class="line">	<span class="keyword">int</span> (*bread)(BIO *, <span class="keyword">char</span> *, <span class="keyword">int</span>); <span class="comment">//读操作回调函数</span></span><br><span class="line">	<span class="keyword">int</span> (*bputs)(BIO *, <span class="keyword">const</span> <span class="keyword">char</span> *); <span class="comment">//写入字符串回调函数</span></span><br><span class="line">	<span class="keyword">int</span> (*bgets)(BIO *, <span class="keyword">char</span> *, <span class="keyword">int</span>); <span class="comment">//读取字符串函数</span></span><br><span class="line">	<span class="keyword">long</span> (*ctrl)(BIO *, <span class="keyword">int</span>, <span class="keyword">long</span>, <span class="keyword">void</span> *); <span class="comment">//控制回调函数</span></span><br><span class="line">	<span class="keyword">int</span> (*)(BIO *); <span class="comment">//生成回调函数</span></span><br><span class="line">	<span class="keyword">int</span> (*destroy)(BIO *); <span class="comment">//销毁回调函数</span></span><br><span class="line">    <span class="keyword">long</span> (*callback_ctrl)(BIO *, <span class="keyword">int</span>, bio_info_cb *); <span class="comment">//控制回调函数，可以由调用者实现</span></span><br><span class="line">&#125; BIO_METHOD;</span><br></pre></td></tr></table></figure>
<h2 id="bio的相关函数"><a class="markdownIt-Anchor" href="#bio的相关函数"></a> BIO的相关函数</h2>
<h3 id="bio的声明与释放"><a class="markdownIt-Anchor" href="#bio的声明与释放"></a> BIO的声明与释放</h3>
<p>下面是用于BIO分配和释放操作的一些基本操作系列函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BIO*  <span class="title">BIO_new</span><span class="params">(BIO_METHOD *type)</span></span>; <span class="comment">//调用BIO_set()函数创建一个新的BIO</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">BIO_set</span><span class="params">(BIO *a,BIO_METHOD *type)</span></span>; <span class="comment">//对一个已经创建好的BIO设置新的BIO类型，其实就是简单的对BIO的各个成员进行初始化，并将参数type赋值给该BIO</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">BIO_free</span><span class="params">(BIO *a)</span></span>; <span class="comment">//释放单个BIO占用的资源，成功返回1，失败返回0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">BIO_vfree</span><span class="params">(BIO *a)</span></span>; <span class="comment">//功能与BIO_free完全相同，但是无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">BIO_free_all</span><span class="params">(BIO *a)</span></span>; <span class="comment">//释放一个BIO链，如果中间某个过程出错也不会停止释放过程</span></span><br></pre></td></tr></table></figure>
<p>一些类型的BIO使用BIO_new()函数创建之后便可以直接使用，如memory类型的BIO；有些BIO在创建之后还需要做一些初始化工作，如文件BIO，一般也会提供一些这样的函数来创建和初始化它们。</p>
<h3 id="bio的控制函数"><a class="markdownIt-Anchor" href="#bio的控制函数"></a> BIO的控制函数</h3>
<p>BIO的控制函数较多，见附录。这些函数用于控制BIO的状态等。</p>
<h3 id="bio的io操作"><a class="markdownIt-Anchor" href="#bio的io操作"></a> BIO的I/O操作</h3>
<p>BIO的基本读写函数有四个：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openss/bio.h&gt;</span></span></span><br><span class="line"><span class="comment">//以下四个函数，成功返回真正读出/写入的数据长度，失败返回0或-1，BIO未实现这一函数返回-2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BIO_read</span><span class="params">(BIO *b, <span class="keyword">void</span> *buf, <span class="keyword">int</span> len)</span></span>; <span class="comment">//从BIO接口中读取len字节数据到buf，</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BIO_write</span><span class="params">(BIO *b, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">int</span> len)</span></span>; <span class="comment">//往BIO写入长度为len的数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BIO_gets</span><span class="params">(BIO *b,<span class="keyword">char</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>; <span class="comment">//从BIO中读取一行长度最大为size的数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BIO_puts</span><span class="params">(BIO *b,<span class="keyword">const</span> <span class="keyword">char</span> *buf)</span></span>; <span class="comment">//往BIO中写入一个以NULL为结束符的字符串</span></span><br></pre></td></tr></table></figure>
<p>BIO也提供了一组出错原因的诊断函数，用于诊断为什么BIO在读写数据的时候不能读写数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_should_read(a)       ((a)-&gt;flags &amp; BIO_FLAGS_READ) <span class="comment">//如果导致IO失败的原因是BIO此时要读取数据，则返回true</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_should_write(a)      ((a)-&gt;flags &amp; BIO_FLAGS_WRITE) <span class="comment">//如果导致IO失败的原因是BIO此时要写数据，则返回true</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_should_io_special(a) ((a)-&gt;flags &amp; BIO_FLAGS_IO_SPECIAL) <span class="comment">//如果导致IO失败的原因是读写之外的原因则返回true</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_retry_type(a)        ((a)-&gt;flags &amp; BIO_FLAGS_RWS) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_should_retry(a)      ((a)-&gt;flags &amp; BIO_FLAGS_SHOULD_RETRY) <span class="comment">//如果读写出错的情况是要求程序稍后重试，那么该函数返回true</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_FLAGS_READ 0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_FLAGS_WRITE 0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_FLAGS_IO_SPECIAL 0x04</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_FLAGS_RWS (BIO_FLAGS_READ|BIO_FLAGS_WRITE|BIO_FLAGS_IO_SPECIAL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_FLAGS_SHOULD_RETRY 0x08</span></span><br><span class="line"></span><br><span class="line"><span class="function">BIO*    <span class="title">BIO_get_retry_BIO</span><span class="params">(BIO *bio, <span class="keyword">int</span> *reason)</span></span>; <span class="comment">//给出特殊情况错误的简短原因</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>     <span class="title">BIO_get_retry_reason</span><span class="params">(BIO *bio)</span></span>; <span class="comment">//返回失败的原因</span></span><br></pre></td></tr></table></figure>
<h3 id="bio对"><a class="markdownIt-Anchor" href="#bio对"></a> BIO对</h3>
<p>BIO对是BIO中专门创建的一对缓存BIO，创建BIO对的函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BIO_new_bio_pair</span><span class="params">(BIO **bio1, <span class="keyword">size_t</span> writebuf1, BIO **bio2, <span class="keyword">size_t</span> writebuf2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数调用成功之后返回1，此时bio1和bio2都变得有效；否则返回0，bio1和bio2被设为NULL。但是注意它们在不使用的时候必须分别释放，因为有些SSL函数会隐含调用BIO_free函数。</p>
<p>当BIO对创建之后，它的两端都能作为数据缓冲的输入和输出，典型的应用为它一端和SSL的IO连接，另一端被应用控制。</p>
<p>这两个BIO对的功能是完全对称的，它们的缓冲区大小由参数writebuf1和writebuf2决定，如果设为0则使用默认大小。注意这个函数不会检查bio1和bio2是否指向其他BIO，二者的值都会被重写，且不会调用BIO_free()函数。因此在使用之前必须自己保证这两个变量为空，否则会造成内存泄漏。</p>
<p>因为BIO对只会简单的缓存数据，而不会直接涉及到连接，所以它看起来<strong>就像非阻塞型的接口</strong>，如果<strong>写缓存满了或读缓存空的时候，调用IO函数就会立刻返回</strong>。也就是说，应用程序必须自己对写缓存执行flush操作或对读缓存执行fill操作。</p>
<h3 id="bio链操作"><a class="markdownIt-Anchor" href="#bio链操作"></a> BIO链操作</h3>
<p>BIO结构其实是一个链式结构，在BIO链上添加或删除BIO的函数有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BIO * <span class="title">BIO_push</span><span class="params">(BIO *b,BIO *append)</span></span>; <span class="comment">//把名为append的链附加到名为b的链上，返回b</span></span><br><span class="line"><span class="function">BIO * <span class="title">BIO_pop</span><span class="params">(BIO *b)</span></span>; <span class="comment">//把名为b的BIO从它所在的BIO链中移除，并返回下一个BIO。如果没有则返回NULL</span></span><br></pre></td></tr></table></figure>
<p>如同链表一样，一个BIO链的第一个元素便代表了整个链。在构造完BIO链之后，从链中的第一个元素开始做写操作时，数据会经过BIO链上每一个元素的处理，然后将BIO链最后一个元素的输出写入到文件中。而对于读操作来说，则是从BIO链的最后一个元素开始，沿着相反的方向进行操作，最后读取BIO链的第一个元素的输出。</p>
<p><img data-src="https://img-blog.csdn.net/20170815180254544?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlhbzIwMDgxMjI4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" /></p>
<p>BIO链也提供了遍历与查找的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BIO* <span class="title">BIO_find_type</span><span class="params">(BIO *b,<span class="keyword">int</span> bio_type)</span></span>; <span class="comment">//在BIO链中根据特定类型的bio_type进行搜索，起始位置为b，返回最先找到的那个BIO，如果未找到则返回null</span></span><br><span class="line"><span class="function">BIO* <span class="title">BIO_next</span><span class="params">(BIO *b)</span></span>; <span class="comment">//返回b所在BIO链中的下一个BIO</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_method_type(b) ((b)-&gt;method-&gt;type)</span></span><br></pre></td></tr></table></figure>
<p>其中，bio_type的值定义见附录。</p>
<h2 id="bio分类"><a class="markdownIt-Anchor" href="#bio分类"></a> BIO分类</h2>
<h3 id="sourcesink类型bio"><a class="markdownIt-Anchor" href="#sourcesink类型bio"></a> Source/Sink类型BIO</h3>
<h4 id="文件指针类型bio"><a class="markdownIt-Anchor" href="#文件指针类型bio"></a> 文件指针类型BIO</h4>
<p>文件类型BIO的相关函数和定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/bio.h&gt;    </span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BIO_METHOD*  <span class="title">BIO_s_file</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//返回文件BIO的BIO_METHOD定义</span></span><br><span class="line"></span><br><span class="line"><span class="function">BIO* <span class="title">BIO_new_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>; <span class="comment">//从文件名新建BIO</span></span><br><span class="line"><span class="function">BIO* <span class="title">BIO_new_fp</span><span class="params">(FILE *stream, <span class="keyword">int</span> flags)</span></span>; <span class="comment">//从文件指针新建BIO</span></span><br><span class="line"></span><br><span class="line">BIO_set_fp(BIO *b,FILE *fp, <span class="keyword">int</span> flags);  <span class="comment">//将bio与文件指针绑定</span></span><br><span class="line">BIO_get_fp(BIO *b,FILE **fpp);           <span class="comment">//获取bio绑定的的文件指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BIO_read_filename</span><span class="params">(BIO *b, <span class="keyword">char</span> *name)</span> <span class="comment">//设置BIO的读文件名</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BIO_write_filename</span><span class="params">(BIO *b, <span class="keyword">char</span> *name)</span> <span class="comment">//设置BIO的写文件名</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BIO_append_filename</span><span class="params">(BIO *b, <span class="keyword">char</span> *name)</span> <span class="comment">//设置BIO的附加文件名</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BIO_rw_filename</span><span class="params">(BIO *b, <span class="keyword">char</span> *name)</span> <span class="comment">//设置BIO的读写文件名</span></span></span><br></pre></td></tr></table></figure>
<p>file类型的BIO_METHOD结构体变量如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BIO_METHOD methods_filep =</span><br><span class="line">&#123;</span><br><span class="line">     BIO_TYPE_FILE,</span><br><span class="line">     <span class="string">&quot;FILE pointer&quot;</span>,</span><br><span class="line">     file_write,</span><br><span class="line">     file_read,</span><br><span class="line">     file_puts,</span><br><span class="line">     file_gets,</span><br><span class="line">     file_ctrl,</span><br><span class="line">     file_new,</span><br><span class="line">     file_free,</span><br><span class="line">     <span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在file类型中，使用前面介绍过的<strong>BIO_read和BIO_write</strong>对底层的file数据流进行读写操作，file类型BIO是支持<strong>BIO_gets和BIO_puts</strong>函数的。</p>
<p><strong>BIO_flush</strong>函数在file类型BIO中只是简单调用了API函数fflush。</p>
<p><strong>BIO_reset</strong>函数则将文件指针重新指向文件的开始位置，它调用fseek(stream,0,0) 函数实现该功能。</p>
<p><strong>BIO_seek</strong>函数将文件指针位置至于所定义的位置ofs上（从文件开头开始计算的偏移ofs），它调用了文件的操作函数fseek(stream,ofs,0)，是一个宏定义形式的函数，需要注意的是，因为该函数调用了fseek函数，所以成功的时候返回0，失败的时候返回－1，这是跟标准BIO_seek函数定义不一样的，因为标准的定义是成功返回1，失败返回非正值。</p>
<p><strong>BIO_eof</strong>调用了feof函数。 如果在BIO结构中<strong>设置了BIO_CLOSE</strong>的标志，则在BIO释放的时候会<strong>自动调用fclose函数</strong>。</p>
<p><strong>BIO_tell</strong>返回位置指针的值。是一个宏定义函数。</p>
<p>BIO文件类型操作的程序示例（省略了头文件等）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.最简单的实例程序</span></span><br><span class="line">BIO *bio_out;</span><br><span class="line">bio_out = BIO_new_fp(<span class="built_in">stdout</span>, BIO_NOCLOSE); </span><br><span class="line">BIO_printf(bio_out, <span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line"><span class="comment">//  2.上述例子的另一种实现方法</span></span><br><span class="line">BIO *bio_out;</span><br><span class="line">bio_out = BIO_new(BIO_s_file());</span><br><span class="line"><span class="keyword">if</span>(bio_out == <span class="literal">NULL</span>) </span><br><span class="line">    <span class="comment">/*error handling*/</span></span><br><span class="line"><span class="keyword">if</span>(!BIO_set_fp(bio_out, <span class="built_in">stdout</span>, BIO_NOCLOSE)) </span><br><span class="line">    <span class="comment">/* 出错则将文件流定向到标准输出*/</span></span><br><span class="line">BIO_printf(bio_out, <span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line"><span class="comment">//  3.写文件操作</span></span><br><span class="line">BIO *out;</span><br><span class="line">out = BIO_new_file(<span class="string">&quot;filename.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!out) <span class="comment">/*出错*/</span></span><br><span class="line">BIO_printf(out, <span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">BIO_free(out);</span><br><span class="line"><span class="comment">//   4.上述例子的另一种实现方法</span></span><br><span class="line">BIO *out;</span><br><span class="line">out = BIO_new(BIO_s_file());</span><br><span class="line"><span class="keyword">if</span>(out == <span class="literal">NULL</span>) </span><br><span class="line">    <span class="comment">/* Error handling */</span></span><br><span class="line"><span class="keyword">if</span>(!BIO_write_filename(out, (<span class="keyword">void</span>*)<span class="string">&quot;filename.txt&quot;</span>)) </span><br><span class="line">    <span class="comment">/* Error handling */</span></span><br><span class="line">BIO_printf(out, <span class="string">&quot;Hello World\n&quot;</span>); <span class="comment">//此处换成BIO_read或BIO_gets可以实现读文件操作</span></span><br><span class="line">BIO_free(out);</span><br></pre></td></tr></table></figure>
<h4 id="文件描述符类型bio"><a class="markdownIt-Anchor" href="#文件描述符类型bio"></a> 文件描述符类型BIO</h4>
<p>文件描述符类型BIO是一个Source/Sink类型的BIO，定义了以下一些类型的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/bio.h&gt;     </span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BIO_METHOD * <span class="title">BIO_s_fd</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//返回一个文件描述符类型的BIO_METHOD结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_set_fd(b,fd,c) BIO_int_ctrl(b,BIO_C_SET_FD,c,fd) <span class="comment">//将BIO的底层文件描述符设置为fd</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_get_fd(b,c)    BIO_ctrl(b,BIO_C_GET_FD,0,(char *)c) <span class="comment">//返回相应的BIO底层文件描述符，存储在参数c中</span></span></span><br><span class="line"><span class="function">BIO*    <span class="title">BIO_new_fd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> close_flag)</span></span>; <span class="comment">//创建并返回一个底层描述符为fd，关闭标志位close_flag的文件描述符类型的BIO</span></span><br></pre></td></tr></table></figure>
<p>fd类型的BIO_METHOD结构体变量定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BIO_METHOD methods_fdp=</span><br><span class="line">&#123;</span><br><span class="line">         BIO_TYPE_FD,</span><br><span class="line">         <span class="string">&quot;file descriptor&quot;</span>,</span><br><span class="line">         fd_write,</span><br><span class="line">         fd_read,</span><br><span class="line">         fd_puts,</span><br><span class="line">         <span class="literal">NULL</span>, <span class="comment">/* fd_gets, 与file类型的BIO相比它没有实现gets方法*/</span> </span><br><span class="line">         fd_ctrl,</span><br><span class="line">         fd_new,</span><br><span class="line">         fd_free,</span><br><span class="line">         <span class="literal">NULL</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>BIO_read</strong>和<strong>BIO_write</strong>对底层的文件描述符结构进行读写操作。这两个函数的一些行为取决于他们所在的平台的文件描述符的读写函数的行为，如果底层的文件描述符是非阻塞型的，那么他们基本上是跟前面介绍过的BIO的IO操作函数一样的。</p>
<p><strong>BIO_puts</strong>是支持的，但是<strong>BIO_gets</strong>在本类型描述符中是不支持的。</p>
<p><strong>BIO_reset</strong>调用lseek(fd,0,0)函数，使文件指针指向开始的位置。调用成功返回0，失败返回－1。</p>
<p><strong>BIO_seek</strong>调用了lseek(fd,ofs,0)函数，设置文件指针的位置到从文件头偏移ofs的位置，成功返回文件指针的位置，失败返回－1。</p>
<p><strong>BIO_tell</strong>返回目前文件指针的位置，它其实调用了lseek(fd,0,1)函数，失败返回－1。 如果设置了关闭标志，那么当BIO被释放的时候底层的文件描述符就会被关闭。</p>
<p>程序示例（省略了头文件和主函数部分）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BIO *out;</span><br><span class="line">out = BIO_new_fd(fileno(<span class="built_in">stdout</span>), BIO_NOCLOSE);</span><br><span class="line">BIO_write(out, <span class="string">&quot;Hello World\n&quot;</span>, <span class="number">13</span>); </span><br><span class="line">BIO_free(out); </span><br></pre></td></tr></table></figure>
<p>附：Linux系统的文件描述符介绍https://blog.csdn.net/cywosp/article/details/38965239</p>
<h4 id="socket类型bio"><a class="markdownIt-Anchor" href="#socket类型bio"></a> Socket类型BIO</h4>
<p>Socket类型的BIO是一种source/sink型BIO，封装了Socket的IO操作，它相关的一 些函数定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BIO_METHOD*  <span class="title">BIO_s_socket</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>      BIO_set_fd(b,fd,c)  BIO_int_ctrl(b,BIO_C_SET_FD,c,fd) <span class="comment">//将Socket描述符fd设置为BIO的底层IO结构，同时可以设置关闭标志c</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>      BIO_get_fd(b,c)     BIO_ctrl(b,BIO_C_GET_FD,0,(char *)c) <span class="comment">//返回指定BIO的Socket描述符</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BIO*         <span class="title">BIO_new_socket</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> close_flag)</span></span>; <span class="comment">//根据一个给定参数返回一个socket类型的BIO，成功则返回该BIO指针，失败返回NULL</span></span><br></pre></td></tr></table></figure>
<p>Socket类型的BIO_METHOD结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BIO_METHOD methods_sockp=</span><br><span class="line">&#123;</span><br><span class="line">     BIO_TYPE_SOCKET,</span><br><span class="line">     <span class="string">&quot;socket&quot;</span>,</span><br><span class="line">     sock_write,</span><br><span class="line">     sock_read,</span><br><span class="line">     sock_puts,</span><br><span class="line">     <span class="literal">NULL</span>, <span class="comment">/* sock_gets, 在Socket的BIO类型中不支持*/</span></span><br><span class="line">     sock_ctrl,</span><br><span class="line">     sock_new,</span><br><span class="line">     sock_free,</span><br><span class="line">     <span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="null型bio"><a class="markdownIt-Anchor" href="#null型bio"></a> NULL型BIO</h4>
<p>NULL类型的BIO是一个空的Source/Sink型BIO，写入这个BIO的数据都被丢掉，从这里执行读操作也总是返回EOF。其相关函数定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/bio.h&gt; </span></span></span><br><span class="line">     　　</span><br><span class="line"><span class="function">BIO_METHOD * <span class="title">BIO_s_null</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>NULL类型的BIO_METHOD结构定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static BIO_METHOD null_method&#x3D;</span><br><span class="line">&#123;</span><br><span class="line">        BIO_TYPE_NULL,</span><br><span class="line">    　　 &quot;NULL&quot;,</span><br><span class="line">    　　 null_write,</span><br><span class="line">    　　 null_read,</span><br><span class="line">    　　 null_puts,</span><br><span class="line">    　　 null_gets,</span><br><span class="line">    　　 null_ctrl,</span><br><span class="line">    　　 null_new,</span><br><span class="line">    　　 null_free,</span><br><span class="line">    　　 NULL,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从结构上看，这个类型的BIO实现了不少的函数，但是，所有这些函数都只是简单返回0、1或者输入数据的长度，而不作任何事情。</p>
<p>一般来说，在openssl里面，<strong>这种类型的BIO是置放在BIO链的末尾</strong>的，比如在应用程序中，如果你要将一些数据通过filter型的BIO  digest进行摘要算法，但不需要把它送往任何地方，又因为一个BIO链要求以source/sink型BIO开始或结束，所以这时候就可以在BIO链的末尾添加一个source/sink型的NUll类型BIO来实现这个功能。</p>
<h4 id="内存类型bio"><a class="markdownIt-Anchor" href="#内存类型bio"></a> 内存类型BIO</h4>
<p>内存型BIO是source/sink型BIO，它<strong>使用内存作为它的I/O</strong>。它定义的相关函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/bio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BIO_METHOD * <span class="title">BIO_s_mem</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">BIO_set_mem_eof_return(BIO *b,<span class="keyword">int</span> v) <span class="comment">//设置一个没有数据的内存型BIO的执行读动作的行为</span></span><br><span class="line"><span class="function"><span class="keyword">long</span>  <span class="title">BIO_get_mem_data</span><span class="params">(BIO *b, <span class="keyword">char</span> **pp)</span> <span class="comment">//将参数pp的指针指向内存型BIO的数据开始处</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">BIO_set_mem_buf</span><span class="params">(BIO *b,BUF_MEM *bm,<span class="keyword">int</span> c)</span> <span class="comment">//将参数bm代表的BUF_MEM结构作为该BIO的底层结构</span></span></span><br><span class="line"><span class="function"><span class="title">BIO_get_mem_ptr</span><span class="params">(BIO *b,BUF_MEM **pp)</span> <span class="comment">//将底层的BUF_MEM结构放在指针pp中</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">BIO *<span class="title">BIO_new_mem_buf</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">int</span> len)</span></span>; <span class="comment">//创建一个内存型BIO，其数据为buf里面长度为len的数据，如果参数len是－1，那么就默认buf是以null结束的，使用strlen计算长度。这时候BIO被设置为只读的，不能执行写操作。它用于数据需要存储在一块静态内存中并以BIO形式存在的时候。所需要的数据是直接从内存中读取的，而不是先要执行拷贝操作（读写方式的内存BIO就是要先拷贝），这也就要求这块内存是只读的，不能改变，一直维持到BIO被释放。</span></span><br></pre></td></tr></table></figure>
<p>写进该类型BIO的数据被存储在BUF_MEM结构中，该结构被定义为适合存储数据的一种结构，其结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">buf_mem_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">int</span> length； <span class="comment">/* current number of bytes */</span></span><br><span class="line">     <span class="keyword">char</span> *data;</span><br><span class="line">     <span class="keyword">int</span> <span class="built_in">max</span>; <span class="comment">/* size of buffer */</span></span><br><span class="line">&#125; BUF_MEM;</span><br></pre></td></tr></table></figure>
<p>注意内存型BIO的内存是可以无限扩大的，也就是说无论写入多少数据都可以成功执行。一般任何写入内存型BIO的数据都可以被读出，除非该内存型BIO为只读类型。</p>
<p>内存型的BIO_METHOD定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BIO_METHOD mem_method=</span><br><span class="line">&#123;</span><br><span class="line">     BIO_TYPE_MEM,</span><br><span class="line">     <span class="string">&quot;memory buffer&quot;</span>,</span><br><span class="line">     mem_write,</span><br><span class="line">     mem_read,</span><br><span class="line">     mem_puts,</span><br><span class="line">     mem_gets,</span><br><span class="line">     mem_ctrl,</span><br><span class="line">     mem_new,</span><br><span class="line">     mem_free,</span><br><span class="line">     <span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>BIO_write和BIO_read</strong>函数是支持的。对内存型BIO执行写操作总是成功的，因为内存型BIO的内存能够无限扩大。<strong>任何一个对可读写的内存型BIO的</strong>读操作都会在使用内部拷贝操作从BIO里面删除该段数据，这样一来，如果BIO里面有大量的数据，而读的却只是很小的一些片断，那么会导致操作非常慢。<strong>使用只读的内存型BIO避免了这个问题</strong>。在使用的时候，如果内存型BIO必须使用可读写的，那么可以加一个Buffer型BIO到BIO链中，这可以使操作速度更快。</p>
<p><strong>BIO_gets和BIO_puts</strong>操作在内存型BIO是支持的。</p>
<p>如果设置了BIO_CLOSE标志，那么内存型BIO被释放的时候其底层的BUF_MEM型BIO也同时被释放。</p>
<p><strong>BIO_reset</strong>函数被调用时，如果该BIO是可读写的，那么该BIO所有数据都会被清空；如果该BIO是只读的，那么该操作只会简单将指针指向原始位置，里面的数据可以再读。</p>
<p><strong>BIO_eof</strong>返回true，表明只读时候BIO里面没有可读数据。</p>
<p><strong>BIO_ctrl_pending</strong>返回目前BIO里面存储的数据的字节(byte)数。</p>
<p>程序示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BIO     *b=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span>     len=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span>    *out=<span class="literal">NULL</span>;</span><br><span class="line">	b=BIO_new(BIO_s_mem());</span><br><span class="line">	len=BIO_write(b,<span class="string">&quot;openssl&quot;</span>,<span class="number">4</span>); <span class="comment">//将4字节的数据写入b（即只写入了&quot;open&quot;），返回值为4</span></span><br><span class="line">	len=BIO_printf(b,<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;Hello world!\n&quot;</span>); <span class="comment">//将字符串写入b</span></span><br><span class="line">	len=BIO_ctrl_pending(b); <span class="comment">//返回存储字节数</span></span><br><span class="line">	out=(<span class="keyword">char</span> *)OPENSSL_malloc(len);</span><br><span class="line">	len=BIO_read(b,out,len); <span class="comment">//从b的缓冲区中读取全部字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,out);<span class="comment">//使用printf可以将out中的内容打印出来</span></span><br><span class="line">	OPENSSL_free(out);</span><br><span class="line">	BIO_free(b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bio对-2"><a class="markdownIt-Anchor" href="#bio对-2"></a> BIO对</h4>
<p>BIO对也是作为一种source/sink类型的BIO来处理的，也就是说，BIO里面还提供了一种专门的BIO_METHO方法来处理BIO对的各种操作。BIO对类型的BIO各种相关的函数定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/bio.h&gt; </span></span></span><br><span class="line"><span class="function">BIO_METHOD *<span class="title">BIO_s_bio</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_make_bio_pair(b1,b2) (int)BIO_ctrl(b1,BIO_C_MAKE_BIO_PAIR,0,b2) <span class="comment">//将两个单独的BIO连接起来形成BIO对</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_destroy_bio_pair(b) (int)BIO_ctrl(b,BIO_C_DESTROY_BIO_PAIR,0,NULL) <span class="comment">//将两个连接起来的BIO对拆开，如果一个BIO对的任何一个被释放则自动执行该操作</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_shutdown_wr(b) (int)BIO_ctrl(b, BIO_C_SHUTDOWN_WR, 0, NULL) <span class="comment">//关闭BIO对中的其中一个BIO，在这之后，针对于该BIO的写操作返回错误，从另一个BIO读取数据的时候返回剩余有效数据或者EOF</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_set_write_buf_size(b,size) (int)BIO_ctrl(b,BIO_C_SET_WRITE_BUF_SIZE,size,NULL) <span class="comment">//设置BIO的缓冲区大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_get_write_buf_size(b,size) (size_t)BIO_ctrl(b,BIO_C_GET_WRITE_BUF_SIZE,size,NULL) <span class="comment">//返回写缓冲区的大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BIO_new_bio_pair</span><span class="params">(BIO **bio1, <span class="keyword">size_t</span> writebuf1, BIO **bio2, <span class="keyword">size_t</span> writebuf2)</span></span>; <span class="comment">//其实是调用BIO_new,BIO_make_bio_pair和BIO_set_write_buf_size函数来创建一对BIO对</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_get_write_guarantee(b) (int)BIO_ctrl(b,BIO_C_GET_WRITE_GUARANTEE,0,NULL) <span class="comment">//返回当前能够写入BIO的数据的最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">BIO_ctrl_get_write_guarantee</span><span class="params">(BIO *b)</span></span>; <span class="comment">//返回当前能够写入BIO的数据的最大长度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_get_read_request(b) (int)BIO_ctrl(b,BIO_C_GET_READ_REQUEST,0,NULL) <span class="comment">//返回要求发送的数据的长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">BIO_ctrl_get_read_request</span><span class="params">(BIO *b)</span></span>; <span class="comment">//返回要求发送的数据的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">BIO_ctrl_reset_read_request</span><span class="params">(BIO *b)</span></span>; <span class="comment">//把BIO_get_read_request要返回值设置为0</span></span><br></pre></td></tr></table></figure>
<p>所谓的BIO对只是将两个BIO的终端输出（BIO结构中参数peer的ptr成员）相互设置为对方，从而形成一种对称的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bio1-&gt;peer-&gt;ptr&#x3D;bio2</span><br><span class="line">bio2-&gt;peer-&gt;ptr&#x3D;bio1</span><br></pre></td></tr></table></figure>
<p>BIO对类型的BIO_METHOD定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BIO_METHOD methods_biop =</span><br><span class="line">&#123;       </span><br><span class="line">     BIO_TYPE_BIO,</span><br><span class="line">     <span class="string">&quot;BIO pair&quot;</span>,</span><br><span class="line">     bio_write,</span><br><span class="line">     bio_read,</span><br><span class="line">     bio_puts,</span><br><span class="line">     <span class="literal">NULL</span> <span class="comment">/* 没有定义 bio_gets */</span>,</span><br><span class="line">     bio_ctrl,</span><br><span class="line">     bio_new,</span><br><span class="line">     bio_free,</span><br><span class="line">     <span class="literal">NULL</span> <span class="comment">/* 没有定义 bio_callback_ctrl */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为没有提供内部数据结构的内存锁结构(lock)，所以，<strong>一般来说一个BIO对的两个BIO都必须在一个线程下使用</strong>。因为BIO链通常是以一个source/sink  BIO结束的，所以就可以实现应用程序通过控制BIO对的一个BIO从而控制整个BIO链的数据处理。其实，也就相当于BIO对给应用程序提供了一个处理整个BIO链的入口。BIO对的一个典型应用就是在应用程序里面控制TLS/SSL的I/O接口，一般来说，在应用程序想在TLS/SSL中使用非标准的传输方法或者不适合使用标准的socket方法的时候就可以采用这样的方法来实现。</p>
<p>BIO对释放的时候，需要分别释放两个BIO，如果在使用BIO_free或者BIO_free_all释放了其中一个BIO的时候，另一个BIO就也必须要释放。</p>
<p>当BIO对使用在双向应用程序的时候，如TLS/SSL，一定要对写缓冲区里面的数据执行flush操作。当然，也可以通过在BIO对中的另一个BIO调用BIO_pending函数，如果有数据在缓冲区中，那么就将它们读出并发送到底层的传输通道中去。为了使请求或BIO_should_read函数调用成功（为true），在执行任何正常的操作（如select）之前，都必须这样做才行。</p>
<p><strong>BIO_read</strong>函数从缓冲BIO中读取数据，如果没有数据，则发出一个重试请求。</p>
<p><strong>BIO_write</strong>函数往缓冲BIO中写入数据，如果缓冲区已满，则发出一个重试请求。</p>
<p><strong>BIO_ctrl_pending和BIO_ctrl_wpending</strong>函数可以用来查看在读或写缓冲区里面有效的数据的数量。</p>
<p><strong>BIO_reset</strong>函数将写缓冲区里面的数据清除。</p>
<h4 id="连接类型bio"><a class="markdownIt-Anchor" href="#连接类型bio"></a> 连接类型BIO</h4>
<p>该类型的BIO封装了socket的Connect方法，它使得编程的时候可以使用统一的BIO规则进行socket的connect连接的操作和数据的发送接受，而不用关心具体平台的Socket的connect方法的区别。其相关定义的一些函数如下(openssl\bio.h)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BIO_METHOD * <span class="title">BIO_s_connect</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>      BIO_set_conn_hostname(b,name)  BIO_ctrl(b,BIO_C_SET_CONNECT,0,(char *)name) <span class="comment">//使用字符串设置主机名，可以是IP地址或是网址等形式</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>      BIO_set_conn_port(b,port)      BIO_ctrl(b,BIO_C_SET_CONNECT,1,(char *)port) <span class="comment">//设置主机端口号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>      BIO_set_conn_ip(b,ip)          BIO_ctrl(b,BIO_C_SET_CONNECT,2,(char *)ip) <span class="comment">//使用二进制模式设置ip</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>      BIO_set_conn_int_port(b,port)  BIO_ctrl(b,BIO_C_SET_CONNECT,3,(char *)port) <span class="comment">//以整数形式设置主机端口号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>      BIO_get_conn_hostname(b)       BIO_ptr_ctrl(b,BIO_C_GET_CONNECT,0) <span class="comment">//返回连接类型BIO的主机名</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>      BIO_get_conn_port(b)           BIO_ptr_ctrl(b,BIO_C_GET_CONNECT,1) <span class="comment">//返回字符串类型的端口信息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>      BIO_get_conn_ip(b,ip)          BIO_ptr_ctrl(b,BIO_C_SET_CONNECT,2) <span class="comment">//返回二进制形式的ip地址</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>      BIO_get_conn_int_port(b,port)  BIO_int_ctrl(b,BIO_C_SET_CONNECT,3,port) <span class="comment">//返回整数形式端口号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>      BIO_set_nbio(b,n)              BIO_ctrl(b,BIO_C_SET_NBIO,(n),NULL) <span class="comment">//设置I/O的非阻塞标志</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>      BIO_do_connect(b)              BIO_do_handshake(b) <span class="comment">//进行连接操作，如果连接成功返回1，否则返回0或负值</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BIO *        <span class="title">BIO_new_connect</span><span class="params">(<span class="keyword">char</span> *str)</span> <span class="comment">//创建并返回一个连接类型的BIO，其实，它调用了BIO_s_connect、BIO_new和BIO_set_conn_hostname函数完成了整个操作。成功则返回一个BIO，否则返回NULL。</span></span></span><br></pre></td></tr></table></figure>
<p>这种类型的BIO_METHOD结构定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static BIO_METHOD methods_connectp&#x3D;</span><br><span class="line">&#123;</span><br><span class="line">     BIO_TYPE_CONNECT,</span><br><span class="line">     &quot;socket connect&quot;,</span><br><span class="line">     conn_write,</span><br><span class="line">     conn_read,</span><br><span class="line">     conn_puts,</span><br><span class="line">     NULL, &#x2F;* connect_gets, *&#x2F;</span><br><span class="line">     conn_ctrl,</span><br><span class="line">     conn_new,</span><br><span class="line">     conn_free,</span><br><span class="line">     conn_callback_ctrl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>BIO_read和BIO_write</strong>的操作调用底层的连接的IO操作来完成。如果在服务器地址和端口设置正确，但连接没有建立的时候调用读写操作函数，那么会先进行连接的建立操作，然后再进行读写操作。</p>
<p><strong>BIO_puts</strong>操作是支持的，但是<strong>BIO_gets操作不支持</strong>，这在该类型BIO的BIO_METHOD结构定义中就可以看出来。</p>
<p>如果<strong>关闭标志设置了，那么在BIO被释放的时候，任何活动的连接和socket都会被关闭</strong>。</p>
<p><strong>BIO_reset</strong>方法被调用的时候，连接（connect）类型的BIO的任何活动连接都会被关闭，从而回到可以重新跟同样的主机建立连接的状态。</p>
<p><strong>BIO_get_fd</strong>函数返回连接类型的BIO的底层socket，当参数c不是NULL的时候，就将该socket赋值给c，当然，socket也作为返回值。c参数应该为int*类型。如果BIO没有初始化，则返回－1。</p>
<p>例：连接到本地Web服务器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>	<span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BIO *cbio, *out;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">char</span> tmpbuf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    cbio = BIO_new_connect(<span class="string">&quot;localhost:http&quot;</span>);</span><br><span class="line">    out = BIO_new_fp(<span class="built_in">stdout</span>, BIO_NOCLOSE);</span><br><span class="line">    <span class="keyword">if</span>(BIO_do_connect(cbio) &lt;= <span class="number">0</span>) </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error connecting to server\n&quot;</span>);</span><br><span class="line">    BIO_puts(cbio, <span class="string">&quot;GET / HTTP/1.0\n\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(;;) </span><br><span class="line">    &#123;</span><br><span class="line">           len = BIO_read(cbio, tmpbuf, <span class="number">1024</span>);</span><br><span class="line">           <span class="keyword">if</span>(len &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">           BIO_write(out, tmpbuf, len);</span><br><span class="line">    &#125;</span><br><span class="line">    BIO_free(cbio);</span><br><span class="line">    BIO_free(out);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接受类型bio"><a class="markdownIt-Anchor" href="#接受类型bio"></a> 接受类型BIO</h4>
<p>接受（accept）类型的BIO跟连接（connect）类型BIO是相对应的，它封装了Socket的accept方法及其相关的一些操作，使得能够对不同的平台使用同一的函数进行操作。其定义的相关函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;openssl&#x2F;bio.h&gt;</span><br><span class="line">BIO_METHOD * BIO_s_accept(void);  </span><br><span class="line"></span><br><span class="line">#define      BIO_set_accept_port(b,name) BIO_ctrl(b,BIO_C_SET_ACCEPT,0,(char*)name) &#x2F;&#x2F;使用字串名来设置接受端口，形式为&quot;host:port&quot;，这两部分可以为*，表示可以使用任意接口和端口</span><br><span class="line">#define      BIO_get_accept_port(b) BIO_ptr_ctrl(b,BIO_C_GET_ACCEPT,0)  </span><br><span class="line"></span><br><span class="line">BIO *        BIO_new_accept(char *host_port); &#x2F;&#x2F;该函数将BIO_new和BIO_set_accept_port函数放在一个函数里面调用，创建一个新的接受类型BIO</span><br><span class="line"></span><br><span class="line">#define      BIO_set_nbio_accept(b,n) BIO_ctrl(b,BIO_C_SET_ACCEPT,1,(n)?&quot;a&quot;:NULL) &#x2F;&#x2F;设置接受socket是否为阻塞模式，参数n为0为阻塞模式，1为非阻塞模式</span><br><span class="line">#define      BIO_set_accept_bios(b,bio) BIO_ctrl(b,BIO_C_SET_ACCEPT,2,(char *)bio) &#x2F;&#x2F;设置一个BIO链，当接受到一个连接之后，这个设置好的BIO链就会被附加到整个BIO链上。调用这一函数之后，只有在接受BIO被释放后链上的BIO才能自动释放</span><br><span class="line">#define      BIO_set_bind_mode(b,mode) BIO_ctrl(b,BIO_C_SET_BIND_MODE,mode,NULL) &#x2F;&#x2F;设置绑定模式</span><br><span class="line">#define      BIO_get_bind_mode(b,mode) BIO_ctrl(b,BIO_C_GET_BIND_MODE,0,NULL) &#x2F;&#x2F;获得绑定模式</span><br><span class="line">#define      BIO_BIND_NORMAL 0 &#x2F;&#x2F;默认绑定模式，那么另外一个socket就不能绑定到同一个端口</span><br><span class="line">#define      BIO_BIND_REUSEADDR_IF_UNUSED 1 &#x2F;&#x2F;绑定模式1，首先会尝试BIO_BIND_NORMAL的模式绑定到端口，如果失败了而且端口没有使用，那么就会使用BIO_BIND_REUSEADDR 模式绑定到端口</span><br><span class="line">#define      BIO_BIND_REUSEADDR 2 &#x2F;&#x2F;绑定模式2，另外的socket可以绑定到同一个端口</span><br><span class="line">#define      BIO_do_accept(b) BIO_do_handshake(b) 当它在接受（accept）BIO设置好之后第一被调用的时候，它会创建一个接受socket并把它跟地址绑定；第二次被调用的时候，它会等待连接的到来</span><br></pre></td></tr></table></figure>
<p>接受类型BIO的BIO_METHOD结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BIO_METHOD methods_acceptp=</span><br><span class="line">&#123;</span><br><span class="line">     BIO_TYPE_ACCEPT,</span><br><span class="line">     <span class="string">&quot;socket accept&quot;</span>,</span><br><span class="line">     acpt_write,</span><br><span class="line">     acpt_read,</span><br><span class="line">     acpt_puts,</span><br><span class="line">     <span class="literal">NULL</span>, <span class="comment">/* connect_gets, */</span></span><br><span class="line">     acpt_ctrl,</span><br><span class="line">     acpt_new,</span><br><span class="line">     acpt_free,</span><br><span class="line">     <span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这一类型的BIO对各种平台的TCP/IP的accept做了封装，所以在使用的时候就可以同一的使用BIO的规则进行操作，而不用担心因为不同的平台带来程序改写或增加移植的工作量。</p>
<p><strong>BIO_read和BIO_write</strong>函数操作调用了底层平台连接的I/O相关操作，如果这时候没有连接建立，端口设置正确，那么该BIO就会等待连接的建立。事实上，当一个连接建立的时候，一个新的socket类型BIO就会被创建并附加到BIO链中，形成accept-&gt;socket的BIO结构，所以这时候对初始化了的接受socket进行IO操作就会导致它处于等待连接建立的状态。当一个接受类型的BIO在BIO链的末尾的时候，在处理I/O调用之前它会先等待一个连接的建立；如果不是在末尾，那么它简单的把I/O调用传到下一个BIO。</p>
<p>如果接受（accept）类型BIO的<strong>关闭标志设置</strong>了，那么当BIO被释放的时候，该BIO链上任何活动的连接和socket都会被关闭。</p>
<p><strong>BIO_get_fd和BIO_set_fd</strong>可以用来取得和设置该连接的socket描述符。</p>
<h3 id="filter类型bio"><a class="markdownIt-Anchor" href="#filter类型bio"></a> Filter类型BIO</h3>
<h4 id="null型过滤bio"><a class="markdownIt-Anchor" href="#null型过滤bio"></a> NULL型过滤BIO</h4>
<p>NULL型的filterBIO的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BIO_METHOD * <span class="title">BIO_f_null</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数返回一个NULL型的过滤BIO_METHOD结构，NULL过滤型BIO是一个不作任何事情的BIO。针对该类型BIO的任何调用都会被简单传递中BIO链中的下一个BIO中去，也就相当于该BIO是不存在的一样。</p>
<h4 id="缓冲类型bio"><a class="markdownIt-Anchor" href="#缓冲类型bio"></a> 缓冲类型BIO</h4>
<p>缓冲类型BIO的相关定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_get_buffer_num_lines(b)         BIO_ctrl(b,BIO_C_GET_BUFF_NUM_LINES,0,NULL) <span class="comment">//返回缓冲区中目前数据的行数</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_set_read_buffer_size(b,size)    BIO_int_ctrl(b,BIO_C_SET_BUFF_SIZE,size,0) <span class="comment">//设置读缓冲区大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_set_write_buffer_size(b,size)   BIO_int_ctrl(b,BIO_C_SET_BUFF_SIZE,size,1) <span class="comment">//设置写缓冲区大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_set_buffer_size(b,size)         BIO_ctrl(b,BIO_C_SET_BUFF_SIZE,size,NULL) <span class="comment">//设置读写缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_set_buffer_read_data(b,buf,num) BIO_ctrl(b,BIO_C_SET_BUFF_READ_DATA,num,buf) <span class="comment">//清空缓冲区原有的数据</span></span></span><br></pre></td></tr></table></figure>
<p>buffer类型的BIO_METHOD结构定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static BIO_METHOD methods_buffer&#x3D;</span><br><span class="line">&#123;</span><br><span class="line">     BIO_TYPE_BUFFER,</span><br><span class="line">     &quot;buffer&quot;,</span><br><span class="line">     buffer_write,</span><br><span class="line">     buffer_read,</span><br><span class="line">     buffer_puts,</span><br><span class="line">     buffer_gets,</span><br><span class="line">     buffer_ctrl,</span><br><span class="line">     buffer_new,</span><br><span class="line">     buffer_free,</span><br><span class="line">     buffer_callback_ctrl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由结构定义可见，<strong>该类型BIO支持所有BIO的I/O函数</strong>。</p>
<p>写入缓冲(buffer)BIO的数据存储在缓冲区里面，定期写入到BIO链的下一个BIO中。事实上，<strong>只有缓冲区已满或者调用了BIO_flush函数时</strong>，数据才会写入下面的BIO，所以，当任何存储在缓冲区的数据需要写入的时候（如在使用BIO_pop函数从BIO链中删除一个buffer类型BIO之前），<strong>必须使用BIO_flush函数</strong>，如果BIO链的末尾是一个非阻塞型的BIO，有时候调用BIO_flush可能出现失败，需要重试的情况。</p>
<p>从该类型BIO读取数据时，数据从下一个BIO填充到该BIO内部缓冲区中，然后再读出来。该类型BIO支持BIO_gets和BIO_puts方法，事实上，BIO_gets函数是通过在下一个BIO的BIO_read函数来实现的，所以，如果一个BIO不支持BIO_gets方法（如SSL类型的BIO），可以通过预先附加一个buffer类型BIO来实现BIO_gets的功能。</p>
<p><strong>BIO_reset</strong>被调用的时候，该类型BIO里面的所有数据都会被清空。</p>
<h4 id="base64类型bio"><a class="markdownIt-Anchor" href="#base64类型bio"></a> Base64类型BIO</h4>
<p>Base64类型的BIO定义在evp目录下。当往该BIO写入数据时，数据被Base64编码，当从该BIO读数据时，数据被Base64解码。该BIO不支持BIO_gets和BIO_puts的功能。它的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BIO_METHOD * <span class="title">BIO_f_base64</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Base64类型的BIO_METHOD结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BIO_METHOD methods_b64=</span><br><span class="line">&#123;</span><br><span class="line">     BIO_TYPE_BASE64,</span><br><span class="line">     <span class="string">&quot;base64 encoding&quot;</span>,</span><br><span class="line">     b64_write,</span><br><span class="line">     b64_read,</span><br><span class="line">     <span class="literal">NULL</span>, <span class="comment">/* b64_puts, */</span></span><br><span class="line">     <span class="literal">NULL</span>, <span class="comment">/* b64_gets, */</span></span><br><span class="line">     b64_ctrl,</span><br><span class="line">     b64_new,</span><br><span class="line">     b64_free,</span><br><span class="line">     b64_callback_ctrl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>BIO_set_flags函数可以用来设置标记BIO_FLAGS_BASE64_NO_NL，该标记设置后，将把所有数据编码成为一行。由于base64编码本身格式的原因，不能准确可靠的决定编码后的数据块的结束位置，使用的时候需要注意数据的长度问题。</p>
<p>程序示例：将字符串进行编码并将编码后的数据输出到标准输出设备</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BIO *bio, *b64;</span><br><span class="line"><span class="keyword">char</span> message[] = <span class="string">&quot;Hello World \n&quot;</span>;</span><br><span class="line">b64 = BIO_new(BIO_f_base64());</span><br><span class="line">bio = BIO_new_fp(<span class="built_in">stdout</span>, BIO_NOCLOSE);</span><br><span class="line">bio = BIO_push(b64, bio);</span><br><span class="line">BIO_write(bio, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">BIO_flush(bio);</span><br><span class="line">BIO_free_all(bio);</span><br></pre></td></tr></table></figure>
<h4 id="cipher类型bio"><a class="markdownIt-Anchor" href="#cipher类型bio"></a> Cipher类型BIO</h4>
<p>该类型的BIO将<strong>写入该BIO的数据加密，从该BIO读数据时数据被解密</strong>，它事实上封装了EVP_CipherInit、EVP_CipherUpdate、EVP_CipherFinal三种方法。它不支持BIO_puts和BIO_gets的方法，如果要使用这两个方法，可以通过在前面附加一个buffer类型的BIO来实现。它的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BIO_METHOD * <span class="title">BIO_f_cipher</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//返回cipher类型的BIO_METHOD</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>         <span class="title">BIO_set_cipher</span><span class="params">(BIO *b,<span class="keyword">const</span> EVP_CIPHER *cipher,<span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv, <span class="keyword">int</span> enc)</span></span>; <span class="comment">//设置BIO的加密算法，key为加密密钥，iv为初始化的IV，enc=1为加密，enc=0为解密</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>          <span class="title">BIO_get_cipher_status</span><span class="params">(BIO *b)</span> <span class="comment">//检测解密是否成功执行</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>          <span class="title">BIO_get_cipher_ctx</span><span class="params">(BIO *b, EVP_CIPHER_CTX **pctx)</span> <span class="comment">//返回BIO的内部加密体制</span></span></span><br></pre></td></tr></table></figure>
<p>cipher类型的BIO_METHOD结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BIO_METHOD methods_enc=</span><br><span class="line">&#123;</span><br><span class="line">     BIO_TYPE_CIPHER,</span><br><span class="line">     <span class="string">&quot;cipher&quot;</span>,</span><br><span class="line">     enc_write,</span><br><span class="line">     enc_read,</span><br><span class="line">     <span class="literal">NULL</span>, <span class="comment">/* enc_puts, */</span></span><br><span class="line">     <span class="literal">NULL</span>, <span class="comment">/* enc_gets, */</span></span><br><span class="line">     enc_ctrl,</span><br><span class="line">     enc_new,</span><br><span class="line">     enc_free,</span><br><span class="line">     enc_callback_ctrl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>跟base64型BIO相似，当调用<strong>BIO_flush函数</strong>时，表明所有数据都已经通过该类型BIO加密了，用来将最后的一段数据通过该BIO进行加密。在进行加密的时候，<strong>必须调用BIO_flush</strong>函数来把最后的数据通过BIO进行加密，否则最后的数据会在解密的时候出现失败的情况。当从一个加密类型的BIO读取数据时，当读到最后一段数据时，会通过检测EOF自动检测到数据结束标志并自动将这段数据解密。</p>
<h4 id="md类型bio"><a class="markdownIt-Anchor" href="#md类型bio"></a> MD类型BIO</h4>
<p>MD类型BIO对通过它的任何数据都进行摘要操作（message digest），事实上，该类型BIO封装了EVP_DigestInit、EVP_DigestUpdate和EVP_DigestFinal三个函数的功能和行为。该类型BIO是完全对称的，也就是说，不管是读数据（BIO_read）还是写数据（BIO_write），都进行相同的摘要操作。</p>
<p>MD类型BIO的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BIO_METHOD * <span class="title">BIO_f_md</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BIO_set_md</span><span class="params">(BIO *b,EVP_MD *md)</span></span>; <span class="comment">//用参数md设置给定的BIO摘要算法。该函数必须在执行读写操作前调用，用于初始化一个摘要类型的BIO，调用成功返回1，失败返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BIO_get_md</span><span class="params">(BIO *b,EVP_MD **mdp)</span></span>; <span class="comment">//返回BIO摘要方法的指针到mdp参数里面。调用成功返回1，否则返回0。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BIO_get_md_ctx</span><span class="params">(BIO *b,EVP_MD_CTX **mdcp)</span></span>; <span class="comment">//返回摘要BIO的方法结构到mdcp参数里面</span></span><br></pre></td></tr></table></figure>
<p>MD类型的BIO_METHOD结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BIO_METHOD methods_md=</span><br><span class="line">&#123;</span><br><span class="line">     BIO_TYPE_MD,<span class="string">&quot;message digest&quot;</span>,</span><br><span class="line">     md_write,</span><br><span class="line">     md_read,</span><br><span class="line">     <span class="literal">NULL</span>, <span class="comment">/* md_puts, */</span></span><br><span class="line">     md_gets,</span><br><span class="line">     md_ctrl,</span><br><span class="line">     md_new,</span><br><span class="line">     md_free,</span><br><span class="line">     md_callback_ctrl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>BIO_gets</strong>函数执行的时候，如果给定的size参数足够大，可以完成摘要（digest）计算，那么就会返回摘要值。BIO_puts函数是不支持的，如果需要支持该函数，可以在前面附加一个buffer类型的BIO。<br />
<strong>BIO_reset</strong>函数重新初始化一个摘要类型的BIO，事实上，它是简单重新调用了EVP_DigestInit函数进行初始化。<br />
注意，在从一个摘要BIO里面读取完摘要信息之后，在重新使用该BIO之前，<strong>必须</strong>调用BIO_reset或BIO_set_md重新初始化该BIO才行。</p>
<p>示例：从标准输入流中读取数据然后输出数据摘要</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        BIO *bio,*mdtmp;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> rdlen;</span><br><span class="line"></span><br><span class="line">		bio=BIO_new_fp(<span class="built_in">stdin</span>,BIO_NOCLOSE);</span><br><span class="line">        mdtmp=BIO_new(BIO_f_md());</span><br><span class="line">        BIO_set_md(mdtmp,EVP_sha1());</span><br><span class="line"></span><br><span class="line">        bio=BIO_push(mdtmp,bio);</span><br><span class="line">        mdtmp=BIO_new(BIO_f_md());</span><br><span class="line">        BIO_set_md(mdtmp,EVP_md5());</span><br><span class="line">        bio=BIO_push(mdtmp,bio);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">                rdlen=BIO_read(bio,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;<span class="keyword">while</span>(rdlen&gt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">                EVP_MD* md;</span><br><span class="line">                mdtmp=BIO_find_type(mdtmp,BIO_TYPE_MD);</span><br><span class="line">                <span class="keyword">if</span>(!mdtmp)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                BIO_get_md(mdtmp,&amp;md);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,OBJ_nid2sn(EVP_MD_type(md)));</span><br><span class="line">                <span class="keyword">int</span> mdlen=BIO_gets(mdtmp,buf,EVP_MAX_MD_SIZE);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mdlen;i++)</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;:%02X&quot;</span>,buf[i]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                mdtmp=BIO_next(mdtmp);</span><br><span class="line">        &#125;<span class="keyword">while</span>(mdtmp);</span><br><span class="line">        BIO_free_all(bio);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ssl类型bio"><a class="markdownIt-Anchor" href="#ssl类型bio"></a> SSL类型BIO</h4>
<p>SSL类型BIO封装了openssl里面的ssl规则和函数，相当于提供了一个使用SSL很好的有效工具。它的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openss/ssl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BIO_METHOD *<span class="title">BIO_f_ssl</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_set_ssl(b,ssl,c)       BIO_ctrl(b,BIO_C_SET_SSL,c,(char *)ssl) <span class="comment">//设置ssl类型BIO的内部ssl指针指向ssl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_get_ssl(b,sslp)        BIO_ctrl(b,BIO_C_GET_SSL,0,(char *)sslp) <span class="comment">//返回ssl类型BIO内部的ssl结构指针，得到该指针后可以用标志的ssl函数对它进行操作</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_set_ssl_mode(b,client) BIO_ctrl(b,BIO_C_SSL_MODE,client,NULL) <span class="comment">//设置ssl的工作模式，参数client为1代表客户端模式，client为0代表服务器模式</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_set_ssl_renegotiate_bytes(b,num) BIO_ctrl(b,BIO_C_SET_SSL_RENEGOTIATE_BYTES,num,NULL); <span class="comment">//设置重新进行session协商的读写数据的长度为num</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_set_ssl_renegotiate_timeout(b,seconds) </span></span><br><span class="line">BIO_ctrl(b,BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT,seconds,<span class="literal">NULL</span>); <span class="comment">//设置重新进行session协商的时间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_get_num_renegotiates(b) BIO_ctrl(b,BIO_C_SET_SSL_NUM_RENEGOTIATES,0,NULL); <span class="comment">//返回ssl连接在因为字节限制或时间限制导致session重新协商之前总共读写的数据长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BIO*    <span class="title">BIO_new_ssl</span><span class="params">(SSL_CTX *ctx,<span class="keyword">int</span> client)</span></span>; <span class="comment">//使用ctx参数所代表的SSL_CTX结构创建一个SSL类型的BIO，如果client不为0则使用客户端模式</span></span><br><span class="line"><span class="function">BIO*    <span class="title">BIO_new_ssl_connect</span><span class="params">(SSL_CTX *ctx)</span></span>; <span class="comment">//创建一个包含ssl类型BIO的新BIO链，并在后面附加了一个连接类型的BIO</span></span><br><span class="line"><span class="function">BIO*    <span class="title">BIO_new_buffer_ssl_connect</span><span class="params">(SSL_CTX *ctx)</span></span>; <span class="comment">//创建一个包含buffer型的BIO，一个SSL类型的BIO和一个连接类型的BIO</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>     <span class="title">BIO_ssl_copy_session_id</span><span class="params">(BIO *to,BIO *from)</span></span>; <span class="comment">//将BIO链from的SSL Session ID拷贝到BIO链to中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>    <span class="title">BIO_ssl_shutdown</span><span class="params">(BIO *bio)</span></span>; <span class="comment">//关闭一个BIO链中的ssl连接</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_do_handshake(b) BIO_ctrl(b,BIO_C_DO_STATE_MACHINE,0,NULL) <span class="comment">//在相关的BIO上启动SSL握手过程并建立SSL连接。连接成功建立返回1，否则返回0或负值</span></span></span><br></pre></td></tr></table></figure>
<p>SSL类型的BIO_METHOD结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BIO_METHOD methods_sslp=</span><br><span class="line">&#123;</span><br><span class="line">    BIO_TYPE_SSL,<span class="string">&quot;ssl&quot;</span>,</span><br><span class="line">    ssl_write,</span><br><span class="line">    ssl_read,</span><br><span class="line">    ssl_puts,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* ssl_gets, */</span></span><br><span class="line">    ssl_ctrl,</span><br><span class="line">    ssl_new,</span><br><span class="line">    ssl_free,</span><br><span class="line">    ssl_callback_ctrl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>BIO_read和BIO_write</strong>函数调用的时候，SSL类型的BIO会使用SSL协议进行底层的I/O操作。如果此时SSL连接并没有建立，那么就会在调用第一个IO函数的时候先进行连接的建立。</p>
<p>如果使用<strong>BIO_push</strong>将一个BIO附加到一个SSL类型的BIO上，那么SSL类型的BIO读写数据的时候，它会被自动调用。</p>
<p><strong>BIO_reset</strong>调用的时候，会调用SSL_shutdown函数关闭目前所有处于连接状态的SSL，然后再对下一个BIO调用BIO_reset，这功能一般就是将底层的传输连接断开。调用完成之后，SSL类型的BIO就处于初始的接受或连接状态。</p>
<p>如果<strong>设置了BIO关闭标志</strong>，那么SSL类型BIO释放的时候，内部的SSL结构也会被SSL_free函数释放。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/ssl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        BIO *sbio,*out;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">char</span> tmpbuf[<span class="number">1024</span>];</span><br><span class="line">        SSL_CTX* ctx;</span><br><span class="line">        SSL* ssl;</span><br><span class="line"></span><br><span class="line">        SSLeay_add_ssl_algorithms();</span><br><span class="line">        OpenSSL_add_all_algorithms();</span><br><span class="line">        ctx=SSL_CTX_new(SSLv23_client_method());</span><br><span class="line">        sbio=BIO_new_ssl_connect(ctx);</span><br><span class="line">        BIO_get_ssl(sbio,&amp;ssl);</span><br><span class="line">        <span class="keyword">if</span>(!ssl)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Cannot locate SSL pointer\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SSL_set_mode(ssl,SSL_MODE_AUTO_RETRY);</span><br><span class="line">        BIO_set_conn_hostname(sbio,<span class="string">&quot;mybank.icbc.com.cn:https&quot;</span>); <span class="comment">//这里可以改</span></span><br><span class="line">        out=BIO_new_fp(<span class="built_in">stdout</span>,BIO_NOCLOSE);</span><br><span class="line">        BIO_printf(out,<span class="string">&quot;Connecting......\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(BIO_do_connect(sbio)&lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Error connecting to server\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(BIO_do_handshake(sbio)&lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Error establishing SSL connection\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BIO_puts(sbio,<span class="string">&quot;GET/HTTP/1.0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(;;)</span><br><span class="line">        &#123;</span><br><span class="line">                len=BIO_read(sbio,tmpbuf,<span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">if</span>(len&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                BIO_write(out,tmpbuf,len);</span><br><span class="line">        &#125;</span><br><span class="line">        BIO_free_all(sbio);</span><br><span class="line">        BIO_free(out);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="evp模块"><a class="markdownIt-Anchor" href="#evp模块"></a> EVP模块</h1>
<h2 id="简介-2"><a class="markdownIt-Anchor" href="#简介-2"></a> 简介</h2>
<p>Openssl EVP(high-level cryptographic functions[1])提供了丰富的密码学中的各种函数。Openssl 中实现了各种对称算法、摘要算法以及签名/验签算法。EVP 函数将这些具体的算法进行了封装。 官方建议使用这些算法时最好调用EVP的上层封装，不建议单独使用某个算法。</p>
<p>EVP系列的函数的声明包含在”evp.h”里面，这是一系列封装了openssl加密库里面所有算法的函数。通过这样的统一的封装，使得只需要在初始化参数的时候做很少的改变，就可以使用相同的代码但采用不同的加密算法进行数据的加密和解密。</p>
<p>EVP系列函数主要封装了<strong>加密、摘要、编码</strong>三大类型的算法，使用算法前需要调用OpenSSL_add_all_algorithms函数。</p>
<p>其中以<strong>加密算法与摘要算法</strong>为基本，公开密钥算法是对数据加密采用了对称加密算法，对密钥采用非对称加密（公钥加密，私钥解密）。数字签名是非对称算法（私钥签名，公钥认证）。</p>
<p>EVP封装的功能函数有：</p>
<ul>
<li>实现了base64编解码BIO；</li>
<li>实现了加解密BIO；</li>
<li>实现了摘要BIO；</li>
<li>实现了reliable BIO；</li>
<li>封装了摘要算法；</li>
<li>封装了对称加解密算法；</li>
<li>封装了非对称密钥的加密(公钥)、解密(私钥)、签名与验证以及辅助函数；</li>
<li>基于口令的加密(PBE)；</li>
<li>对称密钥处理；</li>
<li>数字信封：数字信封用对方的公钥加密对称密钥，数据则用此对称密钥加密。发送给对方时，同时发送对称密钥密文和数据密文。接收方首先用自己的私钥解密密钥密文，得到对称密钥，然后用它解密数据。</li>
<li>其他辅助函数。</li>
</ul>
<h2 id="源码结构"><a class="markdownIt-Anchor" href="#源码结构"></a> 源码结构</h2>
<p>evp源码位于crypto/evp目录，可以分为如下几类：</p>
<h3 id="全局函数"><a class="markdownIt-Anchor" href="#全局函数"></a> 全局函数</h3>
<p>主要包括 c_allc.c、c_alld.c、c_all.c 以及names.c。他们加载openssl  支持的所有的对称算法和摘要算法，放入到哈希表中。实现了OpenSSL_add_all_digests、OpenSSL_add_all_ciphers  以及OpenSSL_add_all_algorithms(调用了前两个函数)函数。在进行计算时，用户也可以单独加载摘要函数（EVP_add_digest）和对称计算函数（EVP_add_cipher）。</p>
<h3 id="bio扩充"><a class="markdownIt-Anchor" href="#bio扩充"></a> BIO扩充</h3>
<p>包括 bio_b64.c、bio_enc.c、bio_md.c 和bio_ok.c，各自实现了BIO_METHOD方法，分别用于base64 编解码、对称加解密以及摘要。</p>
<h3 id="摘要算法封装"><a class="markdownIt-Anchor" href="#摘要算法封装"></a> 摘要算法封装</h3>
<p>由 digest.c 实现，实现过程中调用了对应摘要算法的回调函数。各个摘要算法提供了自己的EVP_MD 静态结构，对应源码为m_xxx.c。</p>
<h3 id="对称算法封装"><a class="markdownIt-Anchor" href="#对称算法封装"></a> 对称算法封装</h3>
<p>由evp_enc.c 实现，实现过程调用了具体对称算法函数，实现了Update 操作。各种对称算法都提供了一个EVP_CIPHER  静态结构，对应源码为e_xxx.c。需要注意的是，e_xxx.c  中不提供完整的加解密运算，它只提供基本的对于一个block_size数据的计算，完整的计算由evp_enc.c  来实现。</p>
<p>想实现一个自己的对称算法时，可以参考e_xxx.c 的实现方式。一般至少需要实现如下功能：</p>
<ul>
<li>构造一个新的静态的 EVP_CIPHER 结构；</li>
<li>实现 EVP_CIPHER 结构中的init 函数，该函数用于设置iv，设置加解密标记、以及根据外送密钥生成自己的内部密钥；</li>
<li>实现 do_cipher 函数，该函数仅对block_size 字节的数据进行对称运算；</li>
<li>实现 cleanup 函数，该函数主要用于清除内存中的密钥信息。</li>
</ul>
<h3 id="非对称算法封装"><a class="markdownIt-Anchor" href="#非对称算法封装"></a> 非对称算法封装</h3>
<p>主要是以 p_开头的文件。其中，p_enc.c 封装了公钥加密；p_dec.c 封装了私钥解密；p_lib.c  实现一些辅助函数；p_sign.c 封装了签名函数；p_verify.c 封装了验签函数；p_seal.c 封装了数字信封；p_open.c  封装了解数字信封。</p>
<h3 id="基于口令的加密"><a class="markdownIt-Anchor" href="#基于口令的加密"></a> 基于口令的加密</h3>
<p>包括 p5_crpt2.c、p5_crpt.c 和evp_pbe.c。</p>
<h2 id="主要函数"><a class="markdownIt-Anchor" href="#主要函数"></a> 主要函数</h2>
<h3 id="对称加解密函数"><a class="markdownIt-Anchor" href="#对称加解密函数"></a> 对称加解密函数</h3>
<ul>
<li>EVP_BytesToKey：计算密钥函数，它根据算法类型、摘要算法、salt 以及输入数据计算出一个对称密钥和初始化向量iv。</li>
<li>PKCS5_PBE_keyivgen 和PKCS5_v2_PBE_keyivgen：实现了 PKCS5 基于口令生成密钥和初始化向量的算法。</li>
<li>PKCS5_PBE_add：加载所有 openssl 实现的基于口令生成密钥的算法。</li>
<li>EVP_PBE_alg_add：添加一个 PBE 算法。</li>
</ul>
<h3 id="其他函数"><a class="markdownIt-Anchor" href="#其他函数"></a> 其他函数</h3>
<ul>
<li>EVP_add_cipher：将对称算法加入到全局变量，以供调用。</li>
<li>EVP_add_digest：将摘要算法加入到全局变量中，以供调用。</li>
<li>EVP_CIPHER_CTX_ctrl：对称算法控制函数，它调用了用户实现的ctrl 回调函数。</li>
<li>EVP_CIPHER_CTX_set_key_length：当对称算法密钥长度为可变长时，设置对称算法的密钥长度。</li>
<li>EVP_CIPHER_CTX_set_padding：设置对称算法的填充，对称算法有时候会涉及填充。加密分组长度大于一时，用户输入数据不是加密分组的整数倍时，会涉及到填充。填充在最后一个分组来完成，openssl 分组填充时，如果有n 个填充，则将最后一个分组用n 来填满。</li>
<li>EVP_CIPHER_get_asn1_iv：获取原始iv，存放在ASN1_TYPE 结构中。</li>
<li>EVP_CIPHER_param_to_asn1：设置对称算法参数，参数存放在ASN1_TYPE 类型中，它调用用户实现的回调函数set_asn1_parameters 来实现。</li>
<li>EVP_CIPHER_type：获取对称算法的类型。</li>
<li>EVP_CipherInit/EVP_CipherInit_ex：对称算法计算(加/解密)初始化函数，_ex 函数多了硬件enginge 参数，EVP_EncryptInit 和EVP_DecryptInit 函数也调用本函数。</li>
<li>EVP_CipherUpdate：对称计算（加/解密）函数，它调用了EVP_EncryptUpdate 和EVP_DecryptUpdate函数。</li>
<li>EVP_CipherFinal/EVP_CipherFinal_ex：对称计算( 加/ 解) 函数， 调用了EVP_EncryptFinal(ex) 和EVP_DecryptFinal(ex)；本函数主要用来处理最后加密分组，可能会有对称计算。</li>
<li>EVP_cleanup：清除加载的各种算法，包括对称算法、摘要算法以及PBE 算法，并清除这些算法相关的哈希表的内容。</li>
<li>EVP_get_cipherbyname：根据字串名字来获取一种对称算法(EVP_CIPHER)，本函数查询对称算法哈希表。</li>
<li>EVP_get_digestbyname：根据字串获取摘要算法(EVP_MD)，本函数查询摘要算法哈希表。</li>
<li>EVP_get_pw_prompt：获取口令提示信息字符串.</li>
<li>int EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen,<br />
ASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de)：PBE 初始化函数。本函数用口令生成对称算法的密钥和初始化向量，并作加/解密初始化操作。本函数再加上后续的EVP_CipherUpdate 以及EVP_CipherFinal_ex构成一个完整的加密过程（可参考crypto/p12_decr.c 的PKCS12_pbe_crypt 函数）.</li>
<li>EVP_PBE_cleanup：删除所有的PBE 信息，释放全局堆栈中的信息.</li>
<li>EVP_PKEY *EVP_PKCS82PKEY(PKCS8_PRIV_KEY_INFO *p8)：将PKCS8_PRIV_KEY_INFO(x509.h 中定义)中保存的私钥转换为EVP_PKEY结构。</li>
<li>EVP_PKEY2PKCS8/EVP_PKEY2PKCS8_broken：将EVP_PKEY 结构中的私钥转换为PKCS8_PRIV_KEY_INFO 数据结构存储。</li>
<li>EVP_PKEY_bits：非对称密钥大小，为比特数。</li>
<li>EVP_PKEY_cmp_parameters：比较非对称密钥的密钥参数，用于DSA 和ECC 密钥。</li>
<li>EVP_PKEY_copy_parameters：拷贝非对称密钥的密钥参数，用于DSA 和ECC 密钥。</li>
<li>EVP_PKEY_free：释放非对称密钥数据结构。</li>
<li>EVP_PKEY_get1_DH/EVP_PKEY_set1_DH：获取/设置EVP_PKEY 中的DH 密钥。</li>
<li>EVP_PKEY_get1_DSA/EVP_PKEY_set1_DSA：获取/设置EVP_PKEY 中的DSA 密钥。</li>
<li>EVP_PKEY_get1_RSA/EVP_PKEY_set1_RSA：获取/设置EVP_PKEY 中结构中的RSA 结构密钥。</li>
<li>EVP_PKEY_missing_parameters：检查非对称密钥参数是否齐全，用于DSA 和ECC 密钥。</li>
<li>EVP_PKEY_new：生成一个EVP_PKEY 结构。</li>
<li>EVP_PKEY_size：获取非对称密钥的字节大小。</li>
<li>EVP_PKEY_type：获取EVP_PKEY 中表示的非对称密钥的类型。</li>
<li>int EVP_read_pw_string(char *buf,int length,const char *prompt,int verify)：获取用户输入的口令；buf 用来存放用户输入的口令，length 为buf 长度，prompt为提示给用户的信息，如果为空，它采用内置的提示信息，verify 为0 时，不要求验证用户输入的口令，否则回要求用户输入两遍。返回0 表示成功。</li>
<li>EVP_set_pw_prompt：设置内置的提示信息，用于需要用户输入口令的场合。</li>
</ul>
<h2 id="对称加密"><a class="markdownIt-Anchor" href="#对称加密"></a> 对称加密</h2>
<h3 id="基本数据结构"><a class="markdownIt-Anchor" href="#基本数据结构"></a> 基本数据结构</h3>
<p>EVP_CIPHER与EVP_CIPHER_CTX两个基本结构，加密函数EVP_Encrypt(EVP_Cipher)一些列函数都是以这两个结构为基础实现了。文件evp_enc.c是最高层的封装实现，，而各个e_*.c文件则是真正实现了各种算法的加解密功能，当然它们其实也是一些封装函数，真正的算法实现在各个算法同名目录里面的文件实现。</p>
<p>注意:  EVP_CIPHER是、EVP_CIPHER_CTX的成员，在加密时通过指定的加密算法（其实就是加密函数），返回对应的EVP_CIPHER的指针，然后EVP_EncryptInit函数中 调用 EVP_CIPHER来初化EVP_CIPHER_CTX。</p>
<h4 id="evp_cipher结构体"><a class="markdownIt-Anchor" href="#evp_cipher结构体"></a> EVP_CIPHER结构体</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">evp_cipher_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nid; <span class="comment">//是算法类型的nid识别号，openssl里面每个对象都有一个内部唯一的识别ID</span></span><br><span class="line">    <span class="keyword">int</span> block_size;        <span class="comment">//是每次加密的数据块的长度，以字节为单位</span></span><br><span class="line">    <span class="keyword">int</span> key_len;           <span class="comment">//是每次加密的数据块的长度，以字节为单位</span></span><br><span class="line">    <span class="keyword">int</span> iv_len;            <span class="comment">//初始化向量的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;   <span class="comment">//标志位</span></span><br><span class="line">    <span class="keyword">int</span> (*init)(EVP_CIPHER_CTX *ctx, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv, <span class="keyword">int</span> enc); <span class="comment">//算法结构初始化函数，可以设置为加密模式还是解密模式</span></span><br><span class="line">    <span class="keyword">int</span> (*do_cipher)(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">unsigned</span> <span class="keyword">int</span> inl);   <span class="comment">//进行数据加密或解密的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*cleanup)(EVP_CIPHER_CTX *);   <span class="comment">//释放EVP_CIPHER_CTX结构里面的数据和设置</span></span><br><span class="line">    <span class="keyword">int</span> ctx_size;  <span class="comment">//设定ctx-&gt;cipher_data数据的长度</span></span><br><span class="line">    <span class="keyword">int</span> (*set_asn1_parameters)(EVP_CIPHER_CTX *, ASN1_TYPE *);  <span class="comment">// 在EVP_CIPHER_CTX结构中通过参数设置一个ASN1_TYPE</span></span><br><span class="line">    <span class="keyword">int</span> (*get_asn1_parameters)(EVP_CIPHER_CTX *, ASN1_TYPE *);  <span class="comment">//从一个ASN1_TYPE中取得参数</span></span><br><span class="line">    <span class="keyword">int</span> (*ctrl)(EVP_CIPHER_CTX *, <span class="keyword">int</span> type, <span class="keyword">int</span> arg, <span class="keyword">void</span> *ptr); <span class="comment">//其它各种操作函数</span></span><br><span class="line">    <span class="keyword">void</span> *app_data;  <span class="comment">//应用数据</span></span><br><span class="line">&#125;EVP_CIPHER;</span><br></pre></td></tr></table></figure>
<h4 id="evp_cipher_ctx结构体"><a class="markdownIt-Anchor" href="#evp_cipher_ctx结构体"></a> EVP_CIPHER_CTX结构体</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">evp_cipher_ctx_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> EVP_CIPHER *cipher;  <span class="comment">//是该结构相关的一个EVP_CIPHER算法结构</span></span><br><span class="line">    ENGINE *engine;            <span class="comment">//如果加密算法是ENGINE提供的，那么该成员保存了相关的函数接口</span></span><br><span class="line">    <span class="keyword">int</span> encrypt;               <span class="comment">//加密或解密的标志</span></span><br><span class="line">    <span class="keyword">int</span> buf_len;               <span class="comment">//该结构缓冲区里面当前的数据长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> oiv[EVP_MAX_IV_LENGTH];      <span class="comment">//初始的初始化向量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> iv[EVP_MAX_IV_LENGTH];       <span class="comment">//工作时候使用的初始化向量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[EVP_MAX_BLOCK_LENGTH];   <span class="comment">//保存下来的部分需要数据</span></span><br><span class="line">    <span class="keyword">int</span> num;                   <span class="comment">//在cfb/ofb模式的时候指定块长度</span></span><br><span class="line">    <span class="keyword">void</span> *app_data;            <span class="comment">//应用程序要处理数据</span></span><br><span class="line">    <span class="keyword">int</span> key_len;               <span class="comment">//密钥长度，算法不一样长度也不一样</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags; </span><br><span class="line">    <span class="keyword">void</span> *cipher_data;         <span class="comment">//加密后的数据</span></span><br><span class="line">    <span class="keyword">int</span> final_used;</span><br><span class="line">    <span class="keyword">int</span> block_mask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">final</span>[EVP_MAX_BLOCK_LENGTH];<span class="comment">//</span></span><br><span class="line">&#125; EVP_CIPHER_CTX;</span><br></pre></td></tr></table></figure>
<h3 id="相关函数"><a class="markdownIt-Anchor" href="#相关函数"></a> 相关函数</h3>
<h4 id="核心函数"><a class="markdownIt-Anchor" href="#核心函数"></a> 核心函数</h4>
<p>EVP_crypt系列函数只是对EVP_Cipher系列函数的调用，EVP_Encrypt函数相当于对EVP_Cipher函数enc参数置为1，EVP_Decrypt函数相当于对EVP_Cipher函数enc参数置为0。</p>
<h5 id="底层函数"><a class="markdownIt-Anchor" href="#底层函数"></a> 底层函数</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旧版本</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CipherInit</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">const</span> EVP_CIPHER *cipher, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv, <span class="keyword">int</span> enc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CipherUpdate</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl,<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CipherFinal</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl)</span></span></span><br><span class="line"><span class="function"><span class="comment">//新版本</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CipherInit_ex</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">const</span> EVP_CIPHER *cipher, </span></span></span><br><span class="line"><span class="function"><span class="params">ENGINE *impl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key,<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv, <span class="keyword">int</span> enc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CipherUpdate</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CipherFinal_ex</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl)</span></span></span><br></pre></td></tr></table></figure>
<p>这三个函数是更底层的函数。完成了数据的加密和解密功能。他们根据参数enc决定执行加密还是解密操作，如果enc为1，则加密；如果enc为0，则解密；如果enc是－1，则不改变数据。<strong>函数都是操作成功返回1，否则返回0。</strong></p>
<p><strong>注意</strong>：两个版本中：EVP_EncryptInit, EVP_DecryptInit和EVP_CipherInit，这三个函数的功能分别跟函数EVP_EncryptInit_ex, EVP_DecryptInit_ex和EVP_CipherInit_ex功能相同，只是他们的ctx参数不需要进行初始化，并且使用缺省的算法库。EVP_EncryptFinal,  EVP_DecryptFinal和EVP_CipherFinal，这三个函数分别跟函数EVP_EncryptFinal_ex,EVP_DecryptFinal_ex以及EVP_CipherFinal_ex函数功能相同，不过，他们的参数ctx会在调用后自动释放。</p>
<h5 id="加密"><a class="markdownIt-Anchor" href="#加密"></a> 加密</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旧版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_EncryptInit</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">const</span> EVP_CIPHER *cipher, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_EncryptUpdate</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl,<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_EncryptFinal</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl)</span></span></span><br><span class="line"><span class="function"><span class="comment">//新版本</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_EncryptInit_ex</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">const</span> EVP_CIPHER *cipher, ENGINE *impl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key,<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv)</span> <span class="comment">//采用ENGINE参数impl的算法来设置并初始化加密结构体。其中ctx参数必须在调用之前被初始化完毕。如果参数impl为NULL，那么就会使用缺省的实现算法。参数key是用来加密的对称密钥，iv参数是初始化向量（如果需要的话）。在算法中真正使用的密钥长度和初始化密钥长度是根据算法来决定的（也就是传入的key或者iv长度可以是任意的，实际使用的数据取决于算法，不足会自动补上，超过会自动舍去）。在调用该函数进行初始化的时候，除了参数cipher之外，所有其它参数可以设置为NULL，留到以后调用其它函数的时候再提供</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_EncryptUpdate</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span> <span class="comment">//该函数执行对数据的加密。该函数加密从参数in输入的长度为inl的数据，并将加密好的数据写入到参数out里面去。可以通过反复调用该函数来处理一个连续的数据块</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_EncryptFinal_ex</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl)</span> <span class="comment">//该函数处理最后（Final）的一段数据。在函数在padding功能打开的时候（缺省）才有效，这时候它将剩余的最后的所有数据进行加密处理。该算法使用标志的块padding方式（AKA PKCS padding）， PKCS 填充（padding）标准是这样定义的，在被加密的数据后面加上n个值为n的字节，使得加密后的数据长度为加密块长度的整数倍。</span></span></span><br></pre></td></tr></table></figure>
<h5 id="解密"><a class="markdownIt-Anchor" href="#解密"></a> 解密</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旧版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DecryptInit</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">const</span> EVP_CIPHER *cipher, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DecryptUpdate</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DecryptFinal</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl)</span></span></span><br><span class="line"><span class="function"><span class="comment">//新版本</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DecryptInit_ex</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">const</span> EVP_CIPHER *cipher,</span></span></span><br><span class="line"><span class="function"><span class="params">ENGINE *impl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key， <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv)</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DecryptUpdate</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span>                    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DecryptFinal_ex</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl)</span></span></span><br></pre></td></tr></table></figure>
<p>上面这些函数对应于上一节中的加密函数，函数的参数要求与相应的加密函数相同。</p>
<h4 id="辅助函数"><a class="markdownIt-Anchor" href="#辅助函数"></a> 辅助函数</h4>
<h5 id="操作evp_cipher_ctx的函数"><a class="markdownIt-Anchor" href="#操作evp_cipher_ctx的函数"></a> 操作EVP_CIPHER_CTX的函数</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CIPHER_CTX_reset</span><span class="params">(EVP_CIPHER_CTX *c)</span>    <span class="comment">//重置EVP_CIPHER_CTX</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">EVP_CIPHER_CTX *<span class="title">EVP_CIPHER_CTX_new</span><span class="params">(<span class="keyword">void</span>)</span>       <span class="comment">//开辟EVP_CIPHER_CTX</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_CIPHER_CTX_free</span><span class="params">(EVP_CIPHER_CTX *ctx)</span>  <span class="comment">//销毁之前开辟的EVP_CIPHER_CTX</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_CIPHER_CTX_init</span><span class="params">(EVP_CIPHER_CTX *a)</span></span>; <span class="comment">//初始化一个EVP_CIPHER_CTX结构体   </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CIPHER_CTX_cleanup</span><span class="params">(EVP_CIPHER_CTX *a)</span></span>; <span class="comment">//清除一个EVP_CIPHER_CTX结构体中的所有信息，并释放该结构占用的所有内存</span></span><br></pre></td></tr></table></figure>
<h5 id="参数设置与获取"><a class="markdownIt-Anchor" href="#参数设置与获取"></a> 参数设置与获取</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_MAX_IV_LENGTH 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_MAX_BOLCK_LENGTH 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_MAX_KEY_LENGTH 64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_partially_overlapping</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr1, <span class="keyword">const</span> <span class="keyword">void</span> *ptr2, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CIPHER_CTX_set_padding</span><span class="params">(EVP_CIPHER_CTX *x, <span class="keyword">int</span> padding)</span></span>; <span class="comment">//设置是否采用填充功能，默认使用。将padding设置为0代表禁止</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CIPHER_CTX_set_key_length</span><span class="params">(EVP_CIPHER_CTX *x, <span class="keyword">int</span> keylen)</span></span>; <span class="comment">//设置EVP_CIPHER_CTX密钥长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CIPHER_CTX_ctrl</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">int</span> type, <span class="keyword">int</span> arg, <span class="keyword">void</span> *ptr)</span></span>; <span class="comment">//设置不同算法特定的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*这三个函数都根据给定的参数返回一个EVP_CIPHER结构。不同的是给定的参数分别是算法名称、算法的NID和一个ASN1_OBJECT结构。具体的算法名称、NID以及ASN1_OBJECT结构请参看object/object.h文件的定义。成功返回对应的EVP_CIPHER* ，失败返回NULL*/</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_CIPHER *<span class="title">EVP_get_cipherbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_get_cipherbynid(a) EVP_get_cipherbyname(OBJ_nid2sn(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_get_cipherbyobj(a) EVP_get_cipherbynid(OBJ_obj2nid(a))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面这组函数的参数为EVP_CIPHER类型变量*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_nid(e)              ((e)-&gt;nid) <span class="comment">//返回加密算法的nid</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_block_size(e)       ((e)-&gt;block_size) <span class="comment">//返回加密块长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_key_length(e)       ((e)-&gt;key_len) <span class="comment">//返回密钥长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_iv_length(e)        ((e)-&gt;iv_len) <span class="comment">//返回初始化向量长度，如果没有使用IV则返回0</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_flags(e)            ((e)-&gt;flags) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_mode(e)             ((e)-&gt;flags) &amp; EVP_CIPH_MODE) <span class="comment">//返回相应结构算法的加密模式</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CIPHER_type</span><span class="params">(<span class="keyword">const</span> EVP_CIPHER *ctx)</span></span>; <span class="comment">//返回算法类型，返回值为算法的NID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面这组函数的返回值与EVP_CIPHER*系列函数的返回值相同，只是函数参数为EVP_CIPHER_CTX类型变量*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_CTX_cipher(e)       ((e)-&gt;cipher) <span class="comment">//返回EVP_CIPHER_CTX结构里面的EVP_CIPHER结构</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_CTX_nid(e)          ((e)-&gt;cipher-&gt;nid) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_CTX_block_size(e)   ((e)-&gt;cipher-&gt;block_size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_CTX_key_length(e)   ((e)-&gt;key_len)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_CTX_iv_length(e)    ((e)-&gt;cipher-&gt;iv_len)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_CTX_get_app_data(e) ((e)-&gt;app_data)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_CTX_set_app_data(e,d) ((e)-&gt;app_data=(char *)(d))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_CTX_type(c)         EVP_CIPHER_type(EVP_CIPHER_CTX_cipher(c)) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_CTX_flags(e)        ((e)-&gt;cipher-&gt;flags)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_CIPHER_CTX_mode(e)         ((e)-&gt;cipher-&gt;flags &amp; EVP_CIPH_MODE)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CIPHER_param_to_asn1</span><span class="params">(EVP_CIPHER_CTX *c, ASN1_TYPE *type)</span></span>; <span class="comment">//设置算法结构的参数，该函数必须在所设置的算法结构使用之前调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_CIPHER_asn1_to_param</span><span class="params">(EVP_CIPHER_CTX *c, ASN1_TYPE *type)</span></span>; <span class="comment">//用算法结构里面的值设置参数type的结构，其设置的内容由具体的算法决定。本函数应该在算法结构的基本算法类型已经设置了但是密钥还没有设置之前调用</span></span><br></pre></td></tr></table></figure>
<h4 id="算法函数"><a class="markdownIt-Anchor" href="#算法函数"></a> 算法函数</h4>
<p>openssl对称加密算法的格式都以函数形式提供，其实该函数返回一个该算法的结构体，其形式一般如下(evp.h 、e_···.c)：<br />
     <code>EVP_CIPHER* EVP_···(···代表加密算法的名称)(void)</code><br />
在openssl中，所有提供的对称加密算法长度都是固定的，有特别说明的除外。</p>
<h5 id="分组加密的迭代模式"><a class="markdownIt-Anchor" href="#分组加密的迭代模式"></a> 分组加密的迭代模式</h5>
<ul>
<li>ecb—电子密码本（Electronic Code Book)加密方式</li>
<li>cbc—加密块链接（Cipher Block Chaining）加密方式</li>
<li>cfb——加密反馈（Cipher Feedback）加密方式</li>
<li>ofb—输出反馈（Output Feedback）加密方式</li>
<li>ede—该加密算法采用了加密、解密、加密的方式，第一个密钥和最后一个密钥是相同的</li>
<li>ede3—该加密算法采用了加密、解密、加密的方式，但是三个密钥都不相同</li>
</ul>
<h5 id="加密算法"><a class="markdownIt-Anchor" href="#加密算法"></a> 加密算法</h5>
<p><strong>注意：下面这些加密算法函数调用时返回的都是对应EVP_CIPHER结构体指针</strong></p>
<ul>
<li>NULL算法：EVP_enc_null()，该算法不作任何事情，也就是没有进行加密处理</li>
<li>DES算法：EVP_des_cbc(void), EVP_des_ecb(void), EVP_des_cfb(void), EVP_des_ofb(void)</li>
<li>使用两个密钥的3DES算法：EVP_des_ede_cbc(void), EVP_des_ede(void), EVP_des_ede_ofb(void),EVP_des_ede_cfb(void)</li>
<li>使用三个密钥的3DES算法：EVP_des_ede3_cbc(void), EVP_des_ede3(void), EVP_des_ede3_ofb(void), EVP_des_ede3_cfb(void)</li>
<li>DESX算法：EVP_desx_cbc(void)</li>
<li>RC2算法：EVP_rc2_cbc(void), EVP_rc2_ecb(void), EVP_rc2_cfb(void), EVP_rc2_ofb(void) ，该算法密钥长度可变，缺省为128位</li>
<li>定长的RC2算法：EVP_rc2_40_cbc(void), EVP_rc2_64_cbc(void)</li>
<li>RC4算法：EVP_rc4(void) ，密钥长度可变，默认为128位</li>
<li>定长的RC4算法：EVP_rc4_40(void) ，密钥长度为40位</li>
<li>RC5算法：EVP_rc5_32_12_16_cbc(void), EVP_rc5_32_12_16_ecb(void), EVP_rc5_32_12_16_cfb(void), EVP_rc5_32_12_16_ofb(void)，密钥长度可以设置，默认128位。由于RC5算法本身实现代码的限制，加密次数只能设置为8、12或16。</li>
<li>IDEA算法：EVP_idea_cbc(void)，EVP_idea_ecb(void), EVP_idea_cfb(void), EVP_idea_ofb(void)</li>
<li>Blowfish算法：EVP_bf_cbc(void), EVP_bf_ecb(void), EVP_bf_cfb(void), EVP_bf_ofb(void)，密钥长度可变</li>
<li>CAST算法：EVP_cast5_cbc(void), EVP_cast5_ecb(void), EVP_cast5_cfb(void), EVP_cast5_ofb(void)，密钥长度可变</li>
<li>AES算法：
<ul>
<li>128位：EVP_aes_128_ecb(void)，EVP_aes_128_cbc(void)，PEVP_aes_128_cfb(void)，EVP_aes_128_ofb(void)</li>
<li>192位：EVP_aes_192_ecb(void)，EVP_aes_192_cbc(void)，PEVP_aes_192_cfb(void)，EVP_aes_192_ofb(void)</li>
<li>256位：EVP_aes_256_ecb(void)，EVP_aes_256_cbc(void)，PEVP_aes_256_cfb(void)，EVP_aes_256_ofb(void)</li>
</ul>
</li>
</ul>
<h3 id="应用流程"><a class="markdownIt-Anchor" href="#应用流程"></a> 应用流程</h3>
<p>一般来说，EVP_Encrypt…系列函数的应用流程如下所描述(不失一般性，以加密算法3DES为例)：</p>
<ol>
<li>
<p>定义一些所需的变量</p>
<p>一般情况下，输出数据缓冲区大小应该大于输入数据缓冲区。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> key[EVP_MAX_KEY_LENGTH];</span><br><span class="line"><span class="keyword">char</span> iv[EVP_MAX_IV_LENGTH];</span><br><span class="line">EVP_CIPHER_CTX ctx;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> out[<span class="number">512</span>+<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> outl;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>给变量key和IV赋值</p>
<p>可以借助函数<code>EVP_BytesToKey</code>来进行，如果有别的方法设定key和IV则该函数调用不是必须的</p>
</li>
<li>
<p>初始化加密算法结构EVP_CIPHER_CTX</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVP_EncryptInit_ex(&amp;ctx, EVP_des_ede3_cbc(), <span class="literal">NULL</span>, key, iv);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>进行数据加密操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (....)</span><br><span class="line">&#123;</span><br><span class="line">	EVP_EncryptUpdate(ctx,out,&amp;outl,in,inl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：EVP库的EVP_*Update系列函数调用一次就能处理完指针in中的inl个字节数据。<strong>这里所谓的循环是用于此类情景：每次收到若干字节放入指针in指向的缓冲区中，然后对其处理；或者每次从文件中读取若干字节到指针in所指缓冲区，再对其处理。<strong>如果输入的数据不是整数倍，则会留到EVP_*_CTX 中，等待下一次Update或EVP_Final*来处理</strong>，也就是</strong>循环是用于无法一次传入所有数据的情况</strong>，其他情况不需要使用循环。</p>
</li>
<li>
<p>结束加密，输出最后一段数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVP_EncryptFinal_ex(&amp;ctx, out, &amp;outl)</span><br></pre></td></tr></table></figure>
<p>该函数会进行加密检测，如果加密过程有误会被检测出来</p>
</li>
</ol>
<p>说明：解密过程与上述过程类似，只是要使用EVP_Decrypt···系列函数</p>
<h3 id="程序示例"><a class="markdownIt-Anchor" href="#程序示例"></a> 程序示例</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/conf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleErrors</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ERR_print_errors_fp(<span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">encrypt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* plaintext, <span class="keyword">int</span> plaintext_len, <span class="keyword">unsigned</span> <span class="keyword">char</span>* key, <span class="keyword">unsigned</span> <span class="keyword">char</span>* iv, <span class="keyword">unsigned</span> <span class="keyword">char</span>* ciphertext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        EVP_CIPHER_CTX* ctx;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">int</span> ciphertext_len;</span><br><span class="line">        <span class="keyword">if</span>(!(ctx=EVP_CIPHER_CTX_new()))</span><br><span class="line">                handleErrors();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>!=EVP_EncryptInit_ex(ctx,EVP_aes_256_cbc(),<span class="literal">NULL</span>,key,iv))</span><br><span class="line">                handleErrors();</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>!=EVP_EncryptUpdate(ctx,ciphertext,&amp;len,plaintext,plaintext_len))</span><br><span class="line">                handleErrors();</span><br><span class="line">        ciphertext_len=len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>!=EVP_EncryptFinal_ex(ctx,ciphertext+len,&amp;len))</span><br><span class="line">                handleErrors();</span><br><span class="line">        ciphertext_len+=len;</span><br><span class="line"></span><br><span class="line">        EVP_CIPHER_CTX_free(ctx);</span><br><span class="line">        <span class="keyword">return</span> ciphertext_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decrypt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* ciphertext, <span class="keyword">int</span> ciphertext_len, <span class="keyword">unsigned</span> <span class="keyword">char</span>* key, <span class="keyword">unsigned</span> <span class="keyword">char</span>* iv, <span class="keyword">unsigned</span> <span class="keyword">char</span>* plainte</span></span></span><br><span class="line"><span class="function"><span class="params">xt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        EVP_CIPHER_CTX* ctx;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">int</span> plaintext_len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!(ctx=EVP_CIPHER_CTX_new()))</span><br><span class="line">                handleErrors();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>!=EVP_DecryptInit_ex(ctx,EVP_aes_256_cbc(),<span class="literal">NULL</span>,key,iv))</span><br><span class="line">                handleErrors();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>!=EVP_DecryptUpdate(ctx,plaintext,&amp;len,ciphertext,ciphertext_len))</span><br><span class="line">                handleErrors();</span><br><span class="line">        plaintext_len=len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>!=EVP_DecryptFinal_ex(ctx,plaintext+len,&amp;len))</span><br><span class="line">                handleErrors();</span><br><span class="line">        plaintext_len+=len;</span><br><span class="line"></span><br><span class="line">        EVP_CIPHER_CTX_free(ctx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> plaintext_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>* key=(<span class="keyword">unsigned</span> <span class="keyword">char</span>*) <span class="string">&quot;01234567890123456789012345678901&quot;</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>* iv=(<span class="keyword">unsigned</span> <span class="keyword">char</span>*) <span class="string">&quot;0123456789012345&quot;</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>* plaintext=(<span class="keyword">unsigned</span> <span class="keyword">char</span>*) <span class="string">&quot;Hello OpenSSL! This a demonstration program about how to use EVP&quot;</span>; <span class="comment">//cbc模式下试着修改某一个字符，则会出现雪崩效应，密文出现很大差别；但是ofb和cfb却不会。（与这三种方式的计算顺序有关）</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> ciphertext[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> decryptedtext[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span> decryptedtext_len, ciphertext_len;</span><br><span class="line">        ciphertext_len=encrypt(plaintext,<span class="built_in">strlen</span>((<span class="keyword">char</span>*)plaintext),key,iv,ciphertext);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The ciphertext is:\n&quot;</span>);</span><br><span class="line">        BIO_dump_fp(<span class="built_in">stdout</span>,(<span class="keyword">const</span> <span class="keyword">char</span>*)ciphertext,ciphertext_len);</span><br><span class="line">        decryptedtext_len=decrypt(ciphertext,ciphertext_len,key,iv,decryptedtext);</span><br><span class="line">        decryptedtext[decryptedtext_len]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Decrypted text is:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,decryptedtext);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要用认证加密（防止CCA攻击），可以参考https://wiki.openssl.org/index.php/EVP_Authenticated_Encryption_and_Decryption</p>
<h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2>
<p>该系列函数封装了openssl加密库所有的信息摘要算法，通过这种EVP封装，当使用不同的信息摘要算法时，只需要对初始化参数修改一下就可以了，其它代码可以完全一样。这些算法包括MD2、MD5以及SHA等算法。</p>
<ul>
<li>函数名称：EVP_Digest*…*</li>
<li>功能描述：该系列函数封装实现了多种信息摘要算法。</li>
<li>相关文件：digest.c,m_*.c</li>
</ul>
<h3 id="基本数据结构-2"><a class="markdownIt-Anchor" href="#基本数据结构-2"></a> 基本数据结构</h3>
<h4 id="evp_md结构体"><a class="markdownIt-Anchor" href="#evp_md结构体"></a> EVP_MD结构体</h4>
<p>所有的摘要算法都维护着指向下面定义的结构体的一个指针，在此基础上实现了算法的功能。该结构EVP_MD的源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opessl/evp.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">env_md_st</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> type;     <span class="comment">//信息摘要算法的NID标识</span></span><br><span class="line">    <span class="keyword">int</span> pkey_type;<span class="comment">//是信息摘要-签名算法体制的相应NID标识，如NID_shaWithRSAEncryption</span></span><br><span class="line">    <span class="keyword">int</span> md_size;  <span class="comment">//是信息摘要算法生成的信息摘要的长度，如SHA算法是SHA_DIGEST_LENGTH，该值是20</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">int</span> (*init)(EVP_MD_CTX *ctx); <span class="comment">//指向一个特定信息摘要算法的初始化函数，如对于SHA算法，指针指向SHA_Init</span></span><br><span class="line">    <span class="keyword">int</span> (*update)(EVP_MD_CTX *ctx,<span class="keyword">const</span> <span class="keyword">void</span> *data,<span class="keyword">unsigned</span> <span class="keyword">long</span> count); <span class="comment">//指向一个真正计算摘要值的函数，例如SHA算法就是指向SHA_Update</span></span><br><span class="line">    <span class="keyword">int</span> (*<span class="keyword">final</span>)(EVP_MD_CTX *ctx,<span class="keyword">unsigned</span> <span class="keyword">char</span> *md); <span class="comment">//指向一个信息摘要值计算之后要调用的函数，该函数完成最后的一块数据的处理工作。例如SHA算法就是指向SHA_Final.</span></span><br><span class="line">    <span class="keyword">int</span> (*copy)(EVP_MD_CTX *to,<span class="keyword">const</span> EVP_MD_CTX *from); <span class="comment">//指向一个可以在两个EVP_MD_CTX结构之间拷贝参数值的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*cleanup)(EVP_MD_CTX *ctx);</span><br><span class="line">    <span class="keyword">int</span> (*sign)();   <span class="comment">//签名</span></span><br><span class="line">    <span class="keyword">int</span> (*verify)(); <span class="comment">//认证</span></span><br><span class="line">    <span class="keyword">int</span> required_pkey_type[<span class="number">5</span>]; <span class="comment">//指向一个用来签名的算法EVP_PKEY的类型，如SHA算法就指向EVP_PKEY_RSA_method</span></span><br><span class="line">    <span class="keyword">int</span> block_size;  <span class="comment">//一个用来进行信息摘要的输入块的的长度（单位是字节），如SHA算法就是SHA_CBLOCK</span></span><br><span class="line">    <span class="keyword">int</span> ctx_size;    <span class="comment">//是CTX结构的长度，在SHA算法里面应该就是sizeof(EVP_MD*)+sizeof(SHA_CTX)</span></span><br><span class="line">&#125; EVP_MD;</span><br></pre></td></tr></table></figure>
<p>如果要增加新的算法，那么可以定义这个结构，并进行必要的移植，然后就可以使用通用的函数了。</p>
<h4 id="evp_md_ctx结构体"><a class="markdownIt-Anchor" href="#evp_md_ctx结构体"></a> EVP_MD_CTX结构体</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">env_md_ctx_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> EVP_MD *digest;  <span class="comment">//digest——指向上面介绍的EVP_MD结构的指针</span></span><br><span class="line">    ENGINE *engine;        <span class="comment">//如果算法由ENGINE提供，该指针指向该ENGINE</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;   <span class="comment">//</span></span><br><span class="line">    <span class="keyword">void</span> *md_data;         <span class="comment">//信息摘要数据</span></span><br><span class="line">&#125;EVP_MD_CTX ;</span><br></pre></td></tr></table></figure>
<h3 id="相关函数-2"><a class="markdownIt-Anchor" href="#相关函数-2"></a> 相关函数</h3>
<h4 id="核心函数-2"><a class="markdownIt-Anchor" href="#核心函数-2"></a> 核心函数</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旧版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DigestInit</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">const</span> EVP_MD *type)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DigestUpdate</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DigestFinal</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *md, <span class="keyword">unsigned</span> <span class="keyword">int</span> *size)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//新版本</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DigestInit_ex</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">const</span> EVP_MD *type, ENGINE *impl)</span> <span class="comment">//使用参数impl所指向的ENGINE设置该信息摘要结构体，参数ctx在调用本函数之前必须经过初始化。参数type一般是使用像EVP_sha1这样的函数的返回值。如果impl为NULL，那么就会使用缺省实现的信息摘要函数，大多数应用程序里面impl是设置为NULL的。操作成功返回1，否则返回0。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DigestUpdate</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> count)</span> <span class="comment">//将参数d中的cnt字节数据进行信息摘要到ctx结构中去，该函数可以被调用多次，用以对更多的数据进行信息摘要。操作成功返回1，否则返回0。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DigestFinal_ex</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *md, <span class="keyword">unsigned</span> <span class="keyword">int</span> *size)</span> <span class="comment">//将ctx结构中的摘要信息数据返回到参数md中，如果参数size不是NULL，那么摘要数据的长度（字节）就会被写入到参数size中，大多数情况下写入的值是EVP_MAX_MD_SIZE。在调用本函数后，不能使用相同的ctx结构调用EVP_DigestUpdate再进行数据的信息摘要操作,但是如果调用EVP_DigestInit_ex函数重新初始化后可以进行新的信息摘要操作。操作成功返回1，否则返回0。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//高级版本</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_Digest</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> count, <span class="keyword">unsigned</span> <span class="keyword">char</span> *md, <span class="keyword">unsigned</span> <span class="keyword">int</span> *size, <span class="keyword">const</span> EVP_MD *type,ENGINE *impl)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="辅助函数-2"><a class="markdownIt-Anchor" href="#辅助函数-2"></a> 辅助函数</h4>
<h5 id="操作evp_md_ctx的函数"><a class="markdownIt-Anchor" href="#操作evp_md_ctx的函数"></a> 操作EVP_MD_CTX的函数</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_MD_CTX_reset</span><span class="params">(EVP_MD_CTX *ctx)</span></span></span><br><span class="line"><span class="function">EVP_MD_CTX *<span class="title">EVP_MD_CTX_new</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_MD_CTX_free</span><span class="params">(EVP_MD_CTX *ctx)</span></span></span><br><span class="line"><span class="function">EVP_MD_CTX *<span class="title">EVP_MD_CTX_create</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//创建一个EVP_MD_CTX结构，分配内存并进行初始化，返回该结构</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_MD_CTX_destroy</span><span class="params">(EVP_MD_CTX *ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_MD_CTX_init</span><span class="params">(EVP_MD_CTX *ctx)</span></span>; <span class="comment">//初始化一个EVP_MD_CTX结构</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">EVP_MD_CTX_cleanup</span><span class="params">(EVP_MD_CTX *ctx)</span></span>; <span class="comment">//清除一个EVP_MD_CTX结构，应该在不再需要使用之后再清除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">EVP_MD_CTX_copy</span><span class="params">(EVP_MD_CTX *out, <span class="keyword">const</span> EVP_MD_CTX *in)</span> <span class="comment">//与下面的函数作用相同，但是out不用初始化</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">EVP_MD_CTX_copy_ex</span><span class="params">(EVP_MD_CTX *out, <span class="keyword">const</span> EVP_MD_CTX *in)</span> <span class="comment">//将信息摘要数据从in结构拷贝到out结构中，out必须在调用之前被初始化</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">EVP_MD_CTX_ctrl</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">int</span> cmd, <span class="keyword">int</span> p1, <span class="keyword">void</span> *p2)</span></span></span><br></pre></td></tr></table></figure>
<h5 id="参数设置与获取函数"><a class="markdownIt-Anchor" href="#参数设置与获取函数"></a> 参数设置与获取函数</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_MAX_MD_SIZE 64     <span class="comment">/* SHA512 */</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_MD_type</span><span class="params">(<span class="keyword">const</span> EVP_MD *md)</span></span>; <span class="comment">//返回信息摘要结构算法的NID</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_MD_pkey_type</span><span class="params">(<span class="keyword">const</span> EVP_MD *md)</span></span>; <span class="comment">//返回信息摘要结构中公钥签名算法的NID</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_MD_size</span><span class="params">(<span class="keyword">const</span> EVP_MD *md)</span></span>; <span class="comment">//返回结构里面摘要信息的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_MD_block_size</span><span class="params">(<span class="keyword">const</span> EVP_MD *md)</span></span>; <span class="comment">//返回摘要信息分块的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_MD_CTX_md</span><span class="params">(<span class="keyword">const</span> EVP_MD_CTX *ctx)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_MD_CTX_size(e)        EVP_MD_size(EVP_MD_CTX_md(e)) <span class="comment">//返回结构里面摘要信息的长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_MD_CTX_block_size(e)  EVP_MD_block_size((e)-&gt;digest) <span class="comment">//返回摘要信息分块的长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_MD_CTX_type(e)        EVP_MD_type((e)-&gt;digest) <span class="comment">//返回信息摘要结构算法的NID</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_get_digestbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; <span class="comment">//根据给定算法名称返回一个EVP_MD结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_get_digestbynid(a) EVP_get_digestbyname(OBJ_nid2sn(a)) <span class="comment">//根据算法的NID返回一个EVP_MD结构</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_get_digestbyobj(a) EVP_get_digestbynid(OBJ_obj2nid(a)) <span class="comment">//根据算法的ASN1_OBJECT结构返回一个EVP_MD结构</span></span></span><br></pre></td></tr></table></figure>
<h5 id="摘要算法函数"><a class="markdownIt-Anchor" href="#摘要算法函数"></a> 摘要算法函数</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_md_null</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_md2</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_md4</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_md5</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_sha</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_sha1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_sha224</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_sha256</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_sha384</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_sha512</span><span class="params">(<span class="keyword">void</span>)</span></span>;       </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_dss</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_dss1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_ecdsa</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_mdc2</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_ripemd160</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> EVP_MD *<span class="title">EVP_whirlpool</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="程序示例-2"><a class="markdownIt-Anchor" href="#程序示例-2"></a> 程序示例</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/conf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleErrors</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ERR_print_errors_fp(<span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">digest_message</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* message, <span class="keyword">size_t</span> message_len, <span class="keyword">unsigned</span> ch</span></span></span><br><span class="line"><span class="function"><span class="params">ar** digest, <span class="keyword">unsigned</span> <span class="keyword">int</span>* digest_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        EVP_MD_CTX* mdctx;</span><br><span class="line">        <span class="keyword">if</span>((mdctx=EVP_MD_CTX_new())==<span class="literal">NULL</span>)</span><br><span class="line">                handleErrors();</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>!=EVP_DigestInit_ex(mdctx,EVP_sha256(),<span class="literal">NULL</span>))</span><br><span class="line">                handleErrors();</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>!=EVP_DigestUpdate(mdctx,message,message_len))</span><br><span class="line">                handleErrors();</span><br><span class="line">        <span class="keyword">if</span>((*digest=(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)OPENSSL_malloc(EVP_MD_size(EVP_sha256())))==N</span><br><span class="line">ULL)</span><br><span class="line">                handleErrors();</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>!=EVP_DigestFinal_ex(mdctx,*digest,digest_len))</span><br><span class="line">                handleErrors();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;(*digest_len);i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>,(*digest)[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        EVP_MD_CTX_free(mdctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* message=(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="string">&quot;01234567890123456789&quot;</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>** digest;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> digest_len;</span><br><span class="line">        digest_message(message,<span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)message),digest,&amp;digest_len);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非对称加密"><a class="markdownIt-Anchor" href="#非对称加密"></a> 非对称加密</h2>
<p>主要是以 p_开头的文件。其中:</p>
<ul>
<li>p_enc.c 封装了公钥加密；</li>
<li>p_dec.c 封装了私钥解密；</li>
<li>p_lib.c 实现一些辅助函数；</li>
<li>p_sign.c 封装了签名函数；</li>
<li>p_verify.c 封装了验签函数；</li>
<li>p_seal.c 封装了数字信封相关的函数；</li>
<li>p_open.c 封装了解数字信封相关的函数。</li>
</ul>
<h3 id="基本数据结构-3"><a class="markdownIt-Anchor" href="#基本数据结构-3"></a> 基本数据结构</h3>
<p>该结构用来存放非对称密钥信息，可以是RSA、DSA、DH 或ECC 密钥。其中，ptr 用来存放密钥结构地址，attributes 堆栈用来存放密钥属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">evp_pkey_st</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">int</span> save_type;</span><br><span class="line">    <span class="keyword">int</span> references;</span><br><span class="line">    <span class="keyword">const</span> EVP_PKEY_ASN1_METHOD *ameth;</span><br><span class="line">    ENGINE *engine;</span><br><span class="line">    <span class="keyword">union</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *ptr;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rsa_st</span> *<span class="title">rsa</span>;</span>     <span class="comment">/* RSA */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dsa_st</span> *<span class="title">dsa</span>;</span>     <span class="comment">/* DSA */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dh_st</span> *<span class="title">dh</span>;</span>       <span class="comment">/* DH */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ec_key_st</span> *<span class="title">ec</span>;</span>   <span class="comment">/* ECC */</span></span><br><span class="line">    &#125; pkey;</span><br><span class="line">    <span class="keyword">int</span> save_parameters;</span><br><span class="line">    STACK_OF(X509_ATTRIBUTE) *attributes; <span class="comment">/* [ 0 ] */</span></span><br><span class="line">&#125;; EVP_PKEY</span><br></pre></td></tr></table></figure>
<h3 id="相关函数-3"><a class="markdownIt-Anchor" href="#相关函数-3"></a> 相关函数</h3>
<h4 id="核心函数-3"><a class="markdownIt-Anchor" href="#核心函数-3"></a> 核心函数</h4>
<h5 id="加密-2"><a class="markdownIt-Anchor" href="#加密-2"></a> 加密</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_encrypt_old</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *enc_key,<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">int</span> key_len, EVP_PKEY *pubk)</span> <span class="comment">//使用RSA公钥加密</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_encrypt_init</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>; <span class="comment">//使用密钥pkey对公钥算法的上下文进行初始化，以进行加密操作。返回1成功，0或负值失败，-2代表该公钥算法不支持此操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_encrypt</span><span class="params">(EVP_PKEY_CTX *ctx,<span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">size_t</span> *outlen, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">size_t</span> inlen)</span></span>; <span class="comment">//函数使用ctx执行公钥加密操作。使用in和inlen参数指定要加密的数据与数据长度。如果out为NULL，则输出缓冲区的最大大小写入outlen参数。如果out不为NULL，那么在调用之前，outlen参数应该包含out缓冲区的长度，如果调用成功，则将加密数据写入out，并将加密后的数据长度写入outlen。返回1成功，0或负值失败，-2表示该公钥算法不支持该操作</span></span><br></pre></td></tr></table></figure>
<h5 id="解密-2"><a class="markdownIt-Anchor" href="#解密-2"></a> 解密</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_decrypt_old</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *dec_key, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *enc_key, <span class="keyword">int</span> enc_key_len,EVP_PKEY *private_key)</span></span>;<span class="comment">//RSA私钥解密</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_decrypt_init</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>; <span class="comment">//函数使用密钥pkey初始化公钥算法的上下文以进行解密操作。返回1成功，0或负值失败，-2表示该公钥算法不支持该操作。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_decrypt</span><span class="params">(EVP_PKEY_CTX *ctx,<span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">size_t</span> *outlen, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">size_t</span> inlen)</span></span>; <span class="comment">//函数使用ctx执行公钥解操作。使用in和inlen参数指定要解密的数据与数据字长。如果out为NULL，则输出缓冲区的最大大小写入outlen参数。如果out不为NULL，那么在调用之前，outlen参数应该包含out缓冲区的长度，如果调用成功，则将解密数据写入out，并将数据写入outlen。返回1成功，0或负值失败，-2表示该公钥算法不支持该操作。</span></span><br></pre></td></tr></table></figure>
<h4 id="辅助函数-3"><a class="markdownIt-Anchor" href="#辅助函数-3"></a> 辅助函数</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="function">EVP_PKEY_CTX *<span class="title">EVP_PKEY_CTX_new</span><span class="params">(EVP_PKEY *pkey, ENGINE *e)</span></span>; <span class="comment">//使用pkey和ENGINE e中指定的算法分配公钥算法上下文，返回新分配的EVP_PKEY_CTX结构，如果出现错误返回NULL</span></span><br><span class="line"><span class="function">EVP_PKEY_CTX *<span class="title">EVP_PKEY_CTX_new_id</span><span class="params">(<span class="keyword">int</span> id, ENGINE *e)</span></span>; <span class="comment">//使用由id和e指定的算法分配公钥算法上下文，返回新分配的EVP_PKEY_CTX结构，如果出现错误返回NULL</span></span><br><span class="line"><span class="function">EVP_PKEY_CTX *<span class="title">EVP_PKEY_CTX_dup</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>; <span class="comment">//复制上下文ctx，返回新分配的EVP_PKEY_CTX结构，如果出现错误返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_PKEY_CTX_free</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>; <span class="comment">//释放上下文ctx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_ctrl</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">int</span> keytype, <span class="keyword">int</span> optype,<span class="keyword">int</span> cmd, <span class="keyword">int</span> p1, <span class="keyword">void</span> *p2)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_ctrl_str</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *type,<span class="keyword">const</span> <span class="keyword">char</span> *value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/rsa.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_set_signature_md</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">const</span> EVP_MD *md)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_set_rsa_padding</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">int</span> pad)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_set_rsa_pss_saltlen</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_set_rsa_rsa_keygen_bits</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">int</span> mbits)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_set_rsa_keygen_pubexp</span><span class="params">(EVP_PKEY_CTX *ctx, BIGNUM *pubexp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/dsa.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_set_dsa_paramgen_bits</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">int</span> nbits)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/dh.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_set_dh_paramgen_prime_len</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_set_dh_paramgen_generator</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">int</span> gen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/ec.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_set_ec_paramgen_curve_nid</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">int</span> nid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_PKEY_CTX_set_cb</span><span class="params">(EVP_PKEY_CTX *ctx, EVP_PKEY_gen_cb *cb)</span></span>;</span><br><span class="line"><span class="function">EVP_PKEY_gen_cb *<span class="title">EVP_PKEY_CTX_get_cb</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="comment">//将pkey所指的EVP_PKEY的密钥设置为key所指的密钥，成功返回1，失败返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_set1_RSA</span><span class="params">(EVP_PKEY *pkey,RSA *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_set1_DSA</span><span class="params">(EVP_PKEY *pkey,DSA *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_set1_DH</span><span class="params">(EVP_PKEY *pkey,DH *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_set1_EC_KEY</span><span class="params">(EVP_PKEY *pkey,EC_KEY *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从pkey所指的EVP_PKEY中获取对应的密钥，失败返回NULL </span></span><br><span class="line"><span class="function">RSA *<span class="title">EVP_PKEY_get1_RSA</span><span class="params">(EVP_PKEY *pkey)</span></span>;</span><br><span class="line"><span class="function">DSA *<span class="title">EVP_PKEY_get1_DSA</span><span class="params">(EVP_PKEY *pkey)</span></span>;</span><br><span class="line"><span class="function">DH *<span class="title">EVP_PKEY_get1_DH</span><span class="params">(EVP_PKEY *pkey)</span></span>;</span><br><span class="line"><span class="function">EC_KEY *<span class="title">EVP_PKEY_get1_EC_KEY</span><span class="params">(EVP_PKEY *pkey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将pkey所指的EVP_PKEY的密钥设置为key所指的密钥，但pkey释放时，key也会被释放成功返回1，失败返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_assign</span><span class="params">(EVP_PKEY,<span class="keyword">int</span> type ,<span class="keyword">void</span> *key)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_assign_RSA</span><span class="params">(EVP_PKEY *pkey,RSA *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_assign_DSA</span><span class="params">(EVP_PKEY *pkey,DSA *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_assign_DH</span><span class="params">(EVP_PKEY *pkey,DH *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_assign_EC_KEY</span><span class="params">(EVP_PKEY *pkey,EC_KEY *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回与type匹配的密钥的类型，EVP_PKEY_RSA, EVP_PKEY_DSA, EVP_PKEY_DH or EVP_PKEY_EC或者NID_undef</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_type</span><span class="params">(<span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_missing_parameters</span><span class="params">(<span class="keyword">const</span> EVP_PKEY *pkey)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_copy_parameters</span><span class="params">(EVP_PKEY *to, <span class="keyword">const</span> EVP_PKEY *from)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_cmp_parameters</span><span class="params">(<span class="keyword">const</span> EVP_PKEY *a, <span class="keyword">const</span> EVP_PKEY *b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_cmp</span><span class="params">(<span class="keyword">const</span> EVP_PKEY *a, <span class="keyword">const</span> EVP_PKEY *b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_derive_init</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_derive_set_peer</span><span class="params">(EVP_PKEY_CTX *ctx, EVP_PKEY *peer)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_derive</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">size_t</span> *keylen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_get_default_digest_nid</span><span class="params">(EVP_PKEY *pkey, <span class="keyword">int</span> *pnid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_keygen_init</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_keygen</span><span class="params">(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_paramgen_init</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_paramgen</span><span class="params">(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="title">EVP_PKEY_gen_cb</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_CTX_get_keygen_info</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">int</span> idx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_PKEY_CTX_set_app_data</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">EVP_PKEY_CTX_get_app_data</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">EVP_PKEY *<span class="title">EVP_PKEY_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_PKEY_free</span><span class="params">(EVP_PKEY *key)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_print_public</span><span class="params">(BIO *out, <span class="keyword">const</span> EVP_PKEY *pkey,<span class="keyword">int</span> indent, ASN1_PCTX *pctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_print_private</span><span class="params">(BIO *out, <span class="keyword">const</span> EVP_PKEY *pkey,<span class="keyword">int</span> indent, ASN1_PCTX *pctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_print_params</span><span class="params">(BIO *out, <span class="keyword">const</span> EVP_PKEY *pkey,<span class="keyword">int</span> indent, ASN1_PCTX *pctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_sign_init</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_sign</span><span class="params">(EVP_PKEY_CTX *ctx,<span class="keyword">unsigned</span> <span class="keyword">char</span> *sig, <span class="keyword">size_t</span> *siglen, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *tbs, <span class="keyword">size_t</span> tbslen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_verify_init</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_verify</span><span class="params">(EVP_PKEY_CTX *ctx, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *sig, <span class="keyword">size_t</span> siglen, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *tbs, <span class="keyword">size_t</span> tbslen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_verify_recover_init</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_verify_recover</span><span class="params">(EVP_PKEY_CTX *ctx,<span class="keyword">unsigned</span> <span class="keyword">char</span> *rout, <span class="keyword">size_t</span> *routlen, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *sig, <span class="keyword">size_t</span> siglen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_get_default_digest_nid</span><span class="params">(EVP_PKEY *pkey, <span class="keyword">int</span> *pnid)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="程序示例-3"><a class="markdownIt-Anchor" href="#程序示例-3"></a> 程序示例</h3>
<h4 id="参数初始化"><a class="markdownIt-Anchor" href="#参数初始化"></a> 参数初始化</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create the context for generating the parameters */</span></span><br><span class="line"><span class="keyword">if</span>(!(pctx = EVP_PKEY_CTX_new_id(type, <span class="literal">NULL</span>))) <span class="keyword">goto</span> err;</span><br><span class="line"><span class="keyword">if</span>(!EVP_PKEY_paramgen_init(pctx)) <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the paramgen parameters according to the type */</span></span><br><span class="line"><span class="keyword">switch</span>(type)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> EVP_PKEY_EC:</span><br><span class="line">  <span class="comment">/* Use the NID_X9_62_prime256v1 named curve - defined in obj_mac.h */</span></span><br><span class="line">  <span class="keyword">if</span>(!EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx, NID_X9_62_prime256v1)) <span class="keyword">goto</span> err;		</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EVP_PKEY_DSA:</span><br><span class="line">  <span class="comment">/* Set a bit length of 2048 */</span></span><br><span class="line">  <span class="keyword">if</span>(!EVP_PKEY_CTX_set_dsa_paramgen_bits(pctx, <span class="number">2048</span>)) <span class="keyword">goto</span> err;		</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EVP_PKEY_DH:</span><br><span class="line">  <span class="comment">/* Set a prime length of 2048 */</span></span><br><span class="line">  <span class="keyword">if</span>(!EVP_PKEY_CTX_set_dh_paramgen_prime_len(pctx, <span class="number">2048</span>)) <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Generate parameters */</span></span><br><span class="line"><span class="keyword">if</span> (!EVP_PKEY_paramgen(pctx, &amp;params)) <span class="keyword">goto</span> err;</span><br></pre></td></tr></table></figure>
<h4 id="密钥生成"><a class="markdownIt-Anchor" href="#密钥生成"></a> 密钥生成</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(*params != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!(kctx = EVP_PKEY_CTX_new(params, <span class="literal">NULL</span>))) <span class="keyword">goto</span> err; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Create context for the key generation */</span></span><br><span class="line">  <span class="keyword">if</span>(!(kctx = EVP_PKEY_CTX_new_id(type, <span class="literal">NULL</span>))) <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!EVP_PKEY_keygen_init(kctx)) <span class="keyword">goto</span> err; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* RSA keys set the key length during key generation rather than parameter generation! */</span></span><br><span class="line"><span class="keyword">if</span>(type == EVP_PKEY_RSA)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!EVP_PKEY_CTX_set_rsa_keygen_bits(kctx, <span class="number">2048</span>)) <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Generate the key */</span></span><br><span class="line"><span class="keyword">if</span> (!EVP_PKEY_keygen(kctx, &amp;key)) <span class="keyword">goto</span> err;</span><br></pre></td></tr></table></figure>
<h2 id="base64编解码"><a class="markdownIt-Anchor" href="#base64编解码"></a> BASE64编解码</h2>
<h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3>
<p>Base 64编码将二进制数据转换为使用字符 A-Z，a-z，0-9，“+”和“/”表示来数据的可打印形式。每3个字节的二进制数据，编码为上述字符表示的4字节数据。如果输入数据长度不是3的倍数，则输出数据将使用“=”字符在最后填充。</p>
<p>步骤：首先将每三个字节原始二进制数据在一起展开； 然后6bit分为一个小组，每个小组前面补两个0，成为一个字节；把新编码的每个字节转为十进制，根据base64标准转换表，找到对应的字符。 如果多了一个字节，则剩余两个字节用“=”填充，如果多了两个字节，则剩余一个字节用“=”填充。</p>
<h3 id="基本数据结构-4"><a class="markdownIt-Anchor" href="#基本数据结构-4"></a> 基本数据结构</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">evp_Encode_Ctx_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="comment">/* number saved in a partial encode/decode */</span></span><br><span class="line">     <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* The length is either the output line length (in input bytes) or the shortest input line length that is ok.  Once decoding begins, the length is adjusted up each time a longer line is decoded */</span></span><br><span class="line">     <span class="keyword">int</span> length;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> enc_data[<span class="number">80</span>];    <span class="comment">//待编码的数据</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> line_num;   <span class="comment">/* number read on current line */</span></span><br><span class="line">     <span class="keyword">int</span> expect_nl;</span><br><span class="line">&#125; EVP_ENCODE_CTX;  </span><br></pre></td></tr></table></figure>
<h3 id="相关函数-4"><a class="markdownIt-Anchor" href="#相关函数-4"></a> 相关函数</h3>
<h4 id="核心函数-4"><a class="markdownIt-Anchor" href="#核心函数-4"></a> 核心函数</h4>
<h5 id="编码"><a class="markdownIt-Anchor" href="#编码"></a> 编码</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_EncodeInit</span><span class="params">(EVP_ENCODE_CTX *ctx)</span></span>; <span class="comment">//初始化ctx以启动新的编码操作，无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_EncodeUpdate</span><span class="params">(EVP_ENCODE_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span></span>; <span class="comment">//编码in指向的缓冲区中的inl字节数据。输出存储在缓冲区out中，输出的字节数存储在outl中。调用者必须确保out指向的缓冲区足够大以容纳输出数据。只有完整的数据块（48字节）可以被直接编码完后并通过函数输出。任何剩余的字节都保存在ctx对象中，并通过后续调用EVP_EncodeUpdate（）EVP_EncodeFinal（）来处理。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_EncodeFinal</span><span class="params">(EVP_ENCODE_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl)</span></span>; <span class="comment">//必须在编码操作结束时调用EVP_EncodeFinal（）。它将处理ctx对象中剩余的任何部分数据块。输出数据将被存储在out，输出的数据长度将存储在* outl中，包含了’\n’。无返回值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">EVP_EncodeBlock</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *t, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *f, <span class="keyword">int</span> n)</span></span>; <span class="comment">//对f中的输入数据进行编码，并将其存储在t中。对于每3字节的输入，将产生4字节的输出数据。如果n不能被3整除，则块被当做最后的数据块来编码，并且被填充，使得它总是可被除以4。另外还将添加‘\0’终结符字符。</span></span><br></pre></td></tr></table></figure>
<h5 id="解码"><a class="markdownIt-Anchor" href="#解码"></a> 解码</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_DecodeInit</span><span class="params">(EVP_ENCODE_CTX *ctx)</span></span>; <span class="comment">//初始化ctx以开始新的解码操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">EVP_DecodeUpdate</span><span class="params">(EVP_ENCODE_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span></span>; <span class="comment">//解码in指向的缓冲区中inl字节的数据。输出存储在缓冲区中out，输出的字节数存储在* outl中。调用者有责任确保out指向的缓冲区足够大以容纳输出数据。该功能将尝试在4字节块中尽可能多地解码数据。任何空格，换行符或回车符都将被忽略。任何保留在结尾的未处理数据（1,2或3个字节）的部分块将保留在ctx对象中，并由后续调用EVP_DecodeUpdate（）处理。如果遇到非法的base64字符，或者如果在数据中间遇到base64填充字符“=”，则函数返回-1表示错误。返回值为0或1表示数据成功处理。返回值0表示处理的最后输入数据字符包括base64填充字符“=”，预期不会再处理非填充字符数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">EVP_DecodeFinal</span><span class="params">(EVP_ENCODE_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl)</span></span>; <span class="comment">//必须在解码操作结束时调用，如果仍然存在任何未处理的数据，那么输入数据不能是4的倍数。成功返回1，失败返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">EVP_DecodeBlock</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *t, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *f, <span class="keyword">int</span> n)</span></span>; <span class="comment">//解码f中包含的基本64个数据的n个字节的块，并将结果存储在t中。任何前导空格，以及任何尾随的空格，换行符，回车符或EOF字符将被修剪。返回解码的数据长度，出错返回-1。</span></span><br></pre></td></tr></table></figure>
<h4 id="辅助函数-4"><a class="markdownIt-Anchor" href="#辅助函数-4"></a> 辅助函数</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EVP_ENCODE_CTX *<span class="title">EVP_ENCODE_CTX_new</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//分配，初始化并返回要用于encode / decode函数的上下文。成功返回地址，失败返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_ENCODE_CTX_free</span><span class="params">(EVP_ENCODE_CTX *ctx)</span></span>; <span class="comment">//清理编码/解码上下文ctx并释放分配给它的空间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_ENCODE_CTX_copy</span><span class="params">(EVP_ENCODE_CTX *dctx, EVP_ENCODE_CTX *sctx)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_ENCODE_CTX_num</span><span class="params">(EVP_ENCODE_CTX *ctx)</span></span>; <span class="comment">//返回在ctx对象中待处理的尚未编码或解码的字节数</span></span><br></pre></td></tr></table></figure>
<h3 id="程序示例-4"><a class="markdownIt-Anchor" href="#程序示例-4"></a> 程序示例</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>	<span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EVP_ENCODE_CTX ectx,dctx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> in[<span class="number">500</span>],out[<span class="number">800</span>],d[<span class="number">500</span>];</span><br><span class="line">    <span class="keyword">int</span>	inl,outl,i,total,ret,total2;</span><br><span class="line"></span><br><span class="line">    EVP_EncodeInit(&amp;ectx);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">500</span>;i++)</span><br><span class="line">        <span class="built_in">memset</span>(&amp;in[i],i,<span class="number">1</span>);</span><br><span class="line">    inl=<span class="number">500</span>;</span><br><span class="line">    total=<span class="number">0</span>;</span><br><span class="line">    EVP_EncodeUpdate(&amp;ectx,out,&amp;outl,in,inl);</span><br><span class="line">    total+=outl;</span><br><span class="line">    EVP_EncodeFinal(&amp;ectx,out+total,&amp;outl);</span><br><span class="line">    total+=outl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,out);</span><br><span class="line"></span><br><span class="line">    EVP_DecodeInit(&amp;dctx);</span><br><span class="line">    outl=<span class="number">500</span>;</span><br><span class="line">    total2=<span class="number">0</span>;</span><br><span class="line">    ret=EVP_DecodeUpdate(&amp;dctx,d,&amp;outl,out,total);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EVP_DecodeUpdate err!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    total2+=outl;</span><br><span class="line">    ret=EVP_DecodeFinal(&amp;dctx,d,&amp;outl);</span><br><span class="line">    total2+=outl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hmac"><a class="markdownIt-Anchor" href="#hmac"></a> HMAC</h2>
<p>HMAC是基于散列函数的MAC（消息认证码），即用于消息认证的密钥哈希函数。</p>
<h3 id="基本数据结构-5"><a class="markdownIt-Anchor" href="#基本数据结构-5"></a> 基本数据结构</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hmac_ctx_st</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> EVP_MD *md;</span><br><span class="line">    EVP_MD_CTX md_ctx;</span><br><span class="line">    EVP_MD_CTX i_ctx;</span><br><span class="line">    EVP_MD_CTX o_ctx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> key_length;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> key[HMAC_MAX_MD_CBLOCK];</span><br><span class="line">&#125;<span class="comment">/* HMAC_CTX*/</span>;</span><br></pre></td></tr></table></figure>
<h3 id="相关函数-5"><a class="markdownIt-Anchor" href="#相关函数-5"></a> 相关函数</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">HMAC</span><span class="params">(<span class="keyword">const</span> EVP_MD *evp_md, <span class="keyword">const</span> <span class="keyword">void</span> *key,<span class="keyword">int</span> key_len, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *d, <span class="keyword">int</span> n,<span class="keyword">unsigned</span> <span class="keyword">char</span> *md, <span class="keyword">unsigned</span> <span class="keyword">int</span> *md_len)</span></span>; <span class="comment">//使用哈希函数evp_md和key_len字节长的密钥键计算d字节的消息认证码。它将结果放在md（它必须有空格的哈希函数的输出，不超过EVP_MAX_MD_SIZE字节）。如果md为NULL，则将摘要放置在静态数组中。输出的大小放在md_len中，除非它为空。evp_md可以为EVP_sha1()等</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> HMAC_MAX_MD_CBLOCK      128<span class="comment">/* largest known is SHA512 */</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> HMAC_size(e)    (EVP_MD_size((e)-&gt;md)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HMAC_CTX_init</span><span class="params">(HMAC_CTX *ctx)</span></span>; <span class="comment">//HMAC_CTX_init()在首次使用前初始化HMAC_CTX。必须调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HMAC_CTX_cleanup</span><span class="params">(HMAC_CTX *ctx)</span></span>; <span class="comment">//HMAC_CTX_cleanup()从HMAC_CTX中删除密钥和其他数据，并释放任何关联的资源。当不再需要HMAC_CTX时，必须调用它</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">HMAC_size</span><span class="params">(<span class="keyword">const</span> HMAC_CTX *e)</span></span>;</span><br><span class="line"><span class="function">HMAC_CTX *<span class="title">HMAC_CTX_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HMAC_CTX_reset</span><span class="params">(HMAC_CTX *ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HMAC_CTX_free</span><span class="params">(HMAC_CTX *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果消息没有完全存储在内存中，可能会使用以下功能：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HMAC_Init_ex</span><span class="params">(HMAC_CTX *ctx, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> key_len,<span class="keyword">const</span> EVP_MD *md, ENGINE *impl)</span></span>; <span class="comment">//初始化或重用HMAC_CTX结构以使用函数evp_md和key，key可以是NULL，在这种情况下，现有的一个将被重用。 HMAC_CTX_init()必须在此功能首次使用HMAC_CTX之前被调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HMAC_Update</span><span class="params">(HMAC_CTX *ctx, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> len)</span></span>; <span class="comment">//可以重复调用消息的大小块进行身份验证（数据中为len个字节）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HMAC_Final</span><span class="params">(HMAC_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *md, <span class="keyword">unsigned</span> <span class="keyword">int</span> *len)</span></span>; <span class="comment">//将消息认证码放在md中，它必须具有用于散列函数输出的空间</span></span><br></pre></td></tr></table></figure>
<h3 id="程序示例-5"><a class="markdownIt-Anchor" href="#程序示例-5"></a> 程序示例</h3>
<h4 id="生成"><a class="markdownIt-Anchor" href="#生成"></a> 生成</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hmac_it</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *msg, <span class="keyword">size_t</span> mlen, <span class="keyword">unsigned</span> <span class="keyword">char</span> **val, <span class="keyword">size_t</span> *vlen, EVP_PKEY *pkey)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Returned to caller */</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    EVP_MD_CTX* ctx = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> req = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!msg || !mlen || !val || !pkey)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    *val = <span class="literal">NULL</span>;</span><br><span class="line">    *vlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ctx = EVP_MD_CTX_new();</span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EVP_MD_CTX_create failed, error 0x%lx\n&quot;</span>, ERR_get_error());</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rc = EVP_DigestSignInit(ctx, <span class="literal">NULL</span>, EVP_sha256(), <span class="literal">NULL</span>, pkey);</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EVP_DigestSignInit failed, error 0x%lx\n&quot;</span>, ERR_get_error());</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rc = EVP_DigestSignUpdate(ctx, msg, mlen);</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EVP_DigestSignUpdate failed, error 0x%lx\n&quot;</span>, ERR_get_error());</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rc = EVP_DigestSignFinal(ctx, <span class="literal">NULL</span>, &amp;req);</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EVP_DigestSignFinal failed (1), error 0x%lx\n&quot;</span>, ERR_get_error());</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *val = OPENSSL_malloc(req);</span><br><span class="line">    <span class="keyword">if</span> (*val == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OPENSSL_malloc failed, error 0x%lx\n&quot;</span>, ERR_get_error());</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *vlen = req;</span><br><span class="line">    rc = EVP_DigestSignFinal(ctx, *val, vlen);</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EVP_DigestSignFinal failed (3), return code %d, error 0x%lx\n&quot;</span>, rc, ERR_get_error());</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line"> err:</span><br><span class="line">    EVP_MD_CTX_free(ctx);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        OPENSSL_free(*val);</span><br><span class="line">        *val = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="验证"><a class="markdownIt-Anchor" href="#验证"></a> 验证</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">verify_it</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *msg, <span class="keyword">size_t</span> mlen, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *val, <span class="keyword">size_t</span> vlen, EVP_PKEY *pkey)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Returned to caller */</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    EVP_MD_CTX* ctx = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buff[EVP_MAX_MD_SIZE];</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!msg || !mlen || !val || !vlen || !pkey)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ctx = EVP_MD_CTX_new();</span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EVP_MD_CTX_create failed, error 0x%lx\n&quot;</span>, ERR_get_error());</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rc = EVP_DigestSignInit(ctx, <span class="literal">NULL</span>, EVP_sha256(), <span class="literal">NULL</span>, pkey);</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EVP_DigestSignInit failed, error 0x%lx\n&quot;</span>, ERR_get_error());</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rc = EVP_DigestSignUpdate(ctx, msg, mlen);</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EVP_DigestSignUpdate failed, error 0x%lx\n&quot;</span>, ERR_get_error());</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    size = <span class="keyword">sizeof</span>(buff);</span><br><span class="line">    rc = EVP_DigestSignFinal(ctx, buff, &amp;size);</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EVP_DigestSignFinal failed, error 0x%lx\n&quot;</span>, ERR_get_error());</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result = (vlen == size) &amp;&amp; (CRYPTO_memcmp(val, buff, size) == <span class="number">0</span>);</span><br><span class="line"> err:</span><br><span class="line">    EVP_MD_CTX_free(ctx);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数字签名"><a class="markdownIt-Anchor" href="#数字签名"></a> 数字签名</h2>
<h3 id="签名"><a class="markdownIt-Anchor" href="#签名"></a> 签名</h3>
<p><strong>EVP_Sign系列函数</strong>使用的基础结构跟信息摘要算法使用的基础结构是一样的，而且，其前面的两个操作步骤初始化和数据操作（信息摘要）也跟信息摘要算法是一样的，唯一不一样的是最后一步操作，本系列函数做了签名的工作。本系列函数定义的如下(openssl/evp.h)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_SignInit_ex(a,b,c) EVP_DigestInit_ex(a,b,c)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_SignInit_ex</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">const</span> EVP_MD *type, ENGINE *impl)</span></span>; <span class="comment">//使用ENGINE参数impl所代表的实现函数功能来设置结构ctx。在调用本函数前，参数ctx一定要经过EVP_MD_CTX_init函数初始化。成功返回1，失败返回0。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_SignUpdate(a,b,c) EVP_DigestUpdate(a,b,c)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_SignUpdate</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">const</span> <span class="keyword">void</span> *d, <span class="keyword">unsigned</span> <span class="keyword">int</span> cnt)</span></span>; <span class="comment">//将一个cnt字节的数据经过信息摘要运算存储到结构ctx中，该函数可以在一个相同的ctx中调用多次来实现对更多数据的信息摘要工作。成功返回1，失败返回0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_SignFinal</span><span class="params">(EVP_MD_CTX *ctx,<span class="keyword">unsigned</span> <span class="keyword">char</span> *sig,<span class="keyword">unsigned</span> <span class="keyword">int</span> *s, EVP_PKEY *pkey)</span></span>; <span class="comment">//该函数是将签名操作的信息摘要结构先调用EVP_MD_CTX_copy_ex函数拷贝一份，然后调用EVP_DigestFinal_ex完成信息摘要工作，然后开始对摘要信息用私钥pkey调用EVP_PKEY_sign_init 和EVP_PKEY_sign进行签名,并将签名信息保存在参数sig里面。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_SignInit(a,b) EVP_DigestInit(a,b)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_SignInit</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">const</span> EVP_MD *type)</span></span>; <span class="comment">//使用缺省实现的算法初始化算法结构ctx</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_PKEY_size</span><span class="params">(EVP_PKEY *pkey)</span></span>; <span class="comment">//返回一个签名信息的最大长度（单位字节）。实际签名信息的长度则由上述的函数EVP_SignFinal返回，有可能比它小</span></span><br></pre></td></tr></table></figure>
<h3 id="认证"><a class="markdownIt-Anchor" href="#认证"></a> 认证</h3>
<p>与EVP_Sign系列函数一样，EVP_Verify系列函数的前两步（初始化和信息摘要处理）和信息摘要算法是一样的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_VerifyInit_ex(a,b,c) EVP_DigestInit_ex(a,b,c)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_VerifyInit_ex</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">const</span> EVP_MD *type, ENGINE *impl)</span></span>; <span class="comment">//该函数使用参数impl所提供的算法库对验证结构ctx进行设置。在调用本函数之前，参数ctx必须经过调用EVP_MD_CTX_init进行初始化。成功返回1，失败返回0。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_VerifyUpdate(a,b,c) EVP_DigestUpdate(a,b,c)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_VerifyUpdate</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">const</span> <span class="keyword">void</span> *d, <span class="keyword">unsigned</span> <span class="keyword">int</span> cnt)</span></span>; <span class="comment">//该函数将参数d中的cnt字节数据经过信息摘要计算后保存到ctx中，该函数可以进行多次调用，以处理更多的数据。成功调用返回1，失败返回0。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_VerifyFinal</span><span class="params">(EVP_MD_CTX *ctx,<span class="keyword">unsigned</span> <span class="keyword">char</span> *sigbuf, <span class="keyword">unsigned</span> <span class="keyword">int</span> siglen,EVP_PKEY *pkey)</span></span>; <span class="comment">//该函数先调用EVP_MD_CTX_copy_ex函数将原来的ctx拷贝一份，然后调用EVP_DigestFinal_ex函数完成拷贝的ctx的信息摘要计算，最后才使用公钥pkey调用EVP_PKEY_verify_init 和EVP_PKEY_verify_进行签名的验证工作</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_VerifyInit(a,b) EVP_DigestInit(a,b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_VerifyInit</span><span class="params">(EVP_MD_CTX *ctx, <span class="keyword">const</span> EVP_MD *type)</span></span>; <span class="comment">//使用默认实现对ctx结构进行初始化</span></span><br></pre></td></tr></table></figure>
<h3 id="备注"><a class="markdownIt-Anchor" href="#备注"></a> 备注</h3>
<p>在新版的OpenSSL中定义了<code>EVP_DigestSign*</code> 和 <code>EVP_DigestVerify*</code> 这两个系列的函数，将计算摘要和数字签名操作合在一起。这一系列函数的用法与不带Digest的系列函数类似，但是函数的参数稍有不同。</p>
<h3 id="程序示例-6"><a class="markdownIt-Anchor" href="#程序示例-6"></a> 程序示例</h3>
<h4 id="签名-2"><a class="markdownIt-Anchor" href="#签名-2"></a> 签名</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">EVP_MD_CTX *mdctx = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">*sig = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Create the Message Digest Context */</span></span><br><span class="line"><span class="keyword">if</span>(!(mdctx = EVP_MD_CTX_create())) <span class="keyword">goto</span> err;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Initialise the DigestSign operation - SHA-256 has been selected as the message digest function in this example */</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> != EVP_DigestSignInit(mdctx, <span class="literal">NULL</span>, EVP_sha256(), <span class="literal">NULL</span>, key)) <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Call update with the message */</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> != EVP_DigestSignUpdate(mdctx, msg, <span class="built_in">strlen</span>(msg))) <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Finalise the DigestSign operation */</span></span><br><span class="line"><span class="comment">/* First call EVP_DigestSignFinal with a NULL sig parameter to obtain the length of the</span></span><br><span class="line"><span class="comment">* signature. Length is returned in slen */</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> != EVP_DigestSignFinal(mdctx, <span class="literal">NULL</span>, slen)) <span class="keyword">goto</span> err;</span><br><span class="line"><span class="comment">/* Allocate memory for the signature based on size in slen */</span></span><br><span class="line"><span class="keyword">if</span>(!(*sig = OPENSSL_malloc(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>) * (*slen)))) <span class="keyword">goto</span> err;</span><br><span class="line"><span class="comment">/* Obtain the signature */</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> != EVP_DigestSignFinal(mdctx, *sig, slen)) <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Success */</span></span><br><span class="line">ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Do some error handling */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Clean up */</span></span><br><span class="line"><span class="keyword">if</span>(*sig &amp;&amp; !ret) OPENSSL_free(*sig);</span><br><span class="line"><span class="keyword">if</span>(mdctx) EVP_MD_CTX_destroy(mdctx);</span><br></pre></td></tr></table></figure>
<h4 id="验证-2"><a class="markdownIt-Anchor" href="#验证-2"></a> 验证</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initialize `key` with a public key */</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> != EVP_DigestVerifyInit(mdctx, <span class="literal">NULL</span>, EVP_sha256(), <span class="literal">NULL</span>, key)) <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize `key` with a public key */</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> != EVP_DigestVerifyUpdate(mdctx, msg, <span class="built_in">strlen</span>(msg))) <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> == EVP_DigestVerifyFinal(mdctx, sig, slen))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Success */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Failure */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数字信封"><a class="markdownIt-Anchor" href="#数字信封"></a> 数字信封</h2>
<h3 id="写信"><a class="markdownIt-Anchor" href="#写信"></a> 写信</h3>
<p>seal系列函数是相当于完成一个电子信封的功能，它产生一个随机密钥，然后使用一个公钥对该密钥进行封装，数据可以使用该随机密钥进行对称加密。</p>
<p>信封加密在进行大量数据传输的时候是必须经常要用到的，因为公开密钥算法的加解密速度很慢，但对称算法就快多了。所以一般用公开密钥算法对产生的随机密钥加密，而真正进行数据加密则使用该随机密钥进行对称加密，然后将加密后的密钥与数据一起发送。</p>
<p>其定义的函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_SealInit</span><span class="params">(EVP_CIPHER_CTX *ctx, EVP_CIPHER *type, <span class="keyword">unsigned</span> <span class="keyword">char</span> **ek, <span class="keyword">int</span> *ekl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv,EVP_PKEY **pubk, <span class="keyword">int</span> npubk)</span></span>;<span class="comment">//该函数初始化一个加密算法结构EVP_CIPHER_CTX，采用了指定的加密算法，使用一个随机密钥和初始化向量IV。事实上，该函数调用EVP_EncryptInit_ex函数两次完成了ctx结构的初始化工作；参数type是算法类型，参数ek是一个缓存序列，可以存放多个被公钥加密后的密钥的信息，所以每个缓存空间都应该足够大；参数pubk是一个公钥陈列，可以包含多个公钥。函数成功执行返回npubk，失败返回0。 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_SealUpdate(a,b,c,d,e) EVP_EncryptUpdate(a,b,c,d,e)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_SealUpdate</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span></span>; <span class="comment">//其完成的功能和使用方法跟EVP_EncryptUpdate函数是一样的。成功执行返回1，否则返回0。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_SealFinal</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out,<span class="keyword">int</span> *outl)</span></span>; <span class="comment">//简单调用EVP_EncryptFinal_ex完成其功能。该函数还调用EVP_EncryptInit_ex(ctx,NULL,NULL,NULL,NULL)函数对ctx结构再次进行了初始化。成功返回1，否则返回0。</span></span><br></pre></td></tr></table></figure>
<h3 id="读信"><a class="markdownIt-Anchor" href="#读信"></a> 读信</h3>
<p>本系列函数将公钥加密了的密钥加密出来，然后进行数据的解密。其定义的函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_OpenInit</span><span class="params">(EVP_CIPHER_CTX *ctx,EVP_CIPHER *type,<span class="keyword">unsigned</span> <span class="keyword">char</span> *ek, <span class="keyword">int</span> ekl,<span class="keyword">unsigned</span> <span class="keyword">char</span> *iv,EVP_PKEY *priv)</span></span>; <span class="comment">//该函数初始化一个用来加密数据的ctx结构。它首先使用参数priv指定的私钥解密参数ek里面长度为ekl字节的加密密钥。然后用此密钥与参数iv指定的初始化向量初始化EVP_CIPHER_CTX。如果参数type设定的加密算法长度是可变的，那么密钥长度就会被设置为解密得到的密钥的长度；如果加密算法长度是固定的，那么得到的解密密钥的长度就必须跟固定算法长度相同才行。成功执行返回密钥的长度，否则返回0。 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVP_OpenUpdate(a,b,c,d,e) EVP_DecryptUpdate(a,b,c,d,e)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_OpenUpdate</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> *outl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span></span>; <span class="comment">//功能和使用方法与EVP_DecryptUpdate相同</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_OpenFinal</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out,<span class="keyword">int</span> *outl)</span></span>; <span class="comment">//调用EVP_DecryptFinal_ex完成了其功能，本函数还调用EVP_DecryptInit_ex(ctx,NULL,NULL,NULL,NULL)再次进行了初始化工作。成功执行返回1，否则返回0。</span></span><br></pre></td></tr></table></figure>
<h3 id="代码示例"><a class="markdownIt-Anchor" href="#代码示例"></a> 代码示例</h3>
<h4 id="写信-2"><a class="markdownIt-Anchor" href="#写信-2"></a> 写信</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">envelope_seal</span><span class="params">(EVP_PKEY **pub_key, <span class="keyword">unsigned</span> <span class="keyword">char</span> *plaintext, <span class="keyword">int</span> plaintext_len,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> <span class="keyword">char</span> **encrypted_key, <span class="keyword">int</span> *encrypted_key_len, <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *ciphertext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	EVP_CIPHER_CTX *ctx;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ciphertext_len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Create and initialise the context */</span></span><br><span class="line">	<span class="keyword">if</span>(!(ctx = EVP_CIPHER_CTX_new())) handleErrors();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialise the envelope seal operation. This operation generates</span></span><br><span class="line"><span class="comment">	 * a key for the provided cipher, and then encrypts that key a number</span></span><br><span class="line"><span class="comment">	 * of times (one for each public key provided in the pub_key array). In</span></span><br><span class="line"><span class="comment">	 * this example the array size is just one. This operation also</span></span><br><span class="line"><span class="comment">	 * generates an IV and places it in iv. */</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span> != EVP_SealInit(ctx, EVP_aes_256_cbc(), encrypted_key,</span><br><span class="line">		encrypted_key_len, iv, pub_key, <span class="number">1</span>))</span><br><span class="line">		handleErrors();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Provide the message to be encrypted, and obtain the encrypted output.</span></span><br><span class="line"><span class="comment">	 * EVP_SealUpdate can be called multiple times if necessary</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span> != EVP_SealUpdate(ctx, ciphertext, &amp;len, plaintext, plaintext_len))</span><br><span class="line">		handleErrors();</span><br><span class="line">	ciphertext_len = len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Finalise the encryption. Further ciphertext bytes may be written at</span></span><br><span class="line"><span class="comment">	 * this stage.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span> != EVP_SealFinal(ctx, ciphertext + len, &amp;len)) handleErrors();</span><br><span class="line">	ciphertext_len += len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Clean up */</span></span><br><span class="line">	EVP_CIPHER_CTX_free(ctx);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ciphertext_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读信-2"><a class="markdownIt-Anchor" href="#读信-2"></a> 读信</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">envelope_open</span><span class="params">(EVP_PKEY *priv_key, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ciphertext, <span class="keyword">int</span> ciphertext_len,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *encrypted_key, <span class="keyword">int</span> encrypted_key_len, <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *plaintext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	EVP_CIPHER_CTX *ctx;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> plaintext_len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Create and initialise the context */</span></span><br><span class="line">	<span class="keyword">if</span>(!(ctx = EVP_CIPHER_CTX_new())) handleErrors();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialise the decryption operation. The asymmetric private key is</span></span><br><span class="line"><span class="comment">	 * provided and priv_key, whilst the encrypted session key is held in</span></span><br><span class="line"><span class="comment">	 * encrypted_key */</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span> != EVP_OpenInit(ctx, EVP_aes_256_cbc(), encrypted_key,</span><br><span class="line">		encrypted_key_len, iv, priv_key))</span><br><span class="line">		handleErrors();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Provide the message to be decrypted, and obtain the plaintext output.</span></span><br><span class="line"><span class="comment">	 * EVP_OpenUpdate can be called multiple times if necessary</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span> != EVP_OpenUpdate(ctx, plaintext, &amp;len, ciphertext, ciphertext_len))</span><br><span class="line">		handleErrors();</span><br><span class="line">	plaintext_len = len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Finalise the decryption. Further plaintext bytes may be written at</span></span><br><span class="line"><span class="comment">	 * this stage.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span> != EVP_OpenFinal(ctx, plaintext + len, &amp;len)) handleErrors();</span><br><span class="line">	plaintext_len += len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Clean up */</span></span><br><span class="line">	EVP_CIPHER_CTX_free(ctx);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> plaintext_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ssl通信"><a class="markdownIt-Anchor" href="#ssl通信"></a> SSL通信</h1>
<p>下面的代码为服务器和客户端建立SSL连接的代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><span class="line">ssl-server.c:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/ssl.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/err.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXBUF 1024 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * *argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd, new_fd;</span><br><span class="line">    <span class="keyword">socklen_t</span> len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">my_addr</span>, <span class="title">their_addr</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> myport, lisnum;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXBUF + <span class="number">1</span>];</span><br><span class="line">    SSL_CTX * ctx;</span><br><span class="line">    <span class="comment">//指定监听端口</span></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>]) </span><br><span class="line">    &#123;</span><br><span class="line">        myport = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        myport = <span class="number">8888</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最大客户端连接数</span></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">2</span>]) </span><br><span class="line">    &#123;</span><br><span class="line">        lisnum = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        lisnum = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* SSL 库初始化*/</span></span><br><span class="line">    SSL_library_init();</span><br><span class="line">    <span class="comment">/* 载入所有SSL 算法*/</span></span><br><span class="line">    OpenSSL_add_all_algorithms();</span><br><span class="line">    <span class="comment">/* 载入所有SSL 错误消息*/</span></span><br><span class="line">    SSL_load_error_strings();</span><br><span class="line">    <span class="comment">/* 以SSL V2 和V3 标准兼容方式产生一个SSL_CTX ，即SSL Content Text */</span></span><br><span class="line">    ctx = SSL_CTX_new(SSLv23_server_method());</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    也可以用SSLv2_server_method() 或SSLv3_server_method() 单独表示V2 或V3标准</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        ERR_print_errors_fp(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 载入用户的数字证书， 此证书用来发送给客户端。证书里包含有公钥*/</span></span><br><span class="line">    <span class="keyword">if</span> (SSL_CTX_use_certificate_file(ctx, argv[<span class="number">4</span>], SSL_FILETYPE_PEM) &lt;= <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        ERR_print_errors_fp(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 载入用户私钥*/</span></span><br><span class="line">    <span class="keyword">if</span> (SSL_CTX_use_PrivateKey_file(ctx, argv[<span class="number">5</span>], SSL_FILETYPE_PEM) &lt;= <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        ERR_print_errors_fp(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 检查用户私钥是否正确*/</span></span><br><span class="line">    <span class="keyword">if</span> (!SSL_CTX_check_private_key(ctx)) </span><br><span class="line">    &#123;</span><br><span class="line">        ERR_print_errors_fp(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 开启一个socket 监听*/</span></span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket created\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    bzero( &amp;my_addr, <span class="keyword">sizeof</span>(my_addr));</span><br><span class="line">    my_addr.sin_family = PF_INET;</span><br><span class="line">    my_addr.sin_port = htons(myport);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置监听的IP</span></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">3</span>]) </span><br><span class="line">    &#123;</span><br><span class="line">        my_addr.sin_addr.s_addr = inet_addr(argv[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果用户没有指定监听端口，则默认监听0.0.0.0(任意IP)</span></span><br><span class="line">        my_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd, (struct sockaddr * ) &amp;my_addr, <span class="keyword">sizeof</span>(struct sockaddr)) == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;binded\n&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (listen(sockfd, lisnum) == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;begin listen\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        SSL * ssl;</span><br><span class="line">        len = <span class="keyword">sizeof</span>(struct sockaddr);</span><br><span class="line">        <span class="comment">/* 等待客户端连上来*/</span></span><br><span class="line">        <span class="keyword">if</span> ((new_fd = accept(sockfd, (struct sockaddr * ) &amp; their_addr, &amp;len)) == <span class="number">-1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(errno);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server: got connection from %s, port %d, socket %d\n&quot;</span>, inet_ntoa(their_addr.sin_addr), ntohs(their_addr.sin_port), new_fd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 基于ctx 产生一个新的SSL */</span></span><br><span class="line">        ssl = SSL_new(ctx);</span><br><span class="line">        <span class="comment">/* 将连接用户的socket 加入到SSL */</span></span><br><span class="line">        SSL_set_fd(ssl, new_fd);</span><br><span class="line">        <span class="comment">/* 建立SSL 连接*/</span></span><br><span class="line">        <span class="keyword">if</span> (SSL_accept(ssl) == <span class="number">-1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            close(new_fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 开始处理每个新连接上的数据收发*/</span></span><br><span class="line">        bzero(buf, MAXBUF + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, <span class="string">&quot;server-&gt;client&quot;</span>);</span><br><span class="line">        <span class="comment">/* 发消息给客户端*/</span></span><br><span class="line">        len = SSL_write(ssl, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;消息&#x27;%s&#x27;发送失败！错误代码是%d，错误信息是&#x27;%s&#x27;\n&quot;</span>, buf, errno, strerror(errno));</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;消息&#x27;%s&#x27;发送成功，共发送了%d 个字节！\n&quot;</span>, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        bzero(buf, MAXBUF + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* 接收客户端的消息*/</span></span><br><span class="line">        len = SSL_read(ssl, buf, MAXBUF);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;接收消息成功:&#x27;%s&#x27;，共%d 个字节的数据\n&quot;</span>, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;消息接收失败！错误代码是%d，错误信息是&#x27;%s&#x27;\n&quot;</span>, errno, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 处理每个新连接上的数据收发结束*/</span></span><br><span class="line">        finish:</span><br><span class="line">        <span class="comment">/* 关闭SSL 连接*/</span></span><br><span class="line">        SSL_shutdown(ssl);</span><br><span class="line">        <span class="comment">/* 释放SSL */</span></span><br><span class="line">        SSL_free(ssl);</span><br><span class="line">        <span class="comment">/* 关闭socket */</span></span><br><span class="line">        close(new_fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 关闭监听的socket */</span></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="comment">/* 释放CTX */</span></span><br><span class="line">    SSL_CTX_free(ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ssl-client.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;resolv.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/ssl.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/err.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXBUF 1024 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowCerts</span><span class="params">(SSL * ssl)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X509 * cert;</span><br><span class="line">    <span class="keyword">char</span> * line;</span><br><span class="line">    cert = SSL_get_peer_certificate(ssl);</span><br><span class="line">    <span class="keyword">if</span> (cert != <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数字证书信息:\n&quot;</span>);</span><br><span class="line">        line = X509_NAME_oneline(X509_get_subject_name(cert), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;证书: %s\n&quot;</span>, line);</span><br><span class="line">        <span class="built_in">free</span>(line);</span><br><span class="line">        line = X509_NAME_oneline(X509_get_issuer_name(cert), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;颁发者: %s\n&quot;</span>, line);</span><br><span class="line">        <span class="built_in">free</span>(line);</span><br><span class="line">        X509_free(cert);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无证书信息！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * *argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd, len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dest</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buffer[MAXBUF + <span class="number">1</span>];</span><br><span class="line">    SSL_CTX * ctx;</span><br><span class="line">    SSL * ssl;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;参数格式错误！正确用法如下：\n\t\t%s IP 地址端口\n\t 比如:\t%s 127.0.0.1 80\n 此程序用来从某个IP 地址的服务器某个端口接收最多MAXBUF 个字节的消息&quot;</span>, argv[<span class="number">0</span>], argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* SSL 库初始化*/</span></span><br><span class="line">    SSL_library_init();</span><br><span class="line">    <span class="comment">/* 载入所有SSL 算法*/</span></span><br><span class="line">    OpenSSL_add_all_algorithms();</span><br><span class="line">    <span class="comment">/* 载入所有SSL 错误消息*/</span></span><br><span class="line">    SSL_load_error_strings();</span><br><span class="line">    <span class="comment">/* 以SSL V2 和V3 标准兼容方式产生一个SSL_CTX ，即SSL Content Text */</span></span><br><span class="line">    ctx = SSL_CTX_new(SSLv23_client_method());</span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        ERR_print_errors_fp(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 创建一个socket 用于tcp 通信*/</span></span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;socket created\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 初始化服务器端（对方）的地址和端口信息*/</span></span><br><span class="line">    bzero( &amp;dest, <span class="keyword">sizeof</span>(dest));</span><br><span class="line">    dest.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//设置连接的端口</span></span><br><span class="line">    dest.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    <span class="comment">//设置连接的IP地址</span></span><br><span class="line">    <span class="keyword">if</span> (inet_aton(argv[<span class="number">1</span>], (struct in_addr * ) &amp;dest.sin_addr.s_addr) == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address created\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 连接服务器*/</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (struct sockaddr * ) &amp;dest, <span class="keyword">sizeof</span>(dest)) != <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Connect &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server connected\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 基于ctx 产生一个新的SSL */</span></span><br><span class="line">    ssl = SSL_new(ctx);</span><br><span class="line">    <span class="comment">/* 将新连接的socket 加入到SSL */</span></span><br><span class="line">    SSL_set_fd(ssl, sockfd);</span><br><span class="line">    <span class="comment">/* 建立SSL 连接*/</span></span><br><span class="line">    <span class="keyword">if</span> (SSL_connect(ssl) == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        ERR_print_errors_fp(<span class="built_in">stderr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connected with %s encryption\n&quot;</span>, SSL_get_cipher(ssl));</span><br><span class="line">        ShowCerts(ssl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 接收对方发过来的消息，最多接收MAXBUF 个字节*/</span></span><br><span class="line">    bzero(buffer, MAXBUF + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 接收服务器来的消息*/</span></span><br><span class="line">    len = SSL_read(ssl, buffer, MAXBUF);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接收消息成功:&#x27;%s&#x27;，共%d 个字节的数据\n&quot;</span>, buffer, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;消息接收失败！错误代码是%d，错误信息是&#x27;%s&#x27;\n&quot;</span>, errno, strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> finish;</span><br><span class="line">    &#125;</span><br><span class="line">    bzero(buffer, MAXBUF + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, <span class="string">&quot;from client-&gt;server&quot;</span>);</span><br><span class="line">    <span class="comment">/* 发消息给服务器*/</span></span><br><span class="line">    len = SSL_write(ssl, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;消息&#x27;%s&#x27;发送失败！错误代码是%d，错误信息是&#x27;%s&#x27;\n&quot;</span>, buffer, errno, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;消息&#x27;%s&#x27;发送成功，共发送了%d 个字节！\n&quot;</span>, buffer, len);</span><br><span class="line">    &#125;</span><br><span class="line">    finish:</span><br><span class="line">    <span class="comment">/* 关闭连接*/</span></span><br><span class="line">    SSL_shutdown(ssl);</span><br><span class="line">    SSL_free(ssl);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    SSL_CTX_free(ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>usage:</p>
<ol>
<li>程序中用到的包含公钥的服务端证书cacert.pem和服务端私钥文件privkey.pem需要使用如下方式生成：<br />
openssl genrsa -out privkey.pem 2048<br />
openssl req -new -x509 -key privkey.pem -out cacert.pem -days 1095</li>
<li>编译程序用下列命令：<br />
gcc -Wall ssl-client.c -o client -lssl<br />
gcc -Wall ssl-server.c -o server -lssl</li>
<li>运行程序用如下命令：<br />
./server 8888 3 127.0.0.1 cacert.pem privkey.pem<br />
./client 127.0.0.1 8888</li>
</ol>
<h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1>
<p>不同的BIO_METHOD对应的type取值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#define BIO_TYPE_NONE 0</span><br><span class="line">#define BIO_TYPE_MEM (1|0x0400)</span><br><span class="line">#define BIO_TYPE_FILE (2|0x0400)</span><br><span class="line">#define BIO_TYPE_FD (4|0x0400|0x0100)</span><br><span class="line">#define BIO_TYPE_SOCKET (5|0x0400|0x0100)</span><br><span class="line">#define BIO_TYPE_NULL (6|0x0400)</span><br><span class="line">#define BIO_TYPE_SSL (7|0x0200)</span><br><span class="line">#define BIO_TYPE_MD (8|0x0200)</span><br><span class="line">#define BIO_TYPE_BUFFER (9|0x0200)</span><br><span class="line">#define BIO_TYPE_CIPHER (10|0x0200)</span><br><span class="line">#define BIO_TYPE_BASE64 (11|0x0200)</span><br><span class="line">#define BIO_TYPE_CONNECT (12|0x0400|0x0100)</span><br><span class="line">#define BIO_TYPE_ACCEPT (13|0x0400|0x0100)</span><br><span class="line">#define BIO_TYPE_PROXY_CLIENT (14|0x0200)</span><br><span class="line">#define BIO_TYPE_PROXY_SERVER (15|0x0200)</span><br><span class="line">#define BIO_TYPE_NBIO_TEST (16|0x0200)</span><br><span class="line">#define BIO_TYPE_NULL_FILTER (17|0x0200)</span><br><span class="line">#define BIO_TYPE_BER (18|0x0200)</span><br><span class="line">#define BIO_TYPE_BIO (19|0x0400)</span><br><span class="line">#define BIO_TYPE_DESCRIPTOR 0x0100</span><br><span class="line">#define BIO_TYPE_FILTER 0x0200</span><br><span class="line">#define BIO_TYPE_SOURCE_SINK 0x0400</span><br></pre></td></tr></table></figure>
<p>BIO的控制函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"><span class="comment">//最底层BIO控制函数，支持不同的命令输入从而产生不同的功能，一般无需调用</span></span><br><span class="line"><span class="function"><span class="keyword">long</span>   <span class="title">BIO_ctrl</span><span class="params">(BIO *bp,<span class="keyword">int</span> cmd,<span class="keyword">long</span> larg,<span class="keyword">void</span> *parg)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//上层BIO控制函数</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>*  <span class="title">BIO_ptr_ctrl</span><span class="params">(BIO *bp,<span class="keyword">int</span> cmd,<span class="keyword">long</span> larg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span>   <span class="title">BIO_int_ctrl</span><span class="params">(BIO *bp,<span class="keyword">int</span> cmd,<span class="keyword">long</span> larg,<span class="keyword">int</span> iarg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最上层BIO控制函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">BIO_reset</span><span class="params">(BIO *b)</span></span>; <span class="comment">//将BIO状态初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">BIO_seek</span><span class="params">(BIO *b, <span class="keyword">int</span> ofs)</span></span>; <span class="comment">//将文件相关的BIO的文件指针设置到距离开始位置ofs字节的位置上</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">BIO_tell</span><span class="params">(BIO *b)</span></span>; <span class="comment">//返回文件相关BIO的当前文件指针位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">BIO_flush</span><span class="params">(BIO *b)</span></span>; <span class="comment">//将BIO内部缓冲区的数据写出</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">BIO_eof</span><span class="params">(BIO *b)</span></span>; <span class="comment">//如果BIO读取到EOF返回1，否则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">BIO_set_close</span><span class="params">(BIO *b,<span class="keyword">long</span> flag)</span></span>; <span class="comment">//设置BIO的关闭标志</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">BIO_get_close</span><span class="params">(BIO *b)</span></span>; <span class="comment">//读取BIO的关闭标志</span></span><br><span class="line"><span class="comment">//下面四个函数都用于得到BIO中读缓存或写缓存中字符的数目</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">BIO_pending</span><span class="params">(BIO *b)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">BIO_wpending</span><span class="params">(BIO *b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">BIO_ctrl_pending</span><span class="params">(BIO *b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">BIO_ctrl_wpending</span><span class="params">(BIO *b)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//最上层BIO控制函数的宏定义方式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_reset(b)       (int)BIO_ctrl(b,BIO_CTRL_RESET,0,NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_seek(b,ofs)    (int)BIO_ctrl(b,BIO_C_FILE_SEEK,ofs,NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_tell(b)        (int)BIO_ctrl(b,BIO_C_FILE_TELL,0,NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_flush(b)       (int)BIO_ctrl(b,BIO_CTRL_FLUSH,0,NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_eof(b)         (int)BIO_ctrl(b,BIO_CTRL_EOF,0,NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_set_close(b,c) (int)BIO_ctrl(b,BIO_CTRL_SET_CLOSE,(c),NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_get_close(b)   (int)BIO_ctrl(b,BIO_CTRL_GET_CLOSE,0,NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_pending(b)     (int)BIO_ctrl(b,BIO_CTRL_PENDING,0,NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_wpending(b)    (int)BIO_ctrl(b,BIO_CTRL_WPENDING,0,NULL)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最底层BIO回调函数控制函数，一般不需要调用。</span></span><br><span class="line"><span class="function"><span class="keyword">long</span>   <span class="title">BIO_callback_ctrl</span><span class="params">(BIO *b, <span class="keyword">int</span> cmd, <span class="keyword">void</span> (*fp)(struct bio_st *, <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>, <span class="keyword">long</span>, <span class="keyword">long</span>))</span></span>;</span><br><span class="line"><span class="comment">//上层BIO回调函数控制函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_set_callback(b,cb)      ((b)-&gt;callback=(cb)) <span class="comment">//设置callback函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_get_callback(b)         ((b)-&gt;callback) <span class="comment">//返回callback函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_set_callback_arg(b,arg) ((b)-&gt;cb_arg=(char *)(arg)) <span class="comment">//设置callback函数的参数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_get_callback_arg(b)     ((b)-&gt;cb_arg) <span class="comment">//得到callback函数的参数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其中，callback函数本身的声明在BIO结构体中。callback函数非常重要，许多控制功能需要用它来协助完成</span></span><br><span class="line"><span class="comment">/*函数参数的解释：</span></span><br><span class="line"><span class="comment">	b：callback函数对应的BIO</span></span><br><span class="line"><span class="comment">	oper：设置BIO将要执行的操作</span></span><br><span class="line"><span class="comment">	argp，argi，argl：根据oper定义操作的不同而不同，是相应操作中要使用到的参数</span></span><br><span class="line"><span class="comment">	retvalue：默认的callback函数返回值*/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="title">callback</span><span class="params">(BIO *b, <span class="keyword">int</span> oper, <span class="keyword">const</span> <span class="keyword">char</span> *argp,<span class="keyword">int</span> argi, <span class="keyword">long</span> argl, <span class="keyword">long</span> retvalue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此外，还有一个用于调试目的的函数，其声明如下：</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">BIO_debug_callback</span><span class="params">(BIO *bio,<span class="keyword">int</span> cmd,<span class="keyword">const</span> <span class="keyword">char</span> *argp,<span class="keyword">int</span> argi,<span class="keyword">long</span> argl,<span class="keyword">long</span> ret)</span></span>;</span><br></pre></td></tr></table></figure>
<p>bio_type的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#define BIO_TYPE_NONE 0</span><br><span class="line">#define BIO_TYPE_MEM (1|0x0400)</span><br><span class="line">#define BIO_TYPE_FILE (2|0x0400)</span><br><span class="line">#define BIO_TYPE_FD (4|0x0400|0x0100)</span><br><span class="line">#define BIO_TYPE_SOCKET (5|0x0400|0x0100)</span><br><span class="line">#define BIO_TYPE_NULL (6|0x0400)</span><br><span class="line">#define BIO_TYPE_SSL (7|0x0200)</span><br><span class="line">#define BIO_TYPE_MD (8|0x0200)</span><br><span class="line">#define BIO_TYPE_BUFFER (9|0x0200)</span><br><span class="line">#define BIO_TYPE_CIPHER (10|0x0200)</span><br><span class="line">#define BIO_TYPE_BASE64 (11|0x0200)</span><br><span class="line">#define BIO_TYPE_CONNECT (12|0x0400|0x0100)</span><br><span class="line">#define BIO_TYPE_ACCEPT (13|0x0400|0x0100)</span><br><span class="line">#define BIO_TYPE_PROXY_CLIENT (14|0x0200)</span><br><span class="line">#define BIO_TYPE_PROXY_SERVER (15|0x0200)</span><br><span class="line">#define BIO_TYPE_NBIO_TEST (16|0x0200)</span><br><span class="line">#define BIO_TYPE_NULL_FILTER (17|0x0200)</span><br><span class="line">#define BIO_TYPE_BER (18|0x0200)</span><br><span class="line">#define BIO_TYPE_BIO (19|0x0400)</span><br><span class="line"></span><br><span class="line">#define BIO_TYPE_DESCRIPTOR 0x0100</span><br><span class="line">#define BIO_TYPE_FILTER 0x0200</span><br><span class="line">#define BIO_TYPE_SOURCE_SINK 0x0400</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3pob3V5b25ndGFvL29wZW5zc2wtaG93dG8=">https://github.com/zhouyongtao/openssl-howto<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cub3BlbnNzbC5vcmcvZG9jcy9tYW4xLjEuMS9tYW43Lw==">https://www.openssl.org/docs/man1.1.1/man7/<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW5vL29wZW5zc2wtZXhhbXBsZXMvYmxvYi9tYXN0ZXIvbGlua3MubWQ=">https://github.com/theno/openssl-examples/blob/master/links.md<i class="fa fa-external-link-alt"></i></span></li>
<li>OpenSSL编程 赵春平</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW8yMDA4MTIyOC9hcnRpY2xlL2RldGFpbHMvNzcxOTM3Mjkv">https://blog.csdn.net/liao20081228/article/details/77193729/<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW8yMDA4MTIyOC9hcnRpY2xlL2RldGFpbHMvNzYyODU4OTY=">https://blog.csdn.net/liao20081228/article/details/76285896<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93aWtpLm9wZW5zc2wub3JnL2luZGV4LnBocC9FVlA=">https://wiki.openssl.org/index.php/EVP<i class="fa fa-external-link-alt"></i></span></li>
</ol>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Yufei Luo
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://lyf35.github.io/2020/10/15/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8-OpenSSL%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E6%91%98%E5%BD%95%EF%BC%89/" title="信息安全-OpenSSL的基本使用（摘录）">http://lyf35.github.io/2020/10/15/信息安全-OpenSSL的使用（摘录）/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/" rel="tag"><i class="fa fa-tag"></i> 信息安全</a>
              <a href="/tags/OpenSSL/" rel="tag"><i class="fa fa-tag"></i> OpenSSL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9F%BA%E4%BA%8E%E7%A1%AC%E4%BB%B6%E5%8E%9F%E7%90%86%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96/" rel="prev" title="计算机组成原理-基于硬件原理的程序优化">
      <i class="fa fa-chevron-left"></i> 计算机组成原理-基于硬件原理的程序优化
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-CPU%E8%99%9A%E6%8B%9F%E5%8C%96/" rel="next" title="操作系统-CPU虚拟化">
      操作系统-CPU虚拟化 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yufei Luo</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.6m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">23:42</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动
  </div>

        






<script data-pjax>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"ypNNXSdcGIIoldC5BBmViS2g-gzGzoHsz","app_key":"0TDwohU7eO4yHTn4tley8PtE","server_url":"https://leancloud.cn/dashboard/data.html?appid=ypNNXSdcGIIoldC5BBmViS2g-gzGzoHsz#/","security":false};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/next-theme/pjax@0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  
  <script data-pjax>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>









<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>


    <div class="pjax">
  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">
  <script src="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css">


  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4dcdc02d24075b0e9d3a',
      clientSecret: '53cf2cb8b89b9d4bba922bb19bda1290f0d0bf95',
      repo        : 'lyf35.github.io',
      owner       : 'lyf35',
      admin       : ['lyf35'],
      id          : 'b92f30dcc0376c41f0a9f75bbefa1051',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
