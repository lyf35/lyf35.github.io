<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">
  <link rel="manifest" href="/images/site.webmanifest">
  <meta name="msapplication-config" content="/images/browserconfig.xml">
  <meta name="msvalidate.01" content="<meta name="msvalidate.01" content="5D3796A5DDB32CC875380613FB613833" />">
  <meta name="baidu-site-verification" content="<meta name="baidu-site-verification" content="kewHZtFYQk" />">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Helvetica:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-flat-top.min.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lyf35.github.io","root":"/","scheme":"Pisces","version":"8.0.0-rc.5","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="简介 UNIX 系统上各种通信和同步工具可以根据功能分成三类：  通信：这些工具关注进程之间的数据交换。 同步：这些进程关注进程和线程操作之间的同步。 信号：尽管信号的主要作用并不在此，但在特定场景下仍然可以将它作为一种同步技术。更罕见的是信号还可以作为一种通信技术：信号编号本身是一种形式的信息，并且可以在实时信号上绑定数据（一个整数或指针）。  这些工具的分类如下图所示：  通常使用通用术语进">
<meta property="og:type" content="website">
<meta property="og:title" content="Yufei Luo&#39;s Blog">
<meta property="og:url" content="http://lyf35.github.io/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Linux/Linux/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.html">
<meta property="og:site_name" content="Yufei Luo&#39;s Blog">
<meta property="og:description" content="简介 UNIX 系统上各种通信和同步工具可以根据功能分成三类：  通信：这些工具关注进程之间的数据交换。 同步：这些进程关注进程和线程操作之间的同步。 信号：尽管信号的主要作用并不在此，但在特定场景下仍然可以将它作为一种同步技术。更罕见的是信号还可以作为一种通信技术：信号编号本身是一种形式的信息，并且可以在实时信号上绑定数据（一个整数或指针）。  这些工具的分类如下图所示：  通常使用通用术语进">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://lyf35.github.io/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Linux/Linux/image-20210715103944465.png">
<meta property="og:image" content="http://lyf35.github.io/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Linux/Linux/image-20210715141636626.png">
<meta property="og:image" content="http://lyf35.github.io/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Linux/Linux/image-20210715141715046.png">
<meta property="og:image" content="http://lyf35.github.io/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Linux/Linux/image-20210715143528480.png">
<meta property="og:image" content="http://lyf35.github.io/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Linux/Linux/image-20210716155455960.png">
<meta property="og:image" content="http://lyf35.github.io/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Linux/Linux/image-20210719145219281.png">
<meta property="article:published_time" content="2021-08-01T14:38:05.197Z">
<meta property="article:modified_time" content="2021-08-01T14:38:05.197Z">
<meta property="article:author" content="Yufei Luo">
<meta property="article:tag" content="个人博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://lyf35.github.io/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Linux/Linux/image-20210715103944465.png">

<link rel="canonical" href="http://lyf35.github.io/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Linux/Linux/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title> | Yufei Luo's Blog
</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
 <!--   <div class="headband"></div>-->

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Yufei Luo's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">But I was so much older then, I am younger than that now.</p>
      <img class="custom-logo-image" src="/images/logo.png" alt="Yufei Luo's Blog">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-计算机基础">

    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80" rel="section"><i class="fa fa-tags fa-fw"></i>计算机基础</a>

  </li>
        <li class="menu-item menu-item-机器学习">

    <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0" rel="section"><i class="fa fa-tags fa-fw"></i>机器学习</a>

  </li>
        <li class="menu-item menu-item-深度学习">

    <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0" rel="section"><i class="fa fa-tags fa-fw"></i>深度学习</a>

  </li>
        <li class="menu-item menu-item-工程实践">

    <a href="/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5" rel="section"><i class="fa fa-tags fa-fw"></i>工程实践</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text"> 简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E5%92%8Cfifo"><span class="nav-number">2.</span> <span class="nav-text"> 管道和FIFO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-number">2.2.</span> <span class="nav-text"> 创建与使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8Eshell%E5%91%BD%E4%BB%A4%E9%80%9A%E4%BF%A1"><span class="nav-number">2.3.</span> <span class="nav-text"> 与shell命令通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fifo"><span class="nav-number">2.4.</span> <span class="nav-text"> FIFO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E8%AF%AD%E4%B9%89"><span class="nav-number">2.5.</span> <span class="nav-text"> 读写语义</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#system-v-ipc"><span class="nav-number">3.</span> <span class="nav-text"> System V IPC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="nav-number">3.1.</span> <span class="nav-text"> 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">3.2.</span> <span class="nav-text"> 消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%88%96%E6%89%93%E5%BC%80"><span class="nav-number">3.2.1.</span> <span class="nav-text"> 创建或打开</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E4%BA%A4%E6%8D%A2"><span class="nav-number">3.2.2.</span> <span class="nav-text"> 消息交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%8E%A7%E5%88%B6"><span class="nav-number">3.2.3.</span> <span class="nav-text"> 消息队列控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.4.</span> <span class="nav-text"> 关联数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">3.2.5.</span> <span class="nav-text"> 缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">3.3.</span> <span class="nav-text"> 信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="nav-number">3.3.1.</span> <span class="nav-text"> 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%88%96%E6%89%93%E5%BC%80-2"><span class="nav-number">3.3.2.</span> <span class="nav-text"> 创建或打开</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">3.3.3.</span> <span class="nav-text"> 控制信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%85%B3%E8%81%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.4.</span> <span class="nav-text"> 信号量关联数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%93%8D%E4%BD%9C"><span class="nav-number">3.3.5.</span> <span class="nav-text"> 信号量操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="nav-number">3.3.6.</span> <span class="nav-text"> 缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">3.4.</span> <span class="nav-text"> 共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-4"><span class="nav-number">3.4.1.</span> <span class="nav-text"> 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%88%96%E6%89%93%E5%BC%80-3"><span class="nav-number">3.4.2.</span> <span class="nav-text"> 创建或打开</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">3.4.3.</span> <span class="nav-text"> 使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">3.4.4.</span> <span class="nav-text"> 控制操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%85%B3%E8%81%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.4.5.</span> <span class="nav-text"> 共享内存关联数据结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#posix-ipc"><span class="nav-number">4.</span> <span class="nav-text"> POSIX IPC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-5"><span class="nav-number">4.1.</span> <span class="nav-text"> 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-2"><span class="nav-number">4.2.</span> <span class="nav-text"> 消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%BC%80-%E5%85%B3%E9%97%AD%E5%92%8C%E6%96%AD%E5%BC%80"><span class="nav-number">4.2.1.</span> <span class="nav-text"> 打开、关闭和断开</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%89%B9%E6%80%A7"><span class="nav-number">4.2.2.</span> <span class="nav-text"> 消息队列特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%B6%88%E6%81%AF"><span class="nav-number">4.2.3.</span> <span class="nav-text"> 交换消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5"><span class="nav-number">4.2.4.</span> <span class="nav-text"> 消息通知</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#posix%E5%92%8Csystem-v%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%AF%94%E8%BE%83"><span class="nav-number">4.2.5.</span> <span class="nav-text"> POSIX和System V消息队列比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F-2"><span class="nav-number">4.3.</span> <span class="nav-text"> 信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="nav-number">4.3.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">4.3.2.</span> <span class="nav-text"> 命名信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%93%8D%E4%BD%9C-2"><span class="nav-number">4.3.3.</span> <span class="nav-text"> 信号量操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AA%E5%91%BD%E5%90%8D%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">4.3.4.</span> <span class="nav-text"> 未命名信号量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-2"><span class="nav-number">4.4.</span> <span class="nav-text"> 共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="nav-number">4.4.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.4.2.</span> <span class="nav-text"> 创建共享内存对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.4.3.</span> <span class="nav-text"> 删除共享内存对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#socket"><span class="nav-number">5.</span> <span class="nav-text"> SOCKET</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-6"><span class="nav-number">5.1.</span> <span class="nav-text"> 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">5.2.</span> <span class="nav-text"> 系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81socket"><span class="nav-number">5.3.</span> <span class="nav-text"> 流socket</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%A5socket"><span class="nav-number">5.4.</span> <span class="nav-text"> 数据报socket</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unix-domain"><span class="nav-number">5.5.</span> <span class="nav-text"> UNIX domain</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#internet-domain"><span class="nav-number">5.6.</span> <span class="nav-text"> Internet domain</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E7%94%A8%E6%B3%95"><span class="nav-number">5.7.</span> <span class="nav-text"> 其它用法</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yufei Luo"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Yufei Luo</p>
  <div class="site-description" itemprop="description">哪怕什么真理无穷，进一寸有进一寸的欢喜</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x5ZjM1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lyf35"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmx5ZjEyMzQwMDAwMDBAMTYzLmNvbQ==" title="E-Mail → mailto:lyf1234000000@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



      </section>
        <div class="back-to-top animated">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x5ZjM1" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        
  
  

        <div class="content page posts-expand">
          

    
    
    
    <div class="post-block" lang="zh-CN">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">
</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
          
            <li><a href="/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/">未完成的技术文档</a></li>
            <li><a href="/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Linux/">LINUX</a></li>
            <li><a href="/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Linux/Linux/">LINUX</a></li>
            <li>进程间通信</li>
          
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
          <h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<p>UNIX 系统上各种通信和同步工具可以根据功能分成三类：</p>
<ul>
<li>通信：这些工具关注进程之间的数据交换。</li>
<li>同步：这些进程关注进程和线程操作之间的同步。</li>
<li>信号：尽管信号的主要作用并不在此，但在特定场景下仍然可以将它作为一种同步技术。更罕见的是信号还可以作为一种通信技术：信号编号本身是一种形式的信息，并且可以在实时信号上绑定数据（一个整数或指针）。</li>
</ul>
<p>这些工具的分类如下图所示：</p>
<img data-src="image-20210715103944465.png" alt="image-20210715103944465" style="zoom:67%;" />
<p>通常使用通用术语进程间通信（IPC）指代所有这些工具。</p>
<h1 id="管道和fifo"><a class="markdownIt-Anchor" href="#管道和fifo"></a> 管道和FIFO</h1>
<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>管道可以用来在相关进程之间传递数据。FIFO 是管道概念的一个变体，它们之间的一个重要差别在于FIFO 可以用于任意进程间的通信。一个管道有如下几个特征：</p>
<ul>
<li>一个管道是一个字节流。从管道中读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是什么。此外，通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序与它们被写入管道的顺序是完全一样的。</li>
<li>如果试图从一个当前为空的管道中读取数据，将会被阻塞直到至少有一个字节被写入到管道中为止。如果管道的写入端被关闭了，那么从管道中读取数据的进程在读完管道中剩余的所有数据之后将会看到文件结束，即<code>read()</code>返回0</li>
<li>管道的数据传递方向是单向的，一端用于写入，另一端用于读取</li>
<li>如果多个进程写入同一个管道，那么如果它们在一个时刻写入的数据量不超过PIPE_BUF字节（Linux系统下这个值为4096），那么就可以确保写入的数据不会发生相互混合的情况。</li>
<li>管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的。一旦管道被填满之后，后续向该管道的写入操作就会被阻塞直到读者从管道中移除了一些数据为止。</li>
</ul>
<h2 id="创建与使用"><a class="markdownIt-Anchor" href="#创建与使用"></a> 创建与使用</h2>
<p><code>pipe</code>系统调用可以创建一个新的管道：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> filedes[<span class="number">2</span>])</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>如果调用成功，则会在数组<code>filedes</code>中返回两个打开的文件描述符，<code>filedes[0]</code>表示管道的读取端，<code>filedes[1]</code>表示管道的写入端。</p>
<p>与所有的文件描述符一样，可以使用<code>read</code>和<code>write</code>系统调用在管道上执行I/O操作。一旦向管道的写入端写入数据之后立即就能从管道的读取端读取数据。管道上的<code>read()</code>调用会读取的数据量为所请求的字节数与管道中当前存在的字节数两者之间较小的那个，而管道为空时则阻塞。也可以在管道上使用<code>stdio</code>函数（<code>printf()</code>、<code>scanf()</code>等），只需要首先使用<code>fdopen()</code>获取一个与<code>filedes</code>中的某个描述符对应的文件流即可。</p>
<p>由于子进程会继承父进程的文件描述符的副本，因此可以通过管道来实现相关进程之间的通信。相关进程指的是这些进程来自于同一个祖先进程，且管道由祖先进程所创建。这些进程必须关闭未使用的管道文件描述符，否则会导致出错。</p>
<p>当所有子进程都关闭了管道的写入端的文件描述符之后，父进程在管道上的<code>read()</code>就会结束并返回文件结束（0）。根据这一特性可以将管道作为一种进程同步的方法。这种方法可以同来协调一个进程的动作使之与多个其他（相关）进程匹配。当然，也可以使用其它的同步结构。</p>
<p>创建管道时，为管道两端分配文件描述符将会优先选择可用描述符中数值最小的，因此可以使用这一特性，将管道的输入和输出端绑定为进程的标准输入或输出。可以通过创建管道时先关闭标准输入/输出，或者是使用<code>dup2</code>来复制文件描述符。</p>
<h2 id="与shell命令通信"><a class="markdownIt-Anchor" href="#与shell命令通信"></a> 与shell命令通信</h2>
<p>管道的一个常见用途是执行shell命令，并读取其输出或向其发送一些输入。<code>popen</code>和<code>pclose</code>函数可以简化这一任务：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE* <span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* command, <span class="keyword">const</span> <span class="keyword">char</span>* mode)</span></span>; <span class="comment">//成功返回文件流，失败返回NULL，并设置errno表示失败原因</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE* stream)</span></span>; <span class="comment">//成功则返回子进程的结束状态，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>popen</code>函数创建一个管道，然后创建一个子进程来执行shell，而shell又创建了一个子进程来执行<code>command</code>字符串。<code>mode</code>参数是一个字符串，它确定调用进程是从管道中读取数据（<code>'r'</code>），也就是命令的输出被送入到管道的输入端；还是将数据写入到管道中（<code>'w'</code>），也就是命令的输入来自于调用进程。</p>
<p>使用<code>system()</code>时，shell命令的执行是被封装在单个函数调用中的；而使用<code>popen()</code>时，调用进程是与shell命令并行运行的，然后会调用<code>pclose()</code>。</p>
<h2 id="fifo"><a class="markdownIt-Anchor" href="#fifo"></a> FIFO</h2>
<p>从语义上来讲，FIFO 与管道类似，它们两者之间最大的差别在于FIFO 在文件系统中拥有一个名称，并且其打开方式与打开一个普通文件是一样的。这样就能够将FIFO 用于非相关进程之间的通信（如客户端和服务器）。</p>
<p>一旦打开了FIFO，就能在它上面使用与操作管道和其他文件的系统调用一样的I/O系统调用。与管道一样，FIFO 也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的名称也由此而来：先入先出。FIFO 有时候也被称为命名管道。</p>
<p>创建一个FIFO的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo [-m mode] pathname</span><br></pre></td></tr></table></figure>
<p>其中<code>pathname</code>指的是创建的FIFO的名称，<code>-m</code>选项用来指定权限<code>mode</code>（工作方式与<code>chmod</code>一样）</p>
<p>要在程序中创建一个FIFO，则可以使用<code>mkfifo()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">mode_t</span> mode)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>当一个进程打开一个FIFO的一端时，如果FIFO的另一端还没有被打开，那么该进程会被阻塞。但有些时候阻塞并不是期望的行为，而这可以通过在调用<code>open()</code>时指定O_NONBLOCK标记来实现。如果打开FIFO是为了写入，并且还没有打开FIFO的另一端来读取数据，那么<code>open()</code>调用会失败，并将<code>errno</code>设置为ENXIO。</p>
<h2 id="读写语义"><a class="markdownIt-Anchor" href="#读写语义"></a> 读写语义</h2>
<p>管道和FIFO上<code>read()</code>操作的语义可以总结为下表：</p>
<p><img data-src="image-20210715141636626.png" alt="image-20210715141636626" /></p>
<p><code>write()</code>操作的语义如下表：</p>
<p><img data-src="image-20210715141715046.png" alt="image-20210715141715046" /></p>
<h1 id="system-v-ipc"><a class="markdownIt-Anchor" href="#system-v-ipc"></a> System V IPC</h1>
<h2 id="简介-2"><a class="markdownIt-Anchor" href="#简介-2"></a> 简介</h2>
<p>System V IPC是首先在System V中被广泛使用的三种IPC机制的名称并且之后被移植到了大多数UNIX实现中以及被加入了各种标准中。System V IPC包括三种不同的进程间通信机制：消息队列、信号量和共享内存。System V IPC的编程接口可汇总为下表：</p>
<p><img data-src="image-20210715143528480.png" alt="image-20210715143528480" /></p>
<h2 id="消息队列"><a class="markdownIt-Anchor" href="#消息队列"></a> 消息队列</h2>
<h3 id="创建或打开"><a class="markdownIt-Anchor" href="#创建或打开"></a> 创建或打开</h3>
<p>使用<code>msgget()</code>系统调用可以创建一个新的消息队列，或者获得一个已有队列的标识符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>; <span class="comment">//成功则返回消息队列的编号，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>key</code>参数可以设置为IPC_PRIVATE，这样会创建一个新的IPC对象；或者是使用<code>ftok()</code>函数生成。<code>msgflg</code>参数可以为0，或者加上掩码IPC_CREAT（如果key不存在则创建新的消息队列）、IPC_EXCL（如果指定IPC_CREAT且key对应的队列已存在，则返回错误）。</p>
<h3 id="消息交换"><a class="markdownIt-Anchor" href="#消息交换"></a> 消息交换</h3>
<p>消息队列上的I/O操作可以使用下面的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span>* msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>; <span class="comment">//成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">ssizt_t</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span>* msgp, <span class="keyword">size_t</span> maxmsgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span>; <span class="comment">//成功返回读取的字节数，失败返回-1</span></span><br><span class="line"><span class="comment">//msgp参数通常写为如下的数据结构：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mymsg</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>msgsnd</code>系统调用向消息队列写入一条信息，<code>msqid</code>代表消息队列标识符，<code>msgp</code>为要发送的消息，<code>msgsz</code>为发送的消息长度，<code>msgflg</code>为位掩码，用于控制<code>msgsnd</code>的操作，目前只定义了IPC_NOWAIT这一个标记，代表执行非阻塞的发送操作。</p>
<p>向消息队列写入消息要求具备在该队列上的写权限。</p>
<p><code>msgrcv</code>系统调用从消息队列中读取（以及删除）一条消息，并将其内容复制到<code>msgp</code>指向的缓冲区，<code>maxmsgsz</code>代表<code>mtext</code>的最大长度。读取消息的顺序无需与消息被发送的一致。可以根据<code>mtype</code>字段的值来选择消息，而这个选择过程是由<code>msgtyp</code>参数来控制的：如果<code>msgtyp</code>等于0，则删除队列的第一条信息；如果大于0，则将队列中第一条<code>mtype</code>等于<code>msgtyp</code>的消息删除并返回给调用进程；如果小于0则将等待消息当成优先队列，返回<code>mtype</code>最小，且数值小于等于<code>msgtyp</code>绝对值的第一条消息。<code>msgflg</code>是一个位掩码，可以为IPC_NOWAIT、MSG_EXCEPT、MSG_NOERROR这三个掩码其中0个或多个的或运算。</p>
<h3 id="消息队列控制"><a class="markdownIt-Anchor" href="#消息队列控制"></a> 消息队列控制</h3>
<p><code>msgctl</code>系统调用可以控制消息队列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds* buf)</span></span>; <span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>msqid</code>代表要操作的消息队列；<code>cmd</code>指定队列上要执行的操作，它的取值为如下三个中的一个：</p>
<ul>
<li>IPC_RMID：立即删除消息队列对象及其关联的<code>msqid_ds</code>数据结构，队列中所有剩余消息丢失，所有被阻塞的读写进程会被唤醒</li>
<li>IPC_STAT：将与这个消息队列关联的<code>msqid_ds</code>数据结构的副本放到<code>buf</code>指向的缓冲区中</li>
<li>IPC_SET：使用<code>buf</code>指向的缓冲区提供的值更新与这个消息队列关联的<code>msqid_ds</code>数据结构中被选中的字段。</li>
</ul>
<h3 id="关联数据结构"><a class="markdownIt-Anchor" href="#关联数据结构"></a> 关联数据结构</h3>
<p>每个消息队列都有一个关联的<code>msqid_ds</code>数据结构，形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span> <span class="comment">//所有权和许可</span></span><br><span class="line">    <span class="keyword">time_t</span> msg_stime; <span class="comment">//创建队列时为0，后续每次调用msgsnd成功都会将其设置为当前时间</span></span><br><span class="line">    <span class="keyword">time_t</span> msg_rtime; <span class="comment">//创建队列时为0，后续每次调用msgrcv成功都会将其设置为当前时间</span></span><br><span class="line">    <span class="keyword">time_t</span> msg_ctime; <span class="comment">//创建消息队列，以及执行IPC_SET成功都会将其设置为当前时间 </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> __msg_cbytes; <span class="comment">//创建时为0，后续代表所有消息的mtext字段包含字节数总和</span></span><br><span class="line">    <span class="keyword">msgqnum_t</span> msg_qnum; <span class="comment">//创建时为0，后面代表队列的消息总数</span></span><br><span class="line">    <span class="keyword">msglen_t</span> msg_qbytes; <span class="comment">//mtext字段的字节总数上限</span></span><br><span class="line">    <span class="keyword">pid_t</span> msg_lspid; <span class="comment">//创建时为0，后面每次调用msgsnd成功会设置为调用进程的ID</span></span><br><span class="line">    <span class="keyword">pid_t</span> msg_lrpid; <span class="comment">//创建时为0，后面每次调用msgrcv成功会设置为调用进程的ID</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3>
<ol>
<li>消息队列是通过标识符引用的，而不是像大多数其他UNIX I/O机制那样使用文件描述符。因此无法使用基于文件描述符的I/O技术</li>
<li>使用键而不是文件名来标识消息队列，会增加额外的程序设计复杂性</li>
<li>消息队列无连接，内核不会维护引用队列的进程数</li>
<li>消息队列总数、消息大小以及单个队列的容量都有限制</li>
</ol>
<h2 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h2>
<h3 id="简介-3"><a class="markdownIt-Anchor" href="#简介-3"></a> 简介</h3>
<p>System V信号量不是用来在进程间传输数据的，而是用来同步进程的动作。信号量的一个常见用途是同步对一块共享内存的访问以防止出现一个进程在访问共享内存的同时另一个进程更新这块内存的情况。</p>
<p>一个信号量是一个由内核维护的整数，其值被限制为大于或等于0。在一个信号量上可以执行各种操作（即系统调用），包括：</p>
<ul>
<li>将信号量设置为一个绝对值</li>
<li>在信号量当前值的基础上加/减1</li>
<li>等待信号量的值等于0</li>
</ul>
<p>当减小一个信号量的值时，内核会将所有试图将信号量值降低到0之下的操作阻塞。如果信号量的当前值不为0，那么等待信号量的值等于0的调用进程将会发生阻塞。</p>
<p>使用System V 信号量的常规步骤如下。</p>
<ul>
<li>使用<code>semget()</code>创建或打开一个信号量集。</li>
<li>使用<code>semctl()</code> SETVAL或SETALL操作初始化集合中的信号量。（只有一个进程需要完成这个任务。</li>
<li>使用<code>semop()</code>操作信号量值。使用信号量的进程通常会使用这些操作来表示一种共享资源的获取和释放。</li>
<li>当所有进程都不再需要使用信号量集之后使用<code>semctl()</code> IPC_RMID 操作删除这个集合。（只有一个进程需要完成这个任务。）</li>
</ul>
<h3 id="创建或打开-2"><a class="markdownIt-Anchor" href="#创建或打开-2"></a> 创建或打开</h3>
<p><code>semget()</code>系统调用创建一个新信号量集，或者获取一个既有集合的标识符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg)</span></span>; <span class="comment">//成功返回信号量的标识符，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>key</code>参数可以设置为IPC_PRIVATE，这样会创建一个新的IPC对象；或者是使用<code>ftok()</code>函数生成。如果要创建一个新的信号量集，那么<code>nsem</code>参数会指定信号量的数量（必须大于0）；如果要获取一个既有集的标识符，则<code>nsem</code>参数需要小于或等于集合大小。<code>semflg</code>参数为一个位掩码，指定了施加于新信号量集之上的权限或需检查的一个既有集合的权限。</p>
<h3 id="控制信号量"><a class="markdownIt-Anchor" href="#控制信号量"></a> 控制信号量</h3>
<p><code>semctl()</code>系统调用在一个信号量集或集合中的单个信号量上执行各种控制操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, <span class="keyword">union</span> semun arg)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>semid</code>参数是操作所施加的信号量集的标识符。对于那些在单个信号量上执行的操作，<code>semnum</code>参数标识出了集合中的具体信号量。对于其他操作则会忽略这个参数，并且可以将其设置为0。<code>cmd</code>参数指定了需执行的操作。</p>
<p>第四个参数<code>arg</code>是一个<code>union</code>类型的变量，需要在程序中显式定义这个类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> semun&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span>* <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>* <span class="built_in">array</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__linux__)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>* __<span class="title">buf</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cmd</code>参数可以设置的值及其对应的操作如下：</p>
<ul>
<li>常规控制操作：
<ul>
<li>IPC_RMID：立即删除信号量集及其关联的<code>semid_ds</code>数据结构</li>
<li>IPC_STAT：在<code>arg.buf</code>指向的缓冲器中放置一份与这个信号量集相关联的<code>semid_ds</code>数据结构的副本</li>
<li>IPC_SET：使用<code>arg.buf</code>指向的缓冲器中的值来更新与信号量集关联的<code>semid_ds</code>数据结构中的字段</li>
</ul>
</li>
<li>获取和初始化信号量值
<ul>
<li>GETVAL：返回由<code>semid</code>指定的信号量中第<code>semnum</code>个信号量的值</li>
<li>SETVAL：将<code>semid</code>指定的信号量集中的第<code>semnum</code>个信号量的值初始化为<code>arg.val</code></li>
<li>GETALL：获取由<code>semid</code>指向的信号量集中所有信号量的值并将它们放在<code>arg.array</code>指向的数组中。程序员必须要确保该数组具备足够的空间。这个操作将忽略<code>semnum</code>参数</li>
<li>SETALL：使用<code>arg.array</code>指向的数组中的值初始化<code>semid</code>指向的集合中的所有信号量。这个操作将忽略<code>semnum</code>参数</li>
</ul>
</li>
<li>获取单个信号量的信息
<ul>
<li>GETPID：返回上一个在该信号量上执行<code>semop()</code>进程的ID</li>
<li>GETNCNT：返回正在等待信号量值增长的进程数</li>
<li>GETZCNT：返回正在等待信号量的值变为0的进程数</li>
</ul>
</li>
</ul>
<h3 id="信号量关联数据结构"><a class="markdownIt-Anchor" href="#信号量关联数据结构"></a> 信号量关联数据结构</h3>
<p>每个信号量集都有一个关联的<code>semid_ds</code>数据结构，其形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span> <span class="comment">//在创建信号量集时初始化这个子结构中的字段</span></span><br><span class="line">    <span class="keyword">time_t</span> sem_otime; <span class="comment">//在创建信号量集时会将这个字段设置为0，然后在每次成功的semop()调用或当信号量值因SEM_UNDO操作而发生变更时将这个字段设置为当前时间</span></span><br><span class="line">    <span class="keyword">time_t</span> sem_ctime; <span class="comment">//在创建信号量时以及每个成功的IPC_SET、SETALL和SETVAL操作执行完毕之后将这个字段设置为当前时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sem_nsems; <span class="comment">//在创建集合时将这个字段的值初始化为集合中信号量的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信号量操作"><a class="markdownIt-Anchor" href="#信号量操作"></a> 信号量操作</h3>
<p><code>semop</code>系统调用在<code>semid</code>标识的信号量集中的信号量上面执行一个或者多个操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf* sops, <span class="keyword">unsigned</span> <span class="keyword">int</span> nsops)</span></span>; <span class="comment">//返回0代表成功，-1代表失败</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semtimedop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf* sops, <span class="keyword">unsigned</span> <span class="keyword">int</span> nsops, struct timespec* timeout)</span></span>; <span class="comment">//可以指定调用阻塞的时间上限，返回0代表成功，-1代表失败</span></span><br></pre></td></tr></table></figure>
<p><code>sops</code>参数是一个指向数组的指针，数组中包含了需要执行的操作，<code>nsops</code>参数给出了数组的大小（数组至少需包含一个元素）。操作将会按照在数组中的顺序以原子的方式被执行。<code>sop</code>数组中的元素是形式如下的结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> sem_num; <span class="comment">//代表在哪个信号量上面执行操作</span></span><br><span class="line">    <span class="keyword">short</span> sem_op; <span class="comment">//大于0就把它的值加到信号量值；等于0则检查信号量确定它是否为0，不为0则阻塞；小于0就把信号量的值减去它，如果相减为负值则会一直阻塞直到操作之后不会出现负值</span></span><br><span class="line">    <span class="keyword">short</span> sem_flg; <span class="comment">//可以为IPC_NOWAIT和SEM_UNDO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果存在多个因减小一个信号量值而发生阻塞的进程，它们对该信号量减去的值是一样的，那么当条件允许时无法确定到底哪个进程会首先被允许执行操作。另一方面，如果多个因减小一个信号量值而发生阻塞的进程对该信号量减去的值是不同的，那么会按照先满足条件先服务的顺序来进行。</p>
<p>假设一个进程在调整完一个信号量值（如减小信号量值使之等于0）之后终止了，不管是有意终止还是意外终止。在默认情况下，信号量值将不会发生变化。这样就可能会给其他使用这个信号量的进程带来问题。为避免这种问题的发生，在通过<code>semop()</code>修改一个信号量值时可以使用SEM_UNDO标记。当指定这个标记时，内核会记录信号量操作的效果，然后在进程终止时撤销这个操作。不管进程是正常终止还是非正常终止，撤销操作都会发生。</p>
<h3 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2"></a> 缺点</h3>
<ul>
<li>信号量是通过标识符而不是大多数UNIX I/O 和IPC 所采用的文件描述符来引用的。这使得执行诸如同时等待一个信号量和文件描述符的输入之类的操作就会变得比较困难。</li>
<li>使用键而不是文件名来标识信号量增加了额外的编程复杂度。</li>
<li>创建和初始化信号量需要使用单独的系统调用意味着在一些情况下必须要做一些额外的编程工作来防止在初始化一个信号量时出现竞争条件。</li>
<li>内核不会维护引用一个信号量集的进程数量。这就给确定何时删除一个信号量集增加了难度，并且难以确保一个不再使用的信号量集会被删除。</li>
<li>System V 提供的编程接口过于复杂。在通常情况下，一个程序只会操作一个信号量。同时操作集合中多个信号量的能力有时侯是多余的。</li>
<li>信号量的操作存在诸多限制。这些限制是可配置的，但如果一个应用程序超出了默认限制的范围，那么在安装应用程序时就需要完成额外的工作。</li>
</ul>
<h2 id="共享内存"><a class="markdownIt-Anchor" href="#共享内存"></a> 共享内存</h2>
<h3 id="简介-4"><a class="markdownIt-Anchor" href="#简介-4"></a> 简介</h3>
<p>共享内存允许两个或多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会成为一个进程用户空间内存的一部分，因此这种IPC机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。</p>
<p>另一方面，共享内存这种IPC机制不由内核控制意味着通常需要使用某些同步方法，使得进程不会出现同时访问共享内存的情况。</p>
<p>为使用一个共享内存段通常需要执行下面的步骤。</p>
<ul>
<li>调用 <code>shmget()</code>创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。</li>
<li>使用<code>shmat()</code>来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。</li>
<li>此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由<code>shmat()</code>调用返回的<code>addr</code> 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。</li>
<li>调用<code>shmdt()</code>来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步。</li>
<li>调用<code>shmctl()</code>来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会被销毁。只有一个进程需要执行这一步。</li>
</ul>
<h3 id="创建或打开-3"><a class="markdownIt-Anchor" href="#创建或打开-3"></a> 创建或打开</h3>
<p><code>shmget()</code>系统调用创建一个新的共享内存段或者获取一个既有段的标识符，新创建的内存段中，所有内容会被初始化为0：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>; <span class="comment">//成功则返回共享内存段的标识符，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>key</code>参数是IPC_PRIVATE值或由<code>ftok()</code>生成的键。<code>size</code>代表要分配的字节数，会被提升到最近的系统分页大小的整数倍。<code>shmflg</code>参数用于控制<code>shmget</code>的操作，可以为IPC_CREAT、IPC_EXCL、SHM_HUGETLB（允许使用巨页的共享内存段）、SHM_NORESERVE这四个值进行或运算的结果。</p>
<h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3>
<p><code>shmat()</code>系统调用可以将<code>shmid</code>标识的共享内存段附加到调用进程的虚拟地址空间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span>* shmaddr, <span class="keyword">int</span> shmflg)</span></span>; <span class="comment">//成功则返回共享内存段的地址，失败返回NULL</span></span><br></pre></td></tr></table></figure>
<p><code>shmaddr</code>和<code>shmflg</code>位掩码参数中SHM_RND位的设置控制着段如何被附加上去：</p>
<ul>
<li>如果<code>shmaddr</code>为NULL，那么段会被附加到内核选择的一个合适的地址</li>
<li>如果<code>shmaddr</code>不为NULL，且没有设置SHM_RND，则会被附加到<code>shmaddr</code>指定的地址处，它必须是系统分页大小的倍数</li>
<li>如果<code>shmaddr</code>不为NULL，并且设置了SHM_RND，那么段会被映射到的地址为在<code>shmaddr</code>中提供的地址被舍入到最近的常量SHMLBA（shared memory low boundaryaddress）的倍数。这个常量等于系统分页大小的某个倍数。</li>
</ul>
<p>要附加一个共享内存段以供只读访问，那么就需要在<code>shmflg</code>中指定SHM_RDONLY标记。如果在<code>shmflg</code>中指定了SHM_REMAP，在指定了这个标记之后<code>shmaddr</code>的值不能为NULL。这个标记要求<code>shmat()</code>调用替换起点在<code>shmaddr</code>处长度为共享内存段的长度的任何既有共享内存段或内存映射。</p>
<p>当一个进程不再需要访问一个共享内存段时就可以调用<code>shmdt()</code>，将该段分离出其虚拟地址空间。<code>shmaddr</code>参数标识出了待分离的段，它应该是由之前的<code>shmat()</code>调用返回的一个值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* shmaddr)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>通过<code>fork()</code>创建的子进程会继承其父进程附加的共享内存段。因此，共享内存为父进程和子进程之间的通信提供了一种简单的IPC 方法。</p>
<p>在<code>exec()</code>操作之后，所有附加的共享内存段都会被分离。在进程终止之后共享内存段也会自动被分离。</p>
<h3 id="控制操作"><a class="markdownIt-Anchor" href="#控制操作"></a> 控制操作</h3>
<p><code>shmctl()</code>系统调用在<code>shmid</code>标识的共享内存段上执行一组控制操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds* buf)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p><code>cmd</code>参数规定了待执行的控制操作，<code>buf</code>参数与控制操作有关，只有部分操作需要指定它的值，其余操作可以设为NULL。</p>
<p>可以执行的操作如下：</p>
<ul>
<li>常规控制操作：
<ul>
<li>IPC_RMID：标记这个共享内存段及其关联<code>shmid_ds</code>数据结构以便删除。如果当前没有进程附加该段，那么就会执行删除操作，否则就在所有进程都已经与该段分离（即当<code>shmid_ds</code>数据结构中<code>shm_nattch</code>字段的值为0 时）之后再执行删除操作。</li>
<li>IPC_STAT：将与这个共享内存段关联的<code>shmid_ds</code>数据结构的一个副本放置到<code>buf</code>指向的缓冲区中。</li>
<li>IPC_SET：使用<code>buf</code>指向的缓冲区中的值来更新与这个共享内存段相关联的<code>shmid_ds</code>数据结构中被选中的字段。</li>
</ul>
</li>
<li>加锁和解锁共享内存：
<ul>
<li>SHM_LOCK：操作将一个共享内存段锁进内存。</li>
<li>SHM_UNLOCK：操作为共享内存段解锁以允许它被交换出去。</li>
</ul>
</li>
</ul>
<h3 id="共享内存关联数据结构"><a class="markdownIt-Anchor" href="#共享内存关联数据结构"></a> 共享内存关联数据结构</h3>
<p>每个共享内存段都有一个关联的<code>shmid_ds</code>数据结构，其形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span> <span class="comment">//所有权和权限</span></span><br><span class="line">    <span class="keyword">size_t</span> shm_segsz; <span class="comment">//共享内存段所需要的字节数，即shmget()调用中size的值</span></span><br><span class="line">    <span class="keyword">time_t</span> shm_atime; <span class="comment">//在创建共享内存段时会将这个字段设置为0，当一个进程附加该段时会将这个字段设置为当前时间</span></span><br><span class="line">    <span class="keyword">time_t</span> shm_dtime; <span class="comment">//在创建共享内存段时会将这个字段设置为0，当一个进程与该段分离之后会将这个字段设置为当前时间</span></span><br><span class="line">    <span class="keyword">time_t</span> shm_ctime; <span class="comment">//当段被创建时以及每个成功的IPC_SET操作都会将这个字段设置为当前时间。</span></span><br><span class="line">    <span class="keyword">pid_t</span> shm_cpid; <span class="comment">//被设置成使用shmget()创建这个段的进程ID。</span></span><br><span class="line">    <span class="keyword">pid_t</span> shm_lpid; <span class="comment">//在创建共享内存段时会将这个字段设置为0，后续每个成功的shmat()或shmdt()调用会将这个字段设置成调用进程的ID。</span></span><br><span class="line">    <span class="keyword">shmatt_t</span> shm_nattch; <span class="comment">//统计当前附加该段的进程数。在创建段时会将这个字段初始化为0，然后每次成功的shmat()调用会递增这个字段的值，每次成功的shmdt()调用会递减这个字段的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="posix-ipc"><a class="markdownIt-Anchor" href="#posix-ipc"></a> POSIX IPC</h1>
<h2 id="简介-5"><a class="markdownIt-Anchor" href="#简介-5"></a> 简介</h2>
<p>POSIX.1b实时扩展定义了一组IPC机制，它们与System V IPC 机制类似。这组机制中包括消息队列、信号量和共享内存。它们的编程接口总结如下：</p>
<img data-src="image-20210716155455960.png" alt="image-20210716155455960" style="zoom:67%;" />
<p>要访问一个POSIX IPC对象就必须要通过某种方式来识别出它。规定的唯一一种用来标识POSIX IPC对象的可移植的方式是使用以斜线打头后面跟着一个或多个非斜线字符的名字，如<code>/myobject</code>。</p>
<h2 id="消息队列-2"><a class="markdownIt-Anchor" href="#消息队列-2"></a> 消息队列</h2>
<h3 id="打开-关闭和断开"><a class="markdownIt-Anchor" href="#打开-关闭和断开"></a> 打开、关闭和断开</h3>
<p>打开一个消息队列可以使用<code>mq_open</code>函数，调用成功则返回一个消息队列描述符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">mqd_t</span> <span class="title">mq_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> oflag, <span class="keyword">mode_t</span> mode, struct mq_attr* attr)</span></span>; <span class="comment">//成功则返回消息队列描述符，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>name</code>参数为消息队列的标识；<code>oflag</code>参数是位掩码，可以包含的值有O_CREAT、O_EXCL、O_RDONLY、O_WRONLY、O_RDWR和O_NONBLOCK；<code>mode</code>参数是一个位掩码，用于指定施加于消息队列的权限，它可取的值与文件上的掩码值一样；<code>attr</code>参数指定了新消息队列的特性，如果使用NULL则使用默认特性创建队列。</p>
<p>消息队列描述符和打开着的消息队列之间的关系，与文件描述符和打开着的文件描述符之间的关系类似。消息队列描述符是一个进程级别的句柄，它引用了系统中打开着的消息队列描述表中的一个条目，而该条目则引用了一个消息队列对象。</p>
<p>在<code>fork()</code>中，子进程会接收其父进程的消息队列描述符的副本，并且这些描述符会引用同样的打开着的消息队列描述符。当一个进程执行了一个<code>exec()</code>或终止时，所有其打开的消息队列描述符会被关闭。</p>
<p>消息队列的关闭使用<code>mq_close</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_close</span><span class="params">(<span class="keyword">mqd_t</span> mqdes)</span></span>; <span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p>关闭一个消息队列并不会删除该队列。要删除队列则需要使用<code>mq_unlink()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>; <span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>
<h3 id="消息队列特性"><a class="markdownIt-Anchor" href="#消息队列特性"></a> 消息队列特性</h3>
<p>消息队列所具有的特性被保存在<code>mq_attr</code>结构中，它的形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mq_attr</span>&#123;</span></span><br><span class="line">	<span class="keyword">long</span> mq_flags; <span class="comment">//消息队列特性标识符</span></span><br><span class="line">    <span class="keyword">long</span> mq_maxmsg; <span class="comment">//消息队列中最大的信息数量</span></span><br><span class="line">    <span class="keyword">long</span> mq_msgsize; <span class="comment">//消息队列中每条信息大小上限</span></span><br><span class="line">    <span class="keyword">long</span> mq_curmsgs; <span class="comment">//消息队列中目前的消息数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要获取一个消息队列的信息，可以使用<code>mq_getattr()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_getattr</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, struct mq_attr* attr)</span></span>; <span class="comment">//返回0代表成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>要修改消息队列特性，可以使用<code>mq_setattr()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_setattr</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> struct mq_attr* newattr, struct mq_attr* oldattr)</span></span>; <span class="comment">//返回0代表成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<h3 id="交换消息"><a class="markdownIt-Anchor" href="#交换消息"></a> 交换消息</h3>
<p>要发送消息到消息队列，可以使用<code>mq_send</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_send</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> <span class="keyword">char</span>* msg_ptr, <span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> <span class="keyword">int</span> msg_prio)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>msg_len</code>指定了<code>msg_ptr</code>指向的消息的长度，其值必须小于或等于队列的<code>mq_msgsize</code>特性，否则会返回EMSGSIZE错误。<code>msg_prio</code>表示消息的优先级，消息在队列中是按照优先级的倒序排列，0表示优先级最低。</p>
<p>如果消息队列已经满了（即已经达到了队列的<code>mq_maxmsg</code>限制），那么后续的<code>mq_send()</code>调用会阻塞直到队列中存在可用空间为止，或者在O_NONBLOCK标记起作用时立即失败并返回EAGAIN错误。</p>
<p><code>mq_receive</code>函数从<code>mqdes</code>引用的消息队列中删除一条优先级最高、存在时间最长的消息，并把删除的消息放置在<code>msg_ptr</code>指向的缓冲区：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">mq_receive</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">char</span>* msg_ptr, <span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> <span class="keyword">int</span>* msg_prio)</span></span>; <span class="comment">//成功则返回接收的字节数，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p>不管消息的实际大小是什么，<code>msg_len</code>（即<code>msg_ptr</code>指向的缓冲区的大小）必须要大于或等于队列的<code>mq_msgsize</code>特性，否则<code>mq_receive()</code>就会失败并返回EMSGSIZE错误。如果<code>msg_prio</code>不为NULL，那么接收到的消息的优先级会被复制到<code>msg_prio</code>指向的位置处。</p>
<p>如果消息队列当前为空，那么<code>mq_receive()</code>会阻塞直到存在可用的消息，或在O_NONBLOCK标记起作用时会立即失败并返回EAGAIN 错误。</p>
<p>如果要为发送和接收消息设置超时时间，则可以使用下面的两个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_timedsend</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> <span class="keyword">char</span>* msg_ptr, <span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> <span class="keyword">int</span> msg_prio, <span class="keyword">const</span> struct timespec* abs_timeout)</span></span>; <span class="comment">//成功则返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">mq_timedreceive</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">char</span>* msg_ptr, <span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> <span class="keyword">int</span>* msg_prio, <span class="keyword">const</span> struct timespec* abs_timeout)</span></span>; <span class="comment">//成功则返回接收的字节数，失败返回-1</span></span><br></pre></td></tr></table></figure>
<h3 id="消息通知"><a class="markdownIt-Anchor" href="#消息通知"></a> 消息通知</h3>
<p>POSIX 消息队列能够接收之前为空的队列上有可用消息的异步通知（即队列从空变成了非空）。这个特性意味着已经无需执行一个阻塞的调用，或将消息队列描述符标记为非阻塞并在队列上定期执行<code>mq_receive()</code>调用。进程可以选择通过信号的形式，或通过在一个单独的线程中调用一个函数的形式来接收通知。</p>
<p><code>mq_notify</code>函数使得调用进程在消息描述符<code>mqdes</code>引用的空队列有一条消息进入时，可以接收到通知：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_notify</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> struct sigevent* notification)</span></span>; <span class="comment">//成功则返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>notification</code>参数指定了进程接收通知的机制。</p>
<p>关于消息通知需要注意以下几点：</p>
<ul>
<li>在任何一个时刻都只有一个进程（“注册进程”）能够向一个特定的消息队列注册接收通知。也就是说一个消息队列只能接受一个进程的注册，只给该进程发送通知</li>
<li>只有当一条新消息进入之前为空的队列时，注册进程才会收到通知</li>
<li>当向注册进程发送了一个通知之后就会删除注册信息</li>
<li>只有当前不存在其他在该队列上调用<code>mq_receive()</code>而发生阻塞的进程时，注册进程才会收到通知。</li>
<li>一个进程可以通过在调用<code>mq_notify()</code>时传入一个值为NULL的<code>notification</code>参数，撤销自己在消息通知上的注册信息。</li>
</ul>
<h3 id="posix和system-v消息队列比较"><a class="markdownIt-Anchor" href="#posix和system-v消息队列比较"></a> POSIX和System V消息队列比较</h3>
<p>POSIX消息队列有如下优势：</p>
<ul>
<li>接口简单，且与传统的UNIX文件模型一致</li>
<li>使用引用计数，简化了确定何时删除一个对象的任务</li>
<li>消息通知特性允许一个（单个）进程能够在一条消息进入之前为空的队列时异步地通过信号或线程的实例化来接收通知。</li>
<li>在 Linux（不包括其他UNIX 实现）上可以使用<code>poll()</code>、<code>select()</code>以及<code>epoll</code>来监控POSIX消息队列</li>
</ul>
<p>但是POSIX消息队列也有一些劣势：</p>
<ul>
<li>可移植性稍差</li>
<li>POSIX消息队列严格按照优先级排序，不能像System V消息队列按照类型选择消息</li>
</ul>
<h2 id="信号量-2"><a class="markdownIt-Anchor" href="#信号量-2"></a> 信号量</h2>
<h3 id="概述-2"><a class="markdownIt-Anchor" href="#概述-2"></a> 概述</h3>
<p>POSIX信号量有两种：</p>
<ul>
<li>命名信号量：这种信号量拥有一个名字。通过使用相同的名字调用<code>sem_open()</code>，不相关的进程能够访问同一个信号量。</li>
<li>未命名信号量：这种信号量没有名字，相反，它位于内存中一个预先商定的位置处。未命名信号量可以在进程之间或一组线程之间共享。当在进程之间共享时，信号量必须位于一个共享内存区域中（System V、POSIX或<code>mmap()</code>）。当在线程之间共享时，信号量可以位于被这些线程共享的一块内存区域中（如在堆上或在一个全局变量中）。</li>
</ul>
<p>POSIX信号量的运作方式与System V信号量类似，即POSIX信号量是一个整数，其值是不能小于0 的。如果一个进程试图将一个信号量的值减小到小于0，那么取决于所使用的函数，调用会阻塞或返回一个表明当前无法执行相应操作的错误。</p>
<h3 id="命名信号量"><a class="markdownIt-Anchor" href="#命名信号量"></a> 命名信号量</h3>
<p>下列函数用于命名信号量的使用过程：</p>
<ul>
<li><code>sem_open()</code>函数打开或创建一个信号量并返回一个句柄以供后续调用使用，如果这个调用会创建信号量的话，还会对所创建的信号量进行初始化。</li>
<li><code>sem_post(sem)</code>和<code>sem_wait(sem)</code>函数分别递增和递减一个信号量值。</li>
<li><code>sem_getvalue()</code>函数获取一个信号量的当前值。</li>
<li><code>sem_close()</code>函数删除调用进程与它之前打开的一个信号量之间的关联关系。</li>
<li><code>sem_unlink()</code>函数删除一个命名信号量，并将其标记为在所有进程关闭该信号量时删除该信号量。</li>
</ul>
<p>打开命名信号量<code>sem_open()</code>函数的使用方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sem_t</span>* <span class="title">sem_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> oflag, <span class="keyword">mode_t</span> mode, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>; <span class="comment">//成功则返回信号量的一个指针，失败返回NULL</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>name</code>为信号量的名称，<code>oflag</code>参数是一个位掩码，它确定是打开一个已有的信号量（将<code>oflag</code>设置为0）还是创建并打开一个新的信号量（<code>oflag</code>的值为O_CREAT且<code>name</code>对应的信号量不存在）。如果这一函数被用来打开一个既有信号量，则调用时只需要传入<code>name</code>和<code>oflag</code>参数；如果要创建一个新的信号量，则还需要指定<code>mode</code>和<code>value</code>参数。其中<code>mode</code>是一个位掩码，指定了新信号量的权限，它可取的值与文件上的位值一样；<code>value</code>是一个无符号整数，指定了信号量的初始值。</p>
<p>当一个进程打开一个命名信号量时，系统会记录进程与信号量之间的关联关系。<code>sem_close()</code>函数会终止这种关联关系（即关闭信号量），释放系统为该进程关联到该信号量之上的所有资源，并递减引用该信号量的进程数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_close</span><span class="params">(<span class="keyword">sem_t</span>* sem)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>打开的命名信号量在进程终止或进程执行了一个<code>exec()</code>时会自动被关闭。</p>
<p>关闭一个信号量并不会删除这个信号量，而要删除信号量则需要使用<code>sem_unlink()</code>。<code>name</code>标识的信号量将会在所有进程都使用完这个信号量时就被销毁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<h3 id="信号量操作-2"><a class="markdownIt-Anchor" href="#信号量操作-2"></a> 信号量操作</h3>
<p>要等待一个信号量，可以使用下面的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span>* sem)</span></span>; <span class="comment">//如果信号量的值大于0，则函数立即返回，并将信号量的值减1；如果信号量等于0则会一直阻塞，直到信号量的值大于0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span>* sem)</span></span>; <span class="comment">//非阻塞版本，如果递减操作无法被立即执行则返回EAGAIN错误</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_timedwait</span><span class="params">(<span class="keyword">sem_t</span>* sem, <span class="keyword">const</span> struct timespec* abs_timeout)</span></span>; <span class="comment">//设定阻塞的时间限制，如果到达时间限制之后仍无法递减信号量，则返回ETIMEDOUT错误</span></span><br><span class="line"><span class="comment">//上面的函数返回0表示成功，返回-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>要发布一个信号量则可以使用<code>sem_post()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span>* sem)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p><code>sem_post()</code>调用会将<code>sem</code>引用信号量的值加1。如果在<code>sem_post</code>调用之前信号量的值为0，并且其它某个进程或者线程因等待递减这个信号量而阻塞，则等待进程会被唤醒。哪个等待进程会被唤醒与系统的调度策略有关。</p>
<p>要获取信号量的当前值，则可以使用<code>sem_getvalue()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_getvalue</span><span class="params">(<span class="keyword">sem_t</span>* sem, <span class="keyword">int</span>* sval)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>这一函数调用会将<code>sem</code>引用的信号量的当前值通过<code>sval</code>指向的变量返回。如果一个或多个进程（或线程）当前正在阻塞以等待递减信号量值，那么<code>sval</code>中的返回值将取决于实现，在Linux系统中会返回0。</p>
<h3 id="未命名信号量"><a class="markdownIt-Anchor" href="#未命名信号量"></a> 未命名信号量</h3>
<p>未命名信号量（也被称为基于内存的信号量）是类型为<code>sem_t</code>并存储在应用程序分配的内存中的变量。通过将这个信号量放在由几个进程或线程共性的内存区域中就能够使这个信号量对这些进程或线程可用。</p>
<p>操作未命名信号量所使用的函数与操作命名信号量使用的函数是一样的，除此之外还需要使用<code>sem_init()</code>和<code>sem_destroy(sem)</code>两个函数。</p>
<p><code>sem_init()</code>使用<code>value</code>参数指定的值，来对<code>sem</code>指向的未命名信号量进行初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span>* sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p><code>pshared</code>参数表明信号量是在线程还是进程间共享。如果<code>pshared</code>等于0，那么信号量将会在调用进程中的线程间进行共享。在这种情况下，<code>sem</code>通常被指定成一个全局变量的地址或分配在堆上的一个变量的地址。线程共享的信号量具备进程持久性，它在进程终止时会被销毁；如果<code>pshared</code>不等于0，那么信号量将会在进程间共享。在这种情况下，<code>sem</code>必须是共享内存区域（一个POSIX 共享内存对象、一个使用<code>mmap()</code>创建的共享映射、或一个System V共享内存段）中的某个位置的地址。</p>
<p>要销毁未命名信号量，则需要使用<code>sem_destroy()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span>* sem)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>这一函数将会销毁信号量<code>sem</code>，其中<code>sem</code>必须是一个之前使用<code>sem_init()</code>进行初始化的未命名信号量。只有不存在进程或者线程在等待一个信号量时，才能安全销毁这个信号量。</p>
<h2 id="共享内存-2"><a class="markdownIt-Anchor" href="#共享内存-2"></a> 共享内存</h2>
<h3 id="概述-3"><a class="markdownIt-Anchor" href="#概述-3"></a> 概述</h3>
<p>POSIX共享内存能够让无关进程共享一个映射区域而无需创建一个相应的映射文件。要使用 POSIX 共享内存对象需要完成下列任务。</p>
<ol>
<li>使用<code>shm_open()</code>函数打开一个与指定的名字对应的对象。<code>shm_open()</code>函数与<code>open()</code>系统调用类似，它会创建一个新共享对象或打开一个既有对象。<code>shm_open()</code>会返回一个引用该对象的文件描述符。</li>
<li>将上一步中获得的文件描述符传入<code>mmap()</code>调用并在其<code>flags</code>参数中指定MAP_SHARED。这会将共享内存对象映射进进程的虚拟地址空间。与<code>mmap()</code>的其他用法一样，一旦映射了对象之后就能够关闭该文件描述符而不会影响到这个映射。</li>
</ol>
<h3 id="创建共享内存对象"><a class="markdownIt-Anchor" href="#创建共享内存对象"></a> 创建共享内存对象</h3>
<p>创建一个共享内存对象的方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shm_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> oflag, <span class="keyword">mode_t</span> mode)</span></span>; <span class="comment">//成功则返回文件描述符，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>name</code>参数代表待创建或者打开的共享内存对象；<code>oflag</code>参数用于改变调用行为，可以对下面几个值取或运算：O_CREAT（如果对象不存在则创建对象）、O_EXCL（确保调用者是对象的创建者）、O_RDONLY（打开只读访问）、O_RDWR（打开读写访问）、O_TRUNC（将对象长度截断为0）。在一个新共享内存对象被创建时，其所有权和组所有权将根据调用<code>shm_open()</code>的进程的有效用户和组ID来设定，对象权限将会根据<code>mode</code>参数中设置的掩码值来设定。<code>mode</code>参数能取的位值与文件上的权限位值是一样的。</p>
<p><code>shm_open()</code>返回的文件描述符会设置<code>close-on-exec</code>标记，因此当程序执行了一个<code>exec()</code>时文件描述符会被自动关闭。</p>
<p>一个新共享内存对象被创建时其初始长度会被设置为0。这意味着在创建完一个新共享内存对象之后通常在调用<code>mmap()</code>之前需要调用<code>ftruncate()</code>来设置对象的大小，以及后续使用<code>ftruncate()</code>来扩大或者收缩共享内存对象。在扩展一个共享内存对象时，新增加的字节会被自动初始化为0。</p>
<p>在任何时候都可以在<code>shm_open()</code>返回的文件描述符上使用<code>fstat()</code>以获取一个<code>stat</code>结构，该结构的字段会包含与这个共享内存对象相关的信息。使用<code>fchmod()</code>和<code>fchown()</code>能够分别修改共享内存对象的权限和所有权。</p>
<h3 id="删除共享内存对象"><a class="markdownIt-Anchor" href="#删除共享内存对象"></a> 删除共享内存对象</h3>
<p>POSIX共享内存对象至少具备内核持久性，即它们会持续存在直到被显式删除或系统重启。当不再需要一个共享内存对象时就应该使用<code>shm_unlink()</code>删除它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shm_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p><code>shm_unlink()</code>函数会删除通过<code>name</code>指定的共享内存对象。删除一个共享内存对象不会影响对象的既有映射（它会保持有效直到相应的进程调用<code>munmap()</code>或终止），但会阻止后续的<code>shm_open()</code>调用打开这个对象。一旦所有进程都解除映射这个对象，对象就会被删除，其中的内容会丢失。</p>
<h1 id="socket"><a class="markdownIt-Anchor" href="#socket"></a> SOCKET</h1>
<h2 id="简介-6"><a class="markdownIt-Anchor" href="#简介-6"></a> 简介</h2>
<p>socket是一种IPC方法，它允许位于同一主机（计算机）或使用网络连接起来的不同主机上的应用程序之间交换数据。在一个典型的客户端/服务器场景中，应用程序使用socket进行通信的方式如下：</p>
<ul>
<li>各个应用程序创建一个socket</li>
<li>服务器将自己的socket绑定到一个地址上，使得客户端可以定位到它的位置</li>
</ul>
<p>socket存在于一个通信domain中，它确定了识别出一个socket的方法，并确定其通信范围。现代操作系统至少支持UNIX、IPv4和IPv6这三个domain。它们的区别如下图：</p>
<img data-src="image-20210719145219281.png" alt="image-20210719145219281" style="zoom:67%;" />
<p>每一个socket实现都至少提供了流和数据报这两种类型。流socket提供了一个可靠的双向字节流通信信道，可以保证发送的数据完整地到达接收端，但是数据不存在消息边界的概念。它类似于使用一对允许在两个应用程序之间双向通信的管道，但是socket允许在网络上进行通信。流socket的正常工作需要一对相互连接的socket，因此它也常常被称为面向连接的。</p>
<p>而数据报socket则允许数据以数据报的消息形式进行交换，因此数据的消息边界被保留下来。但是这种方式的数据传输是不可靠的，消息到达可能是无序的、重复的甚至无法到达。它属于无连接的socket。</p>
<h2 id="系统调用"><a class="markdownIt-Anchor" href="#系统调用"></a> 系统调用</h2>
<p>要创建一个socket，可以使用<code>socket()</code>系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>; <span class="comment">//成功则返回一个文件描述符，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p>其中<code>domain</code>参数指定了socket的通信domain；<code>type</code>参数指定了socket类型，创建流socket时为SOCK_STREAM，创建数据报socket时被设为SOCK_DGRAM；<code>protocol</code>参数通常被设置为0。</p>
<p>如果要将一个socket绑定到一个地址上，则可以使用<code>bind()</code>系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* addr, <span class="keyword">socklen_t</span> addrlen)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>sockfd</code>参数是一个<code>socket()</code>调用获得的文件描述符，<code>addr</code>参数为一个指针，指向socket绑定的地址的结构，这个数据结构类型取决于socket domain。<code>addrlen</code>参数则指定了地址结构数据的大小。一般来说，会将一个服务器的socket绑定到一个众所周知的地址，这个地址是固定的，且客户端应用程序提前知道。</p>
<p><code>sockaddr</code>数据结构的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family; <span class="comment">//即AF_*，代表socket的domain</span></span><br><span class="line">    <span class="keyword">char</span>* sa_data; <span class="comment">//socket地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要关闭一个socket，则可以使用<code>close()</code>函数，这会将双向通信通道的两端全部关闭。如果要实现更精确的控制，则可以使用<code>shutdown()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> how)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>how</code>参数的值可以为如下几种：</p>
<ul>
<li>SHUT_RD：关闭连接的读端，之后的读操作将会返回文件结尾</li>
<li>SHUT_WR：关闭连接的写端，后续再执行写操作则会产生SIGPIPE信号以及EPIPE错误</li>
<li>SHUT_RDWR：将连接的读写端全部关闭</li>
</ul>
<p>需要注意的是，<code>shutdown()</code>并不会关闭文件描述符，必须调用<code>close()</code>关闭。</p>
<h2 id="流socket"><a class="markdownIt-Anchor" href="#流socket"></a> 流socket</h2>
<p>流socket的运作原理如下：</p>
<ol>
<li><code>socket()</code>系统调用将会创建一个socket，这相当于安装一个电话。为了使得两个应用程序能够通信，每个应用程序都必须要创建一个socket。</li>
<li>一个应用程序在进行通信之前必须要将其socket连接到另一个应用程序的socket上。两个socket的连接过程如下：
<ol>
<li>一个应用程序调用<code>bind()</code>将socket绑定到一个地址上，然后调用<code>listen()</code>通知内核它接受接入连接的意愿。</li>
<li>其它应用程序通过调用<code>connect()</code>建立连接，同时指定需要连接的socket地址</li>
<li>调用<code>listen()</code>的应用程序使用<code>accept()</code>接受连接。如果在对等应用程序调用<code>connect()</code>之前执行了<code>accept()</code>，那么<code>accept()</code>操作会阻塞。</li>
</ol>
</li>
<li>一旦建立了一个连接之后，就可以在应用程序之间进行双向数据传输，直到其中一个使用<code>close()</code>关闭连接为止。通信是通过传统的<code>read()</code>和<code>write()</code>系统调用，或通过一些提供了额外功能的socket特定系统调用（如<code>send()</code>和<code>recv()</code>）来完成的。</li>
</ol>
<p>流socket通常可以分为主动和被动两种。在默认情况下，使用<code>socket()</code>创建的socket是主动的。一个主动的socket可用在<code>connect()</code>调用中，来建立一个到被动socket的连接。而一个被动socket（也被称为监听socket）是一个通过调用<code>listen()</code>以被标记成允许接入连接的socket。在大多数使用流socket的应用程序中，服务器会执行被动式打开，而客户端会执行主动式打开。</p>
<p>这一过程中涉及到的系统调用包括：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* addr, <span class="keyword">socklen_t</span>* addrlen)</span></span>; <span class="comment">//成功则返回文件描述符，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* addr, <span class="keyword">socklen_t</span> addrlen)</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<h2 id="数据报socket"><a class="markdownIt-Anchor" href="#数据报socket"></a> 数据报socket</h2>
<p>数据报socket的运作原理如下：</p>
<ol>
<li>所有需要发送和接收数据报的应用程序都需要使用<code>socket()</code>创建一个数据报socket。这可以理解为创建两个邮箱。</li>
<li>为允许另一个应用程序发送其数据报，一个应用程序需要使用<code>bind()</code>将其socket绑定到一个众所周知的地址上。一般来讲，一个服务器会将其socket绑定到一个众所周知的地址上，而一个客户端会通过向该地址发送一个数据报来发起通信。</li>
<li>要发送一个数据报，一个应用程序需要调用<code>sendto()</code>，它接收的其中一个参数是数据报发送到的socket的地址。</li>
<li>为接收一个数据报，一个应用程序需要调用<code>recvfrom()</code>，它在没有数据报到达时会阻塞。由于<code>recvfrom()</code>允许获取发送者的地址，因此可以在需要的时候发送一个响应。</li>
<li>当不再需要socket时，应用程序需要使用<code>close()</code>关闭socket。</li>
</ol>
<p>其中涉及到的系统调用有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buffer, <span class="keyword">size_t</span> length, <span class="keyword">int</span> flags, struct sockaddr* src_addr, <span class="keyword">socklen_t</span>* addrlen)</span></span>; <span class="comment">//成功则返回接收的字节数，如果返回0则代表EOF，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>* buffer, <span class="keyword">size_t</span> length, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr* dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>; <span class="comment">//成功返回发送的字节数，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p>其中<code>flags</code>是一个位掩码，控制socket特定的I/O特性。对于<code>recvfrom</code>函数来说，如果不关心发送者的地址，那么可以将<code>src_addr</code>和<code>addrlen</code>都指定为NULL，此时等价于使用<code>recv()</code>来接收一个数据报。</p>
<p>不管<code>length</code>的参数值是什么，<code>recvfrom()</code>只会从一个数据报socket中读取一条消息。如果消息的大小超过了length字节，那么消息会被静默地截断为length字节。</p>
<h2 id="unix-domain"><a class="markdownIt-Anchor" href="#unix-domain"></a> UNIX domain</h2>
<p>在UNIX domain中，socket地址使用路径名来表示，地址结构的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span>&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sun_family; <span class="comment">//总是等于AF_UNIX</span></span><br><span class="line">    <span class="keyword">char</span> sun_path[<span class="number">108</span>]; <span class="comment">//以NULL结尾的字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于UNIX domain socket的使用需要注意：</p>
<ul>
<li>无法将一个socket绑定到一个既有路径名上（<code>bind()</code>会失败并返回EADDRINUSE 错误）。通常会将一个socket绑定到一个绝对路径名上，这样这个socket就会位于文件系统中的一个固定地址处</li>
<li>一个socket只能绑定到一个路径名上，相应地，一个路径名只能被一个socket绑定</li>
<li>无法使用<code>open()</code>打开一个socket</li>
<li>当不再需要一个socket时，可以使用<code>unlink()</code>（或<code>remove()</code>）删除其路径名条目</li>
</ul>
<p>对于UNIX domain socket来讲，数据报的传输是在内核中发生的，并且也是可靠的。所有消息都会按顺序被递送，并且也不会发生重复的状况。</p>
<p>Linux 特有的一项特性是，它允许将一个UNIX domain socket绑定到一个名字上，但不会在文件系统中创建该名字。要创建一个抽象绑定，就需要将<code>sun_path</code>字段的第一个字节指定为null字节（\0）。这样就能够将抽象socket名字与传统的UNIX domain socket路径名区分开来。余下的字节为socket定义了抽象名称。</p>
<p>socket文件的所有权和权限决定了哪些进程能够与这个socket进行通信。</p>
<ul>
<li>要连接一个UNIX domain流socket，需要在该socket文件上拥有写权限。</li>
<li>要通过一个UNIX domain数据报socket发送一个数据报，需要在该socket文件上拥有写权限。</li>
<li>此外，需要在存放socket路径名的所有目录上都拥有执行（搜索）权限。</li>
</ul>
<p>有时候需要让单个进程创建一对socket并将它们连接起来。<code>socketpair</code>系统调用可以快捷地实现这一操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> sockfd[<span class="number">2</span>])</span></span>; <span class="comment">//返回0表示成功，-1表示失败</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>domain</code>参数必须为AF_UNIX，<code>type</code>可以为SOCK_DGRAM或SOCK_STREAM，<code>protocol</code>参数必须为0，<code>sockfd</code>数组返回引用这两个相互连接socket的文件描述符。</p>
<h2 id="internet-domain"><a class="markdownIt-Anchor" href="#internet-domain"></a> Internet domain</h2>
<p>Internet domain流socket是基于TCP之上的，它们提供了可靠的双向字节流通信信道。而Internet domain数据报socket是基于UDP之上的，它属于不可靠连接。Internet domain socket的地址有IPv4和IPv6两种，它们分别对应的数据结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family; <span class="comment">//总为AF_INET</span></span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port; <span class="comment">//网络字节序的端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">//地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> __pad[X]; <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span> s_addr; <span class="comment">//无符号的32位整数，代表IPv4的4字节地址，需要转为网络字节序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span>&#123;</span></span><br><span class="line">	<span class="keyword">sa_family_t</span> sin6_family; <span class="comment">//总为AF_INET6</span></span><br><span class="line">    <span class="keyword">in_port_t</span> sin6_port; <span class="comment">//端口号</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_flowinfo; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span> <span class="comment">//地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_scope_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> s6_addr[<span class="number">16</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用通用的<code>sockaddr_storage</code>结构，这个数据结构的空间足以存储任意类型的socket地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ss_aligntype uint32_t</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span>&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> ss_family;</span><br><span class="line">    __ss_aligntype __ss_align;</span><br><span class="line">    <span class="keyword">char</span> __ss_padding[SS_PADSIZE];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于IP地址在计算机中被存储为二进制形式，不方便阅读，下面两个函数可以方便将IPv4和IPv6地址的二进制形式和点分十进制表示法或者十六进制字符串表示法之间转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">char</span>* src_str, <span class="keyword">void</span>* addrptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">void</span>* addrptr, <span class="keyword">char</span>* dst_str, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>inet_pton()</code>用于将<code>src_str</code>中所包含的字符串转换为网络字节序的二进制IP地址，<code>domain</code>参数为AF_INET或者AF_INET6，转换得到的地址会被放在<code>addrptr</code>指向的结构中；而<code>inet_ntop()</code>函数执行逆向的转换，<code>addrptr</code>指向一个待转换的<code>in_addr</code>或者<code>in_addr6</code>结构，得到的字符串会被存放在<code>dst_str</code>指向的缓冲区中，<code>len</code>参数为缓冲区的大小。如果<code>len</code>的值太小，不足以存放转换后的地址，那么函数会返回NULL并将errno设置为ENOSPC。</p>
<p>为了正确计算缓冲区大小，可以使用下面两个常量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INET_ADDRSTRLEN 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INET6_ADDRSTRLEN 46</span></span><br></pre></td></tr></table></figure>
<p>一个多字节的整数可能会以大端序或者小端序这两种不同的顺序来存储。在特定主机上使用的字节序称为主机字节序，它与硬件架构有关；而在网络中传递的顺序被称为网络字节序，它被规定为大端序。因此，在将整数存储进socket地址结构之前则需要将这些值转换成网络字节序，可以使用下面四个函数完成这一操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> host_uint16)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unit32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> host_uint32)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> net_uint16)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> net_uint32)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="其它用法"><a class="markdownIt-Anchor" href="#其它用法"></a> 其它用法</h2>
<p><code>recv()</code>和<code>send()</code>这一组系统调用可以在已连接的套接字上执行I/O操作，它们提供了专属于套接字的功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buffer, <span class="keyword">size_t</span> length, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>* buffer, <span class="keyword">size_t</span> length, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，前3个参数于<code>read()</code>和<code>write()</code>一样，最后一个参数为位掩码，用于修改I/O操作的行为。</p>
<p>对于<code>recv</code>函数，<code>flags</code>可以取下面的值：</p>
<ul>
<li>MSG_DONTWAIT：让<code>recv</code>以非阻塞方式执行，如果没有数据可用则立即返回并生成错误码EAGAIN</li>
<li>MSG_OOB：在套接字上接收带外数据，带外数据指的是允许发送端将传输的数据标记为高优先级。任意时刻最多只有1字节数据可以被标记为带外数据。</li>
<li>MSG_PEEK：从套接字缓冲区中获取一份请求字节的副本，但不会将请求的字节从缓冲区中实际移除</li>
<li>MSG_WAITALL：如果无法接收<code>length</code>字节则会阻塞，直到可以从缓冲区接收<code>length</code>字节的数据</li>
</ul>
<p>而对于<code>send</code>函数，<code>flags</code>可以取下面的值：</p>
<ul>
<li>MSG_DONTWAIT：以非阻塞方式执行，如果没有数据可用则立即返回并生成错误码EAGAIN</li>
<li>MSG_MORE：在Linux系统下，如果指定了MSG_MORE 标记，那么数据会打包成一个单独的数据报。仅当下一次调用中没有指定该标记时，数据才会传输出去</li>
<li>MSG_NOSIGNAL：当在已连接的流式套接字上发送数据时，如果连接的另一端已经关闭了，指定该标记后将不会产生SIGPIPE信号。相反，<code>send()</code>调用会失败，伴随的错误码为EPIPE。</li>
<li>MSG_OOB：在流式套接字上发送带外数据</li>
</ul>
<p>如果要将磁盘上的文件内容不做修改地传出去，则可以使用<code>sendfile()</code>系统调用。此时，文件内容会被直接传送到套接字上，而不会经过用户空间，因此传输效率更高：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span>* offset, <span class="keyword">size_t</span> count)</span></span>; <span class="comment">//调用成功返回实际传输字节数，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>in_fd</code>代表输入文件描述符，<code>out_fd</code>代表输出文件描述符。要求<code>out_fd</code>必须指向一个套接字，而<code>in_fd</code>指向的文件可以进行<code>mmap()</code>操作。参数<code>offset</code>可以指向一个<code>off_t</code>类型的值，指定输入文件的偏移量，代表<code>in_fd</code>指向的文件从这一位置开始可以传输字节，此时数据传输不会修改<code>in_fd</code>的文件偏移量；也可以设置为NULL，此时会从当前的文件偏移量处开始传输，且传输时会更新文件偏移量。<code>count</code>参数指定了请求传输的字节数。</p>
<p>套接字选项能影响到套接字操作的多个功能。下面两个系统调用可以设定和获取套接字选项：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsocket</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span>* optval, <span class="keyword">socklen_t</span>* optlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsocket</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span>* optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>sockfd</code>代表指向套接字的文件描述符，<code>level</code>代表套接字选项适用的协议，<code>optname</code>标识了希望设定或者取出的套接字选项，<code>optval</code>是一个指向缓冲区的指针，用于指定或者返回选项的值，<code>optlen</code>指定了缓冲区的空间大小。</p>

      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/">未完成的技术文档</a></li>
            <li><a href="/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Linux/">LINUX</a></li>
            <li><a href="/%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Linux/Linux/">LINUX</a></li>
            <li>进程间通信</li>
          
  </ul>

    
    
    


        </div>
        
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yufei Luo</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">16:41</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动
  </div>

        






<script data-pjax>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"ypNNXSdcGIIoldC5BBmViS2g-gzGzoHsz","app_key":"0TDwohU7eO4yHTn4tley8PtE","server_url":"https://leancloud.cn/dashboard/data.html?appid=ypNNXSdcGIIoldC5BBmViS2g-gzGzoHsz#/","security":false};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="//cdn.jsdelivr.net/npm/ribbon.js@1/dist/ribbon.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/next-theme/pjax@0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  
  <script data-pjax>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>









<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>


    <div class="pjax">
  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">
  <script src="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css">


  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4dcdc02d24075b0e9d3a',
      clientSecret: '53cf2cb8b89b9d4bba922bb19bda1290f0d0bf95',
      repo        : 'lyf35.github.io',
      owner       : 'lyf35',
      admin       : ['lyf35'],
      id          : '659288eebe575eb77db0361842d2fc04',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
